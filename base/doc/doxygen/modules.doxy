/**
@page modules Description of Modules

SG++ is grouped into several modules. This ensures
- Modularity - not all parts are required for every task
- Usability - not everything has to be compiled 
- Flexibility - only parts of SG++ can be shipped
- Correctness - at least to some degree; if some part is modified, it will not influence others
- ...

The modules correspond (roughly) to the corresponding namespaces in C++. Roughly, as all files belonging to a namespace belong to the respective module. But a module can contain files belonging to another namespace, especially static factory methods in the namespace SGPP::op_factory.

@dot
digraph G {
	rankdir=BT;
	node [shape=polygon,fontsize=10,height=0.25];
	edge [group];
	
	{ rank=same; datadriven; solver; combigrid; }

	base [URL="@ref SGPP::base"];
	pde [URL="@ref SGPP::pde"];
	datadriven [URL="@ref SGPP::datadriven"];
	finance [URL="@ref SGPP::finance"];
	solver [URL="@ref SGPP::solver"];
	parallel [URL="@ref SGPP::parallel"];
	combigrid [URL=""];

	pde -> base;
	pde -> solver;
	datadriven -> base;
	finance -> pde;
	finance -> base;
	solver -> base;
	parallel -> base;
	parallel -> pde;
	parallel -> finance;
	parallel -> datadriven [constraint=false];
	combigrid -> base;
}
@enddot

The modules can depdend on each other. Especially all depend on the base module.
Libraries are generated for all modules, named sgppbase, sgpppde, etc. The following table briefly summarizes the main contents of each module:
<table>
   <tr>
     <td valign="top">
       base
     </td>
     <td>
       - the main SGPP::base::Grid class
       - different types of sparse grids (with or without grid points on the boundary etc.)
       - different types of basis function (piecewise linear/polynomial, b-splines, pre-wavelets, ...)
       - the underlying data structures
       - data types (SGPP::base::DataVector and SGPP::base::DataMatrix)
       - basic operations such as hierarchization and dehierarchization
       - evaluation, evaluation of multiple data points
       - adaptive refinement
       - refinement specified via functors
       - quadrature
       - basic OpenMP support
     </td>
   </tr>
   <tr>
     <td valign="top">
       datadriven
     </td>
     <td>
       - operations depending on datasets
       - data mining support
       - specialized regularization
       - vectorization of evaluation of multiple on x86
     </td>
   </tr>
   <tr>
     <td valign="top">
       pde
     </td>
     <td>
       - support for elliptic and parabolic PDEs
       - algorithms (esp. UpDown schemes) for different PDEs
       - different boundary conditions (Dirichlet, Neumann)
       - simple applications
     </td>
   </tr>
   <tr>
     <td valign="top">
       solver
     </td>
     <td>
       - solver (CG, ...)
       - time-stepping schemes
     </td>
   </tr>
   <tr>
     <td valign="top">
       finance
     </td>
     <td>
       - support for the solution of financial problems
       - Black-Scholes equation
       - Hull-White equation (1d,2d)
       - algorithmic schemes to support this
     </td>
   </tr>
   <tr>
     <td valign="top">
       parallel
     </td>
     <td>
       - MPI-based parallelization
       - hardware-tuned and -aware algorithms
     </td>
   </tr>
   <tr>
     <td valign="top">
       combigrid
     </td>
     <td>
       - combination technique
       - special variants
       - data structures and algorithms
       - dimensional adaptivity
     </td>
   </tr>
      <tr>
     <td valign="top">
       parallel
     </td>
     <td>
       - extension to datadriven, finance and pde
       - sophisticated parallelizations using GPUs (datadriven)
       - MPI parallelization of PDE solvers
     </td>
   </tr>
</table>

*/
