/**
@page code_examples_quick_start Quick-Start: Short Code Examples

To be able to quickly start with a toolkit, it is often advantageous
(not only for the impatient users), to look at some code examples
first. As SG++ can be used from within different programming
languages, we provide a short example for some of them. They show
nicely the differences between the different types of usage. Sooner or
later they will be extended to additional functionality and more
programming languages.

To this end, we create a regular sparse grid with level three in two dimensions
using piecewise linear basis functions without gridpoints on the
boundary. We then interpolate the function 
@f[ f(x_0,x_1) := 16 * (x_0-1)*x_0 * (x_1-1)*x_1 @f]
with
@f[ u(x_0,x_1) := \sum_{j=1}^N \alpha_j \varphi_j(x_0,x_1) @f]
by setting the coefficients @f$\alpha_j@f$ to the function values of
@f$f@f$ at the corresponding grid points. Then we hierarchize it,
transforming the function values at the grid points into hierarchical
coefficients. Finally, we evaluate the sparse grid function @f$u@f$ at
@f$(0.52,0.73)@f$.



@section code_examples__overview Overview
- \ref code_examples__python
 - \ref code_examples__python_linebyline
- \ref code_examples__cpp
 - \ref code_examples__cpp_linebyline
- \ref code_examples__java
 - \ref code_examples__java_linebyline
- \ref code_examples__matlab
 - \ref code_examples__matlab_linebyline



@section code_examples__python Python

First, the whole code of file python_simple.py at once, as it can be
found in the directory @c base/examples/, which we then discuss line by line.

@include python_simple.py
which can be executed by
@code
export LD_LIBRARY_PATH="/path/to/SGpp/trunk/lib/sgpp"
export PYTHONPATH="/path/to/SGpp/trunk/lib/pysgpp"
python python_simple.py
@endcode 
in the directory @c base/examples/.
Keep in mind that you need to seed the @c LD_LIBRARY_PATH and @c PYTHONPATH
environment variables correctly, allowing Python to find pysgpp and SG++.

This results in the output
@include all_simple.output.txt
It can be clearly seen that the surplusses decay with a factor of 1/4:
On the first level, we obtain 1, on the second 1/4, and on the third
1/16 as surplusses.



@subsection code_examples__python_linebyline Explanations line by line

@dontinclude python_simple.py
@until pysgpp
We import the pysgpp classes which we require afterwards,
with the most important being SGPP::base::DataVector and SGPP::base::Grid.

@until dimensionality
creates a two-dimensional grid object with piecewise bilinear basis
functions with the help of the factory method
SGPP::base::Grid.createLinearGrid().
Then we obtain a reference to the Grid's 
GridStorage object which allows us, e.g., to access grid
points, to obtain the dimensionality (which we print) and the
number of grid points.

@until number
Here, we use a SGPP::base::GridGenerator to
create a regular sparse grid of level 3.
Thus, @c gridStorage.size() returns 17, the number of grid points
of a two-dimensional regular sparse grid of level 3.

@until length
Now we create an object of type SGPP::base::DataVector which has as many
entries as there are grid points. It serves as a coefficient vector for the
sparse grid interpolant we want to construct. As the entries of a
freshly created DataVector are not initialized, we set them to
0.0. (This is superfluous here as we initialize them in the
next few lines anyway.)

@until alpha before hierarchization
Here, the function @f$f@f$, which we want to interpolate, is defined.
The @c for loop iterates over all grid points: For each grid
point @c gp, the corresponding coefficient @f$\alpha_j@f$ is set to the
function value at the grid point's coordinates which are obtained by
@c getCoord(dim).
The current coefficient vector is then printed.

@until alpha after hierarchization
An object SGPP::base::OperationHierarchisation is created and used to
hierarchize the coefficient vector, which we print.

@until u(
Finally, a second DataVector is created which is used as a point to
evaluate the sparse grid function. An object is obtained which
provides an evaluation operation, and the sparse grid interpolant is
evaluated close to (but not exactly at) a grid point.



@section code_examples__cpp C++

Again, we first show the whole code of file c++_simple.cpp at once,
as it can be found in the directory @c base/examples/, which we then discuss
line by line.

@include c++_simple.cpp

The example can be compiled, linked, and executed by
@code
g++ -o c++_simple.o -c -std=c++11 -I../src c++_simple.cpp
g++ -o c++_simple -fopenmp c++_simple.o -L/path/to/SGpp/trunk/lib/sgpp -lsgppbase
export LD_LIBRARY_PATH="/path/to/SGpp/trunk/lib/sgpp"
./c++_simple
@endcode
running in the directory @c base/examples/.
Note that you have to set the @c LD_LIBRARY_PATH
environment variable to be able to use the shared library.

This results in the same output as before:

@include all_simple.output.txt



@subsection code_examples__cpp_linebyline Explanations line by line

@dontinclude c++_simple.cpp
@until SGPP::base;
Apart from iostream, we have to include the header files of all
classes we are using. Finally, we import the namespaces @c std and (to
simplify the example) SGPP::base.

@until }
defines the function @f$f@f$ we want to interpolate.

@until dimensionality
creates a two-dimensional grid object with piecewise bilinear basis
functions with the help of the factory method
SGPP::base::Grid.createLinearGrid().
Then we obtain a reference to the Grid's 
GridStorage object which allows us, e.g., to access grid
points, to obtain the dimensionality (which we print) and the
number of grid points.

@until number
Here, we use a SGPP::base::GridGenerator to
create a regular sparse grid of level 3.
Thus, @c gridStorage.size() returns 17, the number of grid points
of a two-dimensional regular sparse grid of level 3.

@until length
Now we create an object of type SGPP::base::DataVector which has as many
entries as there are grid points. It serves as a coefficient vector for the
sparse grid interpolant we want to construct. As the entries of a
freshly created DataVector are not initialized, we set them to
0.0. (This is superfluous here as we initialize them in the
next few lines anyway.)

@until alpha before hierarchization
The @c for loop iterates over all grid points: For each grid
point @c gp, the corresponding coefficient @f$\alpha_j@f$ is set to the
function value at the grid point's coordinates which are obtained by
@c getCoord(dim).
The current coefficient vector is then printed.

@until alpha after hierarchization
An object SGPP::base::OperationHierarchisation is created and used to
hierarchize the coefficient vector, which we print.

@until u(
Finally, a second DataVector is created which is used as a point to
evaluate the sparse grid function. An object is obtained which
provides an evaluation operation, and the sparse grid interpolant is
evaluated close to (but not exactly at) a grid point.



@section code_examples__java Java

Again, we first show the whole code of file java_simple.java at once, as it
can be
found in the directory @c base/examples/, which we then discuss line by line.

@include java_simple.java

For the compilation and execution of the example,
we change to the directory @c base/examples/ and run
@code
javac -cp .:/path/to/SGpp/trunk/lib/jsgpp/jsgpp.jar java_simple.java
export LD_LIBRARY_PATH="/path/to/SGpp/trunk/lib/sgpp:/path/to/SGpp/trunk/lib/jsgpp"
java -cp .:/path/to/SGpp/trunk/lib/jsgpp/jsgpp.jar java_simple
@endcode 
Note that you have to set the @c LD_LIBRARY_PATH
environment variable to be able to use the shared library.

This results in (nearly) the same output as before:

@include all_simple.output.txt



@subsection code_examples__java_linebyline Explanations line by line

@dontinclude java_simple.java
@until sgpp.OperationEval;
We can import the whole @c .jar file as in the second line or, better,
just import the class files we use.

@until }
defines the function @f$f@f$ we want to interpolate.

@until loadJSGPPLib
Two possibilities of loading the libjsgpp.so shared object library file,
which is needed to find the methods.

@until dimensionality
creates a two-dimensional grid object with piecewise bi-linear basis
functions with the help of the factory method
SGPP::base::Grid.createLinearGrid().
Then we obtain a reference to the Grid's 
GridStorage object which allows us, e.g., to access grid
points, to obtain the dimensionality (which we print) and the
number of grid points.

@until number
Here, we use a SGPP::base::GridGenerator to
create a regular sparse grid of level 3.
Thus, @c gridStorage.size() returns 17, the number of grid points
of a two-dimensional regular sparse grid of level 3.

@until length
Now we create an object of type SGPP::base::DataVector which has as many
entries as there are grid points. It serves as a coefficient vector for the
sparse grid interpolant we want to construct. As the entries of a
freshly created DataVector are not initialized, we set them to
0.0. (This is superfluous here as we initialize them in the
next few lines anyway.)

@until alpha before hierarchization
The @c for loop iterates over all grid points: For each grid
point @c gp, the corresponding coefficient @f$\alpha_j@f$ is set to the
function value at the grid point's coordinates which are obtained by
@c getCoord(dim).
The current coefficient vector is then printed.

@until alpha after hierarchization
An object sgpp.jsgpp.OperationHierarchisation is created and used to
hierarchize the coefficient vector, which we print.

@until u(
Finally, a second DataVector is created which is used as a point to
evaluate the sparse grid function. An object is obtained which
provides an evaluation operation, and the sparse grid interpolant is
evaluated close to (but not exactly at) a grid point.



@section code_examples__matlab MATLAB

As in the previous sections, we first show the whole code of file
matlab_simple.m at once, as it can be
found in the directory @c base/examples/, which we then discuss line by line.

@include matlab_simple.m

MATLAB can use SGpp via Java, i.e. we use the Java library of SGpp and import
it to MATLAB.
Before we can use these methods in MATLAB, we have to add the path to the
@c libjsgpp.so file to the librarypath.txt file of MATLAB.
(Hint: Typing @c matlabroot in MATLAB returns the path to your MATLAB
installation.)
Open the file @c /path/to/MATLAB/toolbox/local/librarypath.txt in a text editor
and add the line
@code
/path/to/SGpp/trunk/lib/jsgpp
@endcode
at the end of the file.
After adding this line, we can start MATLAB.
However, we have to set the environment variables @c LD_LIBRARY_PATH and
@c LD_PRELOAD:
@code
export LD_LIBRARY_PATH="/path/to/SGpp/trunk/lib/sgpp:/path/to/SGpp/trunk/lib/jsgpp"
export LD_PRELOAD="/usr/lib/x86_64-linux-gnu/libstdc++.so.6"
matlab
@endcode
The variable @c LD_LIBRARY_PATH has to be set to allow MATLAB to find
the shared libraries.
However, MATLAB ships its own version of @c libstdc++
(usually in @c /path/to/MATLAB/sys/os/glnxa64) and adds its location
to MATLAB's internal @c LD_LIBRARY_PATH.
Since this version of @c libstdc++ is most likely incompatible with the
version used to compile SG++, you will get errors like this
when executing matlab_simple in MATLAB:
@code
Error using matlab_simple (line 5)
Java exception occurred:
java.lang.UnsatisfiedLinkError: /path/to/SGpp/trunk/lib/jsgpp/libjsgpp.so:
/path/to/MATLAB/bin/glnxa64/libstdc++.so.6: version
`GLIBCXX_3.4.20' not found (required by /path/to/SGpp/trunk/lib/jsgpp/libjsgpp.so)
        at java.lang.ClassLoader$NativeLibrary.load(Native Method)
        at java.lang.ClassLoader.loadLibrary1(Unknown Source)
        at java.lang.ClassLoader.loadLibrary0(Unknown Source)
        at java.lang.ClassLoader.loadLibrary(Unknown Source)
        at java.lang.Runtime.loadLibrary0(Unknown Source)
        at java.lang.System.loadLibrary(Unknown Source)
        at sgpp.LoadJSGPPLib.loadJSGPPLib(LoadJSGPPLib.java:10)
@endcode
To work around this issue, set the @c LD_PRELOAD variable
to load the correct version @c libstdc++ before calling MATLAB.
You can find the correct version by examining the output of
@code
ldd /path/to/SGpp/trunk/lib/jsgpp/libjsgpp.so
@endcode
and searching for a line containing @c libstdc++.
On my Ubuntu system, it was located in
@c /usr/lib/x86_64-linux-gnu/libstdc++.so.6,
but it can differ on other systems.

In MATLAB, we have to add the @c jsgpp.jar file, doing this with
the command
@code
javaaddpath('/path/to/SGpp/trunk/lib/jsgpp/jsgpp.jar')
@endcode
We can now change to the directory @c base/examples/ and run the matlab_simple
example with
@code
matlab_simple
@endcode 

This results in the same output as before:

@include all_simple.output.txt



@subsection code_examples__matlab_hints Hints
Use
@code
javaclasspath
@endcode
to see the loaded jar files (upper part static, lower
part dynamic; our jsgpp.jar should be in the latter part).
Write
@code
import sgpp.*
@endcode
in MATLAB to not have to write @c sgpp. in front of every method.
Call
@code
methods('sgpp.Classname')
@endcode
to see all methods of the class "Classname" (e.g. @c Grid).
The methods itself can now also be called like Java methods in the MATLAB
command window, e.g.
@code
dataVector = sgpp.DataVector(10)
dataVector.setAll(0)
dataVector
@endcode



@subsection code_examples__matlab_linebyline Explanations line by line

@dontinclude matlab_simple.m
@until loadJSGPPLib
Method to load the libjsgpp.so library.
As you can see, the methods are called in Java syntax.

@until sgpp.OperationEval;
We can import the whole @c .jar file as in the second line or, better,
just import the class files we use.

@until x1
defines the function @f$f@f$ we want to interpolate.

@until dimensionality
creates a two-dimensional grid object with piecewise bi-linear basis
functions with the help of the factory method
SGPP::base::Grid.createLinearGrid().
Then we obtain a reference to the Grid's 
GridStorage object which allows us, e.g., to access grid
points, to obtain the dimensionality (which we print) and the
number of grid points.

@until number
Here, we use a sgpp.GridGenerator to
create a regular sparse grid of level 3.
Thus, @c gridStorage.size() returns 17, the number of grid points
of a two-dimensional regular sparse grid of level 3.

@until length
Now we create an object of type SGPP::base::DataVector which has as many
entries as there are grid points. It serves as a coefficient vector for the
sparse grid interpolant we want to construct. As the entries of a
freshly created DataVector are not initialized, we set them to
0.0. (This is superfluous here as we initialize them in the
next few lines anyway.)

@until alpha before hierarchization
The @c for loop iterates over all grid points: For each grid
point @c gp, the corresponding coefficient @f$\alpha_j@f$ is set to the
function value at the grid point's coordinates which are obtained by
@c getCoord(dim).
The current coefficient vector is then printed.
Attention has to be paid on the different syntax in indexing the array between
MATLAB and Java.
Java starts with 0, MATLAB with 1!

@until alpha after hierarchization
An object sgpp.jsgpp.OperationHierarchisation is created and used to
hierarchize the coefficient vector, which we print.

@until u(
Finally, a second DataVector is created which is used as a point to
evaluate the sparse grid function. An object is obtained which
provides an evaluation operation, and the sparse grid interpolant is
evaluated close to (but not exactly at) a grid point.
*/
