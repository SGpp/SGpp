// Copyright (C) 2008-today The SG++ project
// This file is part of the SG++ project. For conditions of distribution and
// use, please see the copyright notice provided with SG++ or at
// sgpp.sparsegrids.org

#ifndef FUNDAMENTAL_SPLINE_MODIFIED_BASE_HPP
#define FUNDAMENTAL_SPLINE_MODIFIED_BASE_HPP

#include <cmath>
#include <stdexcept>
#include <sgpp/base/operation/hash/common/basis/Basis.hpp>
#include <sgpp/base/operation/hash/common/basis/FundamentalSplineBasis.hpp>
#include <sgpp/base/operation/hash/common/basis/BsplineBasis.hpp>
#include <sgpp/base/operation/hash/common/basis/BsplineModifiedBasis.hpp>

#include <sgpp/globaldef.hpp>

namespace SGPP {
  namespace base {

    /**
     * Modified fundamental spline basis on Noboundary grids.
     */
    template <class LT, class IT>
    class FundamentalSplineModifiedBasis: public Basis<LT, IT> {
      public:
        /**
         * Default constructor.
         */
        FundamentalSplineModifiedBasis() :
          fundamentalSplineBasis(FundamentalSplineBasis<LT, IT>()),
          xCut(NAN),
          linearSlope(NAN),
          splineScaling(NAN) {
        }

        /**
         * Constructor.
         *
         * @param degree    fundamental spline degree, must be odd
         *                  (if it's even, degree - 1 is used)
         */
        FundamentalSplineModifiedBasis(size_t degree) :
          fundamentalSplineBasis(FundamentalSplineBasis<LT, IT>(degree)) {
          switch (fundamentalSplineBasis.getDegree()) {
            case 1:
              xCut = 1.0;
              linearSlope = -1.0;
              splineScaling = 1.0;
              break;
            case 3:
              xCut = 1.612004618869898;
              linearSlope = -1.054831764407937;
              splineScaling = 0.784812708970871;
              break;
            case 5:
              xCut = 1.628269758166734;
              linearSlope = -1.046604143563875;
              splineScaling = 0.765581551691929;
              break;
            default:
              throw std::invalid_argument("Degree is unsupported.");
          }
        }

        /**
         * @param l     level of basis function
         * @param i     index of basis function
         * @param x     evaluation point
         * @return      value of modified fundamental spline basis function
         */
        inline float_t eval(LT l, IT i, float_t x) {
          /*const float_t t = x * hInv - 1.0 +
                            static_cast<float_t>(p + 1) / 2.0;
          float_t y = coefficients[0] *
                      bsplineModifiedBasis.modifiedBSpline(x * hInvDbl, p);

          for (size_t k = 1; k < coefficients.size(); k++) {
            y += coefficients[k] *
                 bsplineBasis.uniformBSpline(t - static_cast<float_t>(k), p);
          }*/



          /*const size_t p = bsplineBasis.getDegree();
          const float_t t = x * hInv + static_cast<float_t>(p);
          float_t y = 0.0;

          for (size_t k = 0; k < coefficients.size(); k++) {
            y += coefficients[k] * bsplineBasis.uniformBSpline(
                   t - static_cast<float_t>(k), p);
          }

          return y;*/



          if (l == 1) {
            return 1.0;
          }

          const IT hInv = static_cast<IT>(1) << l;

          if ((i != 1) && (i != hInv - 1)) {
            return fundamentalSplineBasis.eval(l, i, x);
          }

          if (i == hInv - 1) {
            // mirror the situation at x = 0.5
            x = 1.0 - x;
            i = 1;
          }

          const float_t hInvDbl = static_cast<float_t>(hInv);

          if (x * hInvDbl < xCut) {
            return linearSlope * (x * hInvDbl - 1.0) + 1.0;
          } else {
            return splineScaling * fundamentalSplineBasis.eval(l, i, x);
          }
        }

        /**
         * @param l     level of basis function
         * @param i     index of basis function
         * @param x     evaluation point
         * @return      value of derivative of modified
         *              fundamental spline basis function
         */
        inline float_t evalDx(LT l, IT i, float_t x) {
          /*const float_t t = x * hInv - 1.0 +
                            static_cast<float_t>(p + 1) / 2.0;
          float_t y = coefficients[0] *
                      bsplineModifiedBasis.modifiedBSplineDx(x * hInvDbl, p);

          for (size_t k = 1; k < coefficients.size(); k++) {
            y += coefficients[k] *
                 bsplineBasis.uniformBSplineDx(t - static_cast<float_t>(k), p);
          }*/



          /*const size_t p = bsplineBasis.getDegree();
          const float_t t = x * hInv + static_cast<float_t>(p);
          float_t y = 0.0;

          for (size_t k = 0; k < coefficients.size(); k++) {
            y += coefficients[k] * bsplineBasis.uniformBSplineDx(
                   t - static_cast<float_t>(k), p);
          }

          return dxFactor * y;*/



          if (l == 1) {
            return 0.0;
          }

          const IT hInv = static_cast<IT>(1) << l;

          if ((i != 1) && (i != hInv - 1)) {
            return fundamentalSplineBasis.evalDx(l, i, x);
          }

          const float_t hInvDbl = static_cast<float_t>(hInv);
          // inner derivative
          float_t dxFactor = 1.0;

          if (i == hInv - 1) {
            // mirror the situation at x = 0.5
            x = 1.0 - x;
            i = 1;
            dxFactor = -1.0;
          }

          if (x * hInvDbl < xCut) {
            return dxFactor * linearSlope * hInvDbl;
          } else {
            return dxFactor * splineScaling *
                fundamentalSplineBasis.evalDx(l, i, x);
          }
        }

        /**
         * @param l     level of basis function
         * @param i     index of basis function
         * @param x     evaluation point
         * @return      value of 2nd derivative of modified
         *              fundamental spline basis function
         */
        inline float_t evalDxDx(LT l, IT i, float_t x) {
          /*const float_t t = x * hInv - 1.0 +
                            static_cast<float_t>(p + 1) / 2.0;
          float_t y = coefficients[0] *
                      bsplineModifiedBasis.modifiedBSplineDxDx(x * hInvDbl, p);

          for (size_t k = 1; k < coefficients.size(); k++) {
            y += coefficients[k] *
                 bsplineBasis.uniformBSplineDxDx(
                   t - static_cast<float_t>(k), p);
          }*/



          /*const size_t p = bsplineBasis.getDegree();
          const float_t t = x * hInv + static_cast<float_t>(p);
          float_t y = 0.0;

          for (size_t k = 0; k < coefficients.size(); k++) {
            y += coefficients[k] * bsplineBasis.uniformBSplineDxDx(
                   t - static_cast<float_t>(k), p);
          }

          return dxFactor * y;*/



          if (l == 1) {
            return 0.0;
          }

          const IT hInv = static_cast<IT>(1) << l;

          if ((i != 1) && (i != hInv - 1)) {
            return fundamentalSplineBasis.evalDxDx(l, i, x);
          }

          const float_t hInvDbl = static_cast<float_t>(hInv);

          if (i == hInv - 1) {
            // mirror the situation at x = 0.5
            x = 1.0 - x;
            i = 1;
          }

          if (x * hInvDbl < xCut) {
            return 0.0;
          } else {
            return splineScaling * fundamentalSplineBasis.evalDxDx(l, i, x);
          }
        }

        /**
         * @return      B-spline degree
         */
        inline size_t getDegree() const {
          return fundamentalSplineBasis.getDegree();
        }

      protected:
        /// fundamental spline basis for fundamental spline evaluation
        FundamentalSplineBasis<LT, IT> fundamentalSplineBasis;
        float_t xCut;
        float_t linearSlope;
        float_t splineScaling;
    };

    // default type-def (unsigned int for level and index)
    typedef FundamentalSplineModifiedBasis<unsigned int, unsigned int>
    SFundamentalSplineModifiedBase;
  }
}

#endif /* FUNDAMENTAL_SPLINE_MODIFIED_BASE_HPP */
