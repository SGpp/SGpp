# Copyright (C) 2008-today The SG++ project
# This file is part of the SG++ project. For conditions of distribution and
# use, please see the copyright notice provided with SG++ or at
# sgpp.sparsegrids.org


import os
import fnmatch
import subprocess

Import('env')
Import('BUILD_DIR')
Import('PYSGPP_BUILD_PATH')
Import('moduleName')
Import('libraryTargetList')
Import('installTargetList')
Import('exampleTargetList')

moduleDependencies = []
Export('moduleDependencies')

if env['USE_OCL']:
    moduleDependencies += ['OpenCL']

# srcs = []
# for currentFolder, subdirNames, fileNames in os.walk("."):
#     if currentFolder.startswith("./src"):
#         for fileName in fnmatch.filter(fileNames, '*.cpp'):
#             srcs.append(os.path.join(currentFolder, fileName))
# 
# objs = []
# for sourceFile in srcs:
#     objs.append(env.SharedObject(sourceFile))
    
objs = []
for currentFolder, subdirNames, fileNames in os.walk("src", topdown=True):
  if os.path.exists(os.path.join(currentFolder, "SConscript")):
    objsSubmodule = env.SConscript(os.path.join(currentFolder, "SConscript"))
    objs += objsSubmodule
    # remove subfolders from iteration, as they are already processed (this is why topdown=True is also required
    subdirNames[:] = []
  else:
    for fileName in fnmatch.filter(fileNames, '*.cpp'):
      sourceFile = os.path.join(currentFolder, fileName)
      objs.append(env.SharedObject(sourceFile))

libname = "sgpp%s" % moduleName
if env['USE_STATICLIB']:
    libname += "static"
    for i, _ in enumerate(moduleDependencies):
        moduleDependencies[i] = "%sstatic" % moduleDependencies[i]
Export('libname')

if env['USE_STATICLIB']:
    # building static libraries is the same for unix and windows platforms
    lib = env.StaticLibrary(target=libname,
                            source=objs,
                            LIBS=moduleDependencies)
else:
    # building shared libraries differ
    if env['PLATFORM'] in ['cygwin', 'win32']:
        # remove old moduleDependencies if they exist already
        for ext in ['lib', 'exp', 'dll', 'def']:
            newlibFilename = "%s.%s" % (libname, ext)
            if os.path.exists(newlibFilename):
               os.remove(newlibFilename)
    
        def buildDefFile(target, source, env):
            # load all object files
            win32objs = []
            for currentFolder, subdirNames, fileNames in os.walk(os.path.join(moduleName, "src")):
                for fileName in fnmatch.filter(fileNames, '*.obj'):
                    win32objs.append(os.path.join(currentFolder, fileName))
            # build windows module definition file (def-file)
            subprocess.call(['bindexplib.exe', '-o', os.path.join(moduleName, '%s.def' % libname), os.path.join(moduleName, '%s.dll' % libname)] + win32objs)

        cmd = env.Command('buildDefFile', [], buildDefFile)
        lib = env.SharedLibrary(target=libname,
                                source=objs,
                                LIBPATH=BUILD_DIR,
                                LIBS=moduleDependencies,
                                LINKFLAGS=['/DEF:' + os.path.join(moduleName, '%s.def' % libname)])

        env.Depends(cmd, objs)
        env.Depends(lib, cmd)
    else:
        lib = env.SharedLibrary(target=libname,
                                source=objs,
                                LIBS=moduleDependencies)

libInstall = env.Install(BUILD_DIR, lib)

for fileName in os.listdir("examples"):
    if fnmatch.fnmatch(fileName, "*.cpp"):
        example = env.Program(source=os.path.join("examples", fileName),
                              LIBPATH=BUILD_DIR,
                              LIBS=[libname] + moduleDependencies)
        env.Requires(example, libInstall)
        exampleTargetList.append(example)

# build unit tests
if env['COMPILE_BOOST_TESTS']:
    Import('boostTestTargetList')
    test_env = env.Clone()
    boostlib = "boost_unit_test_framework"
    if env['PLATFORM'] == 'win32':
        test_env.Append(CPPFLAGS=['/DBOOST_ALL_DYN_LINK', '/MD', '/D _WIN32'])
        test_env.AppendUnique(LIBS=moduleDependencies + [libname])
    else:
        test_env.AppendUnique(LIBS=moduleDependencies + [libname, boostlib])
    
    testObjects = []
    for currentFolder, subdirNames, fileNames in os.walk("tests", topdown=True):
      for fileName in fnmatch.filter(fileNames, '*.cpp'):
        testObjects.append(test_env.SharedObject(os.path.join(currentFolder, fileName)))
    if len(testObjects) > 0:
        fileName = os.path.join("tests", "test_{}_boost".format(moduleName))
        executable = fileName
        test = test_env.Program(executable, testObjects)
        test_env.Requires(test, libInstall)
        if env['RUN_BOOST_TESTS']:
            executable = fileName + "_run"
            testRun = test_env.BoostTest(executable, source=fileName)
            boostTestTargetList.append(testRun)

libraryTargetList.append(lib)
installTargetList.append(libInstall)

