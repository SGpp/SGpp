<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Combigrid Example (Python)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_combigrid_py.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Combigrid Example (Python)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example, we use the combigrid module to interpolate a test function on a two-dimensional regular sparse grid with the combination technique and hierarchical B-splines.</p>
<p>First, we import the required modules. </p><div class="fragment"><div class="line"><span class="keyword">import</span> pysgpp</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> sys</div>
<div class="line"> </div>
<div class="line"><span class="comment"># skip plotting if Matplotlib cannot be imported (e.g., not installed or no GUI available)</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">  <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line">  <span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div>
<div class="line">  doPlot = <span class="keyword">True</span></div>
<div class="line"><span class="keywordflow">except</span> ImportError:</div>
<div class="line">  doPlot = <span class="keyword">False</span></div>
</div><!-- fragment --><p>Next, we define a helper function for plotting the resulting functions. </p><div class="fragment"><div class="line"><span class="keyword">def </span>plotFunction(opEval, surpluses, X):</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keywordflow">not</span> doPlot: <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># generate a meshgrid for plotting</span></div>
<div class="line">  xx0 = np.linspace(0, 1, 65)</div>
<div class="line">  xx1 = np.linspace(0, 1, 65)</div>
<div class="line">  XX0, XX1 = np.meshgrid(xx0, xx1)</div>
<div class="line">  XX = pysgpp.DataMatrix(np.column_stack([XX0.flatten(), XX1.flatten()]))</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># evaluate interpolant at meshgrid</span></div>
<div class="line">  YY = pysgpp.DataVector(0)</div>
<div class="line">  opEval.multiEval(surpluses, XX, YY)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># convert resulting sgpp::base::DataVector to NumPy array</span></div>
<div class="line">  YY = np.reshape(np.array([YY[k] <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(YY.getSize())]), XX0.shape)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># actual plotting</span></div>
<div class="line">  fig = plt.figure(figsize=(6, 6))</div>
<div class="line">  ax = fig.gca(projection=<span class="stringliteral">&quot;3d&quot;</span>)</div>
<div class="line">  ax.plot_surface(XX0, XX1, YY)</div>
<div class="line">  ax.plot(X[:,0], X[:,1], <span class="stringliteral">&quot;k.&quot;</span>, zs=<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(X[:,0], X[:,1]), ms=10)</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
</div><!-- fragment --><p>We define some parameters such as dimensionality and level of the regular sparse grid. </p><div class="fragment"><div class="line"><span class="comment"># dimensionality</span></div>
<div class="line">dim = 2</div>
<div class="line"><span class="comment"># regular level</span></div>
<div class="line">n = 4</div>
<div class="line"><span class="comment"># B-spline degree</span></div>
<div class="line">p = 3</div>
<div class="line"><span class="comment"># whether there are points on the boundary</span></div>
<div class="line">hasBoundary = <span class="keyword">True</span></div>
<div class="line"><span class="comment"># test function</span></div>
<div class="line">f = <span class="keyword">lambda</span> XX0, XX1: np.sin(7*XX0-3)*np.cos(5*XX1-5)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># disable log output</span></div>
<div class="line">pysgpp.Printer.getInstance().setVerbosity(-1)</div>
</div><!-- fragment --><p>The basis functions are defined via an <a class="el" href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html" title="Potentially hetereogeneous basis on full grids, i.e., a dim-dimensional vector of 1D bases of type sg...">sgpp::combigrid::HeterogeneousBasis</a> object. In contrast to <a class="el" href="classsgpp_1_1base_1_1Basis.html" title="Basis class for basis functions.">sgpp::base::Basis</a>, this allows for different types of basis functions for the different dimensions. However, for this example, we do not need this flexibility, so we use the same basis function types for both dimensions. </p><div class="fragment"><div class="line">basis1d = pysgpp.SBsplineBase(p)</div>
<div class="line">basis = pysgpp.HeterogeneousBasis(dim, basis1d)</div>
</div><!-- fragment --><p>An <a class="el" href="classsgpp_1_1combigrid_1_1CombinationGrid.html" title="Class for representing a collection of full grids together with one scalar coefficient per full grid.">sgpp::combigrid::CombinationGrid</a> is a collection of full grids (nodal subspaces) together with scalar-valued coefficients. Here, we construct an <a class="el" href="classsgpp_1_1combigrid_1_1CombinationGrid.html" title="Class for representing a collection of full grids together with one scalar coefficient per full grid.">sgpp::combigrid::CombinationGrid</a> object for a regular sparse grid via the combination technique. </p><div class="fragment"><div class="line">combiGrid = pysgpp.CombinationGrid.fromRegularSparse(dim, n, basis, hasBoundary)</div>
</div><!-- fragment --><p>We obtain the grid points of the regular sparse grid by combining the grid points of all full grids that are contained in the combination grid. </p><div class="fragment"><div class="line">gridStorage = pysgpp.HashGridStorage(dim)</div>
<div class="line">combiGrid.combinePoints(gridStorage)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># convert grid storage to array with coordinates of grid points</span></div>
<div class="line">X = np.array([[gridStorage.getPoint(k).getStandardCoordinate(d) <span class="keywordflow">for</span> d <span class="keywordflow">in</span> range(dim)]</div>
<div class="line">              <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(gridStorage.getSize())])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># evaluate test function at grid points</span></div>
<div class="line">fX = pysgpp.DataVector(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(X[:,0], X[:,1]))</div>
</div><!-- fragment --><p>We now want to perform an operation on each full grid. For this, we distribute the values of the combined grid (sparse grid) to the full grids. The result is a <code>std::vector</code> of <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a>; each <code>DataVector</code> contains the values at all grid points for one specific full grid. </p><div class="fragment"><div class="line">values = pysgpp.DataVectorVector()</div>
<div class="line">combiGrid.distributeValuesToFullGrids(gridStorage, fX, values)</div>
</div><!-- fragment --><p>The operation we want to perform on each full grid is hierarchization. Since the grids are full grids, we can use the unidirectional principle for this, which performs 1D hierarchization on each pole (one-dimensional sub-grid), iterating over all dimensions. </p><div class="fragment"><div class="line"><span class="comment"># copy the values (surpluses will be modified in-place)</span></div>
<div class="line">surpluses = pysgpp.DataVectorVector(values)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create pole operation</span></div>
<div class="line">opPole = pysgpp.OperationPoleVector()</div>
<div class="line">pysgpp.OperationPoleHierarchisationGeneral.fromHeterogenerousBasis(basis, opPole)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create operation for unidirectional principle and hierarchize in-place</span></div>
<div class="line">opHier = pysgpp.OperationUPCombinationGrid(combiGrid, opPole)</div>
<div class="line">opHier.apply(surpluses)</div>
</div><!-- fragment --><p>The resulting surpluses are also a <code>std::vector</code> of <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a>, separated by full grids. We could combine the full grid surpluses via the combination formula to the sparse grid surpluses via <code>combineSparseGridValues</code>. However, the operation <a class="el" href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html" title="Operation for evaluating a combination grid function (linear combination of linear combinations of fu...">sgpp::combigrid::OperationEvalCombinationGrid</a> does this automatically.</p>
<p>We evaluate the combined function (combination of all full grid interpolants) at some arbitrary point, print the value, and plot the function. </p><div class="fragment"><div class="line"><span class="comment"># test point at which to evaluate</span></div>
<div class="line">x = [0.12, 0.34]</div>
<div class="line">xDv = pysgpp.DataVector(x)</div>
<div class="line">print(<span class="stringliteral">&quot;Value of test function at {}: {:.6g}&quot;</span>.format(np.array(x), <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(*x)))</div>
<div class="line"><span class="comment"># create operation for evaluating and evaluate</span></div>
<div class="line">opEval = pysgpp.OperationEvalCombinationGrid(combiGrid)</div>
<div class="line">y = opEval.eval(surpluses, xDv)</div>
<div class="line">print(<span class="stringliteral">&quot;Value of combined sparse grid interpolant at {}: {:.6g}&quot;</span>.format(np.array(x), y))</div>
<div class="line"><span class="comment"># plot</span></div>
<div class="line">plotFunction(opEval, surpluses, X)</div>
</div><!-- fragment --><p>Finally, we do the same for one full grid of the combination grid: We evaluate and plot the corresponding interpolant. We extract the surpluses from the already calculated <code>vector</code> of <code>DataVector</code>. Alternatively, we could also apply <a class="el" href="classsgpp_1_1combigrid_1_1OperationUPFullGrid.html" title="Operation for applying 1D OperationPole operators on all poles of a full grid in all dimensions via t...">sgpp::combigrid::OperationUPFullGrid</a> with opPole to obtain the surpluses for this single full grid. </p><div class="fragment"><div class="line"><span class="comment"># select the second full grid of the combination grid (arbitrary choice)</span></div>
<div class="line">fullGridIndex = 1</div>
<div class="line">fullGrid = combiGrid.getFullGrids()[fullGridIndex]</div>
<div class="line">l = fullGrid.getLevel()</div>
<div class="line">print(<span class="stringliteral">&quot;Level of selected full grid with index {}: {}&quot;</span>.format(fullGridIndex, np.array(l)))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># create operation for evaluating and evaluate</span></div>
<div class="line">opEval = pysgpp.OperationEvalFullGrid(fullGrid)</div>
<div class="line">y = opEval.eval(surpluses[fullGridIndex], xDv)</div>
<div class="line">print(<span class="stringliteral">&quot;Value of full grid interpolant at {}: {:.6g}&quot;</span>.format(np.array(x), y))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># compute grid points of full grid</span></div>
<div class="line">X = pysgpp.DataMatrix(0, 0)</div>
<div class="line">pysgpp.IndexVectorRange.getPoints(fullGrid, X)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># convert resulting sgpp::base::DataMatrix to NumPy array</span></div>
<div class="line">X = np.array([[X.get(k, j) <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(X.getNcols())] <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(X.getNrows())])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># plot</span></div>
<div class="line">plotFunction(opEval, surpluses[fullGridIndex], X)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> doPlot: plt.show()</div>
<div class="line"><span class="keywordflow">else</span>: print(<span class="stringliteral">&quot;Skipping plots due to failed import of Matplotlib.&quot;</span>)</div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">Value of test function at [0.12 0.34]: 0.820974
Value of combined sparse grid interpolant at [0.12 0.34]: 0.774666
Level of selected full grid with index 1: [3 1]
Value of full grid interpolant at [0.12 0.34]: 0.564036
</pre><p>We see that the value of the combined sparse grid interpolant at the evaluation point is closer to the actual value of the test function than the value of the chosen full grid interpolant, which corresponds to the full grid of level \((3, 1)\). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_py.html">Python Examples</a></li>
    <li class="footer">Generated on Mon Feb 24 2025 09:21:46 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
