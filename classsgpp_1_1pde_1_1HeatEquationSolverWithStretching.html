<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: sgpp::pde::HeatEquationSolverWithStretching Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sgpp::pde::HeatEquationSolverWithStretching Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class provides a simple-to-use solver of the multi dimensional Heat Equation that uses Sparse Grids.  
 <a href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#details">More...</a></p>

<p><code>#include &lt;HeatEquationSolverWithStretching.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sgpp::pde::HeatEquationSolverWithStretching:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.png" usemap="#sgpp::pde::HeatEquationSolverWithStretching_map" alt=""/>
  <map id="sgpp::pde::HeatEquationSolverWithStretching_map" name="sgpp::pde::HeatEquationSolverWithStretching_map">
<area href="classsgpp_1_1pde_1_1ParabolicPDESolver.html" title="This class extends the PDESolver with functions that are needed to solve parabolic PDEs." alt="sgpp::pde::ParabolicPDESolver" shape="rect" coords="0,56,264,80"/>
<area href="classsgpp_1_1pde_1_1PDESolver.html" title="This class provides defines a implements basic task and tools which are useful while solving PDEs." alt="sgpp::pde::PDESolver" shape="rect" coords="0,0,264,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75dd73d88817b024255854ad9ee0851e" id="r_a75dd73d88817b024255854ad9ee0851e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a75dd73d88817b024255854ad9ee0851e">constructGrid</a> (<a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;myStretching, size_t <a class="el" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>)</td></tr>
<tr class="memdesc:a75dd73d88817b024255854ad9ee0851e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this routine the construct a regular grid to solve a PDE.  <br /></td></tr>
<tr class="separator:a75dd73d88817b024255854ad9ee0851e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac81680ff24ab68b9237acbffc54669" id="r_aaac81680ff24ab68b9237acbffc54669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">constructGrid</a> (<a class="el" href="classsgpp_1_1base_1_1Stretching.html">sgpp::base::Stretching</a> &amp;myStretching, size_t <a class="el" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>)</td></tr>
<tr class="separator:aaac81680ff24ab68b9237acbffc54669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993915578e28e38ac683a897783bfbb7" id="r_a993915578e28e38ac683a897783bfbb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a993915578e28e38ac683a897783bfbb7">HeatEquationSolverWithStretching</a> ()</td></tr>
<tr class="memdesc:a993915578e28e38ac683a897783bfbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Constructor of the solver.  <br /></td></tr>
<tr class="separator:a993915578e28e38ac683a897783bfbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcd2ef641164314d24780a562c62f88" id="r_a8dcd2ef641164314d24780a562c62f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8dcd2ef641164314d24780a562c62f88">initGridWithSmoothHeat</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double <a class="el" href="AugmentedLagrangian_8cpp.html#a74577585cf12d1712ab9c57616d49205">mu</a>, double sigma, double factor)</td></tr>
<tr class="memdesc:a8dcd2ef641164314d24780a562c62f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits the grid in the middle of the whole domain with one single heat.  <br /></td></tr>
<tr class="separator:a8dcd2ef641164314d24780a562c62f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84f238b0b47f3bdb919d29bb78d9ec0" id="r_ab84f238b0b47f3bdb919d29bb78d9ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#ab84f238b0b47f3bdb919d29bb78d9ec0">initScreen</a> ()</td></tr>
<tr class="memdesc:ab84f238b0b47f3bdb919d29bb78d9ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inits the grid with a constant heat.  <br /></td></tr>
<tr class="separator:ab84f238b0b47f3bdb919d29bb78d9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d08080266d2a23666361030910f4ae" id="r_a06d08080266d2a23666361030910f4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a06d08080266d2a23666361030910f4ae">printGrid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t PointesPerDimension, std::string tfilename) const</td></tr>
<tr class="memdesc:a06d08080266d2a23666361030910f4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is some kind of debug functionality.  <br /></td></tr>
<tr class="separator:a06d08080266d2a23666361030910f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b842e84c97d964e4cdd65efcbf63d0f" id="r_a4b842e84c97d964e4cdd65efcbf63d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a4b842e84c97d964e4cdd65efcbf63d0f">printGridDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t PointesPerDimension, <a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;GridArea, std::string tfilename) const</td></tr>
<tr class="memdesc:a4b842e84c97d964e4cdd65efcbf63d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a placeholder, is not used.  <br /></td></tr>
<tr class="separator:a4b842e84c97d964e4cdd65efcbf63d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25c8115e2d2f00da1ffa78b3c49616d" id="r_ae25c8115e2d2f00da1ffa78b3c49616d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#ae25c8115e2d2f00da1ffa78b3c49616d">printGridDomainStretching</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t PointesPerDimension, <a class="el" href="classsgpp_1_1base_1_1Stretching.html">sgpp::base::Stretching</a> &amp;GridArea, std::string tfilename) const</td></tr>
<tr class="memdesc:ae25c8115e2d2f00da1ffa78b3c49616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is some kind of debug functionality.  <br /></td></tr>
<tr class="separator:ae25c8115e2d2f00da1ffa78b3c49616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ff946fa227995f2c9da26a40e7f89c" id="r_aa2ff946fa227995f2c9da26a40e7f89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa2ff946fa227995f2c9da26a40e7f89c">printSparseGrid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::string tfilename, bool bSurplus) const</td></tr>
<tr class="memdesc:aa2ff946fa227995f2c9da26a40e7f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus.  <br /></td></tr>
<tr class="separator:aa2ff946fa227995f2c9da26a40e7f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21274ef0d75e14039d98ef16ec5bd2" id="r_a7a21274ef0d75e14039d98ef16ec5bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a7a21274ef0d75e14039d98ef16ec5bd2">printSparseGridExpTransform</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::string tfilename, bool bSurplus) const</td></tr>
<tr class="memdesc:a7a21274ef0d75e14039d98ef16ec5bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus.  <br /></td></tr>
<tr class="separator:a7a21274ef0d75e14039d98ef16ec5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7bb45dc1b34d92d18e6cc8977f3567" id="r_a8d7bb45dc1b34d92d18e6cc8977f3567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8d7bb45dc1b34d92d18e6cc8977f3567">setHeatCoefficient</a> (double a)</td></tr>
<tr class="memdesc:a8d7bb45dc1b34d92d18e6cc8977f3567"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the heat coefficient of the regarded material.  <br /></td></tr>
<tr class="separator:a8d7bb45dc1b34d92d18e6cc8977f3567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61ab5f30a7b33949bf765d240039897" id="r_aa61ab5f30a7b33949bf765d240039897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa61ab5f30a7b33949bf765d240039897">solveCrankNicolson</a> (size_t numTimesteps, double timestepsize, size_t maxCGIterations, double epsilonCG, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t NumImEul=0)</td></tr>
<tr class="memdesc:aa61ab5f30a7b33949bf765d240039897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this routine to use the Crank Nicolson algorithm to solve the parabolic PDE.  <br /></td></tr>
<tr class="separator:aa61ab5f30a7b33949bf765d240039897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830bd0a65ab2cb7624786c71bba5cc67" id="r_a830bd0a65ab2cb7624786c71bba5cc67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a830bd0a65ab2cb7624786c71bba5cc67">solveExplicitEuler</a> (size_t numTimesteps, double timestepsize, size_t maxCGIterations, double epsilonCG, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, bool verbose=false, bool generateAnimation=false)</td></tr>
<tr class="memdesc:a830bd0a65ab2cb7624786c71bba5cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  <br /></td></tr>
<tr class="separator:a830bd0a65ab2cb7624786c71bba5cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333b0cfdf1d92be4b35623773100247d" id="r_a333b0cfdf1d92be4b35623773100247d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a333b0cfdf1d92be4b35623773100247d">solveImplicitEuler</a> (size_t numTimesteps, double timestepsize, size_t maxCGIterations, double epsilonCG, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, bool verbose=false, bool generateAnimation=false)</td></tr>
<tr class="memdesc:a333b0cfdf1d92be4b35623773100247d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this routine to use an explicit Euler algorithm to solve the parabolic PDE.  <br /></td></tr>
<tr class="separator:a333b0cfdf1d92be4b35623773100247d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d444fb44a239d46ab93bf8b9ab06e5" id="r_a80d444fb44a239d46ab93bf8b9ab06e5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a80d444fb44a239d46ab93bf8b9ab06e5">~HeatEquationSolverWithStretching</a> ()</td></tr>
<tr class="memdesc:a80d444fb44a239d46ab93bf8b9ab06e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Destructor of the solver.  <br /></td></tr>
<tr class="separator:a80d444fb44a239d46ab93bf8b9ab06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html">sgpp::pde::ParabolicPDESolver</a></td></tr>
<tr class="memitem:ab2d6a8aeffbc0834b03afd517c22e117 inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver" id="r_ab2d6a8aeffbc0834b03afd517c22e117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html#ab2d6a8aeffbc0834b03afd517c22e117">ParabolicPDESolver</a> ()</td></tr>
<tr class="memdesc:ab2d6a8aeffbc0834b03afd517c22e117 inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">the size of one timestep  <br /></td></tr>
<tr class="separator:ab2d6a8aeffbc0834b03afd517c22e117 inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600c31cc5079cbd74e53e49af4160bef inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver" id="r_a600c31cc5079cbd74e53e49af4160bef"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html#a600c31cc5079cbd74e53e49af4160bef">~ParabolicPDESolver</a> ()</td></tr>
<tr class="memdesc:a600c31cc5079cbd74e53e49af4160bef inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Destructor of the solver.  <br /></td></tr>
<tr class="separator:a600c31cc5079cbd74e53e49af4160bef inherit pub_methods_classsgpp_1_1pde_1_1ParabolicPDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsgpp_1_1pde_1_1PDESolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsgpp_1_1pde_1_1PDESolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html">sgpp::pde::PDESolver</a></td></tr>
<tr class="memitem:aef887e4ad90f9ee170fdce53ac4f6bb8 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_aef887e4ad90f9ee170fdce53ac4f6bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aef887e4ad90f9ee170fdce53ac4f6bb8">coarsenInitialGridSurplus</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold)</td></tr>
<tr class="memdesc:aef887e4ad90f9ee170fdce53ac4f6bb8 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsens a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:aef887e4ad90f9ee170fdce53ac4f6bb8 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0311f95d9cf104d382f4093e8e80283 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_ae0311f95d9cf104d382f4093e8e80283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid</a> ()</td></tr>
<tr class="memdesc:ae0311f95d9cf104d382f4093e8e80283 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the grid created within that solver  <br /></td></tr>
<tr class="separator:ae0311f95d9cf104d382f4093e8e80283 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89db95e3e95b25eefb5013f9439560c0 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a89db95e3e95b25eefb5013f9439560c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a89db95e3e95b25eefb5013f9439560c0">evaluateCuboid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;FunctionValues, <a class="el" href="classsgpp_1_1base_1_1DataMatrix.html">sgpp::base::DataMatrix</a> &amp;EvaluationPoints)</td></tr>
<tr class="memdesc:a89db95e3e95b25eefb5013f9439560c0 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the sparse grid's function given by the stored grid and the alpha coefficients.  <br /></td></tr>
<tr class="separator:a89db95e3e95b25eefb5013f9439560c0 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8f8b9e656279c6b14bf27e4ee1082 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a92a8f8b9e656279c6b14bf27e4ee1082"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a92a8f8b9e656279c6b14bf27e4ee1082">evaluatePoint</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;evalPoint, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>)</td></tr>
<tr class="memdesc:a92a8f8b9e656279c6b14bf27e4ee1082 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the value of the function in the d-dimensional space.  <br /></td></tr>
<tr class="separator:a92a8f8b9e656279c6b14bf27e4ee1082 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eb3364a1bca298cb3d30f417ac9291 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a40eb3364a1bca298cb3d30f417ac9291"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a40eb3364a1bca298cb3d30f417ac9291">getGrid</a> () const</td></tr>
<tr class="memdesc:a40eb3364a1bca298cb3d30f417ac9291 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the a string the describes the grid which is currently used to solve  <br /></td></tr>
<tr class="separator:a40eb3364a1bca298cb3d30f417ac9291 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bcff79a5a69e8f065621c4a637dd9b inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a59bcff79a5a69e8f065621c4a637dd9b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a59bcff79a5a69e8f065621c4a637dd9b">getNumberDimensions</a> () const</td></tr>
<tr class="memdesc:a59bcff79a5a69e8f065621c4a637dd9b inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this the determine the number of dimensions that are currently used in the solver.  <br /></td></tr>
<tr class="separator:a59bcff79a5a69e8f065621c4a637dd9b inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6815ca45215bb246e21862ca281390 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_aab6815ca45215bb246e21862ca281390"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab6815ca45215bb246e21862ca281390">getNumberGridPoints</a> () const</td></tr>
<tr class="memdesc:aab6815ca45215bb246e21862ca281390 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to determine the number of grid points, used to solve the current problem  <br /></td></tr>
<tr class="separator:aab6815ca45215bb246e21862ca281390 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45128f2082e8d53a167c2a90bfdd7e83 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a45128f2082e8d53a167c2a90bfdd7e83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a45128f2082e8d53a167c2a90bfdd7e83">getNumberInnerGridPoints</a> () const</td></tr>
<tr class="memdesc:a45128f2082e8d53a167c2a90bfdd7e83 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to determine the number of inner grid points, used to solve the current problem  <br /></td></tr>
<tr class="separator:a45128f2082e8d53a167c2a90bfdd7e83 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79313aacae20fce23c6e8abdc3305d45 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a79313aacae20fce23c6e8abdc3305d45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a79313aacae20fce23c6e8abdc3305d45">PDESolver</a> ()</td></tr>
<tr class="memdesc:a79313aacae20fce23c6e8abdc3305d45 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Constructor of the solver.  <br /></td></tr>
<tr class="separator:a79313aacae20fce23c6e8abdc3305d45 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefbaefea95d2606fc318fcb1d1196e6 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_abefbaefea95d2606fc318fcb1d1196e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abefbaefea95d2606fc318fcb1d1196e6">printLevelIndexGrid</a> (std::string tfilename) const</td></tr>
<tr class="memdesc:abefbaefea95d2606fc318fcb1d1196e6 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the level,index pairs of the grid for each Gridpoint to a file.  <br /></td></tr>
<tr class="separator:abefbaefea95d2606fc318fcb1d1196e6 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4c77f046a5e6c883af2a4301462cdf inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a7b4c77f046a5e6c883af2a4301462cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7b4c77f046a5e6c883af2a4301462cdf">refineInitialGridSurplus</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, int numRefinePoints, double dThreshold)</td></tr>
<tr class="memdesc:a7b4c77f046a5e6c883af2a4301462cdf inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a7b4c77f046a5e6c883af2a4301462cdf inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166862b23257a31d1dca95f3e2b7431 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a3166862b23257a31d1dca95f3e2b7431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, int numRefinePoints, double dThreshold, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a3166862b23257a31d1dca95f3e2b7431 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a3166862b23257a31d1dca95f3e2b7431 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47e14878284049156d5e63e5217986 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_abb47e14878284049156d5e63e5217986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abb47e14878284049156d5e63e5217986">refineInitialGridSurplusToMaxLevel</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold, <a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a> maxLevel)</td></tr>
<tr class="memdesc:abb47e14878284049156d5e63e5217986 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:abb47e14878284049156d5e63e5217986 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481446a6b4cc4f10f5f26b383417c968 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a481446a6b4cc4f10f5f26b383417c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold, <a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a> maxLevel, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a481446a6b4cc4f10f5f26b383417c968 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a481446a6b4cc4f10f5f26b383417c968 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc81f7ec6fcf8216c478ca2237b1a0ae inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_adc81f7ec6fcf8216c478ca2237b1a0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid</a> (const std::string &amp;serializedGrid)</td></tr>
<tr class="memdesc:adc81f7ec6fcf8216c478ca2237b1a0ae inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the grid used in this BlackScholes Solver by an given serialized string of the grid.  <br /></td></tr>
<tr class="separator:adc81f7ec6fcf8216c478ca2237b1a0ae inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917d693b9b3f883d88dcb6f54041784 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a7917d693b9b3f883d88dcb6f54041784"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7917d693b9b3f883d88dcb6f54041784">~PDESolver</a> ()</td></tr>
<tr class="memdesc:a7917d693b9b3f883d88dcb6f54041784 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Destructor of the solver.  <br /></td></tr>
<tr class="separator:a7917d693b9b3f883d88dcb6f54041784 inherit pub_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classsgpp_1_1pde_1_1PDESolver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsgpp_1_1pde_1_1PDESolver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html">sgpp::pde::PDESolver</a></td></tr>
<tr class="memitem:a9827af10992190a4f3c1fb12af05b833 inherit pro_methods_classsgpp_1_1pde_1_1PDESolver" id="r_a9827af10992190a4f3c1fb12af05b833"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a9827af10992190a4f3c1fb12af05b833 inherit pro_methods_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates for every grid point the value of a normal distribution given by norm_mu and norm_sigma.  <br /></td></tr>
<tr class="separator:a9827af10992190a4f3c1fb12af05b833 inherit pro_methods_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classsgpp_1_1pde_1_1PDESolver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html">sgpp::pde::PDESolver</a></td></tr>
<tr class="memitem:ac46f28fe1db45d35b227e62d3ac7a0f5 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_ac46f28fe1db45d35b227e62d3ac7a0f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a></td></tr>
<tr class="memdesc:ac46f28fe1db45d35b227e62d3ac7a0f5 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores if the grid was created inside the solver  <br /></td></tr>
<tr class="separator:ac46f28fe1db45d35b227e62d3ac7a0f5 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a0a1948e622c6c9b516f51a8db8fc inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_aac9a0a1948e622c6c9b516f51a8db8fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">dim</a></td></tr>
<tr class="memdesc:aac9a0a1948e622c6c9b516f51a8db8fc inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dimension of the grid  <br /></td></tr>
<tr class="separator:aac9a0a1948e622c6c9b516f51a8db8fc inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50e57ef6db91938b72675063b5c608 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_aff50e57ef6db91938b72675063b5c608"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aff50e57ef6db91938b72675063b5c608">levels</a></td></tr>
<tr class="memdesc:aff50e57ef6db91938b72675063b5c608 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of levels used for an regular grid  <br /></td></tr>
<tr class="separator:aff50e57ef6db91938b72675063b5c608 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a74f50df80eaf2ce1fbd413ef84bf inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_a465a74f50df80eaf2ce1fbd413ef84bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a465a74f50df80eaf2ce1fbd413ef84bf">myBoundingBox</a></td></tr>
<tr class="memdesc:a465a74f50df80eaf2ce1fbd413ef84bf inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores Pointer to the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a>'s Bounding Box.  <br /></td></tr>
<tr class="separator:a465a74f50df80eaf2ce1fbd413ef84bf inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a7d65c5d2d3b0843874070b8716d8 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_a104a7d65c5d2d3b0843874070b8716d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a></td></tr>
<tr class="memdesc:a104a7d65c5d2d3b0843874070b8716d8 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> needed in this classificator.  <br /></td></tr>
<tr class="separator:a104a7d65c5d2d3b0843874070b8716d8 inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36857d2d44fef8e2aa2c78f87c97ec0e inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver" id="r_a36857d2d44fef8e2aa2c78f87c97ec0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">sgpp::base::GridStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a></td></tr>
<tr class="memdesc:a36857d2d44fef8e2aa2c78f87c97ec0e inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores Pointer to the Girs's Storage.  <br /></td></tr>
<tr class="separator:a36857d2d44fef8e2aa2c78f87c97ec0e inherit pro_attribs_classsgpp_1_1pde_1_1PDESolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a simple-to-use solver of the multi dimensional Heat Equation that uses Sparse Grids. </p>
<p>The class's aim is, to hide all complex details of solving the Heat Equation with Sparse Grids! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a993915578e28e38ac683a897783bfbb7" name="a993915578e28e38ac683a897783bfbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993915578e28e38ac683a897783bfbb7">&#9670;&#160;</a></span>HeatEquationSolverWithStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sgpp::pde::HeatEquationSolverWithStretching::HeatEquationSolverWithStretching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Std-Constructor of the solver. </p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>.</p>

</div>
</div>
<a id="a80d444fb44a239d46ab93bf8b9ab06e5" name="a80d444fb44a239d46ab93bf8b9ab06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d444fb44a239d46ab93bf8b9ab06e5">&#9670;&#160;</a></span>~HeatEquationSolverWithStretching()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sgpp::pde::HeatEquationSolverWithStretching::~HeatEquationSolverWithStretching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Std-Destructor of the solver. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a75dd73d88817b024255854ad9ee0851e" name="a75dd73d88817b024255854ad9ee0851e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dd73d88817b024255854ad9ee0851e">&#9670;&#160;</a></span>constructGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::constructGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>myBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this routine the construct a regular grid to solve a PDE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myBoundingBox</td><td>reference to a bounding box that describes the grid </td></tr>
    <tr><td class="paramname">level</td><td>number of the regular's grid levels </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a04ecc30e2b0ac3579f7f5c4e6599eb84">sgpp::pde::PDESolver</a>.</p>

</div>
</div>
<a id="aaac81680ff24ab68b9237acbffc54669" name="aaac81680ff24ab68b9237acbffc54669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac81680ff24ab68b9237acbffc54669">&#9670;&#160;</a></span>constructGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::constructGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1Stretching.html">sgpp::base::Stretching</a> &amp;&#160;</td>
          <td class="paramname"><em>myStretching</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">sgpp::pde::PDESolver::dim</a>, <a class="el" href="classsgpp_1_1base_1_1BoundingBox.html#a2427369faf73c57229d9b0ea1743770f">sgpp::base::BoundingBox::getDimension()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a9de6e7d313016311d8f72a8b0b29bc56">sgpp::base::Grid::getStorage()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a20f5a635f3bdf456369a61fee4f12a7f">sgpp::base::Grid::getStretching()</a>, <a class="el" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aff50e57ef6db91938b72675063b5c608">sgpp::pde::PDESolver::levels</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">sgpp::pde::PDESolver::myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a6382c18ef2719f4e99ff2a82fddd4e7a">sgpp::base::GridGenerator::regular()</a>.</p>

</div>
</div>
<a id="a8dcd2ef641164314d24780a562c62f88" name="a8dcd2ef641164314d24780a562c62f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcd2ef641164314d24780a562c62f88">&#9670;&#160;</a></span>initGridWithSmoothHeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::initGridWithSmoothHeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits the grid in the middle of the whole domain with one single heat. </p>
<p>alpha reference to the coefficients vector heat the value of the heat in the middle of the domain Inits the grid in the middle the domain with an smooth heat distribution that the normal distribution formula</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>reference to the coefficients vector </td></tr>
    <tr><td class="paramname">mu</td><td>the exspected value of the normal distribution </td></tr>
    <tr><td class="paramname">sigma</td><td>the sigma of the normal distribution </td></tr>
    <tr><td class="paramname">factor</td><td>a factor that is used to stretch the function values </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>, <a class="el" href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">sgpp::pde::PDESolver::dim</a>, <a class="el" href="classsgpp_1_1base_1_1OperationHierarchisation.html#a99b9b460bff87d78614da15a0a3c1e8d">sgpp::base::OperationHierarchisation::doHierarchisation()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a6878101532f42b8770e3e8842f74ba0b">sgpp::base::HashGridStorage::getCoordinates()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#af261ad6948876baada8b4cea521c3113">sgpp::base::HashGridStorage::getPoint()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a163ccf59d9ebd526c73ff7fdd17a5d01">sgpp::base::Grid::getSize()</a>, <a class="el" href="AugmentedLagrangian_8cpp.html#a74577585cf12d1712ab9c57616d49205">mu</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">sgpp::pde::PDESolver::myGridStorage</a>.</p>

</div>
</div>
<a id="ab84f238b0b47f3bdb919d29bb78d9ec0" name="ab84f238b0b47f3bdb919d29bb78d9ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84f238b0b47f3bdb919d29bb78d9ec0">&#9670;&#160;</a></span>initScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::initScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inits the grid with a constant heat. </p>
<p>alpha reference to the coefficients vector constHeat the temperature of the constant heat Inits the screen object </p>

<p class="reference">References <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#a91957f2c0323d966be6df2e3d711bde8">sgpp::base::ScreenOutput::writeTitle()</a>.</p>

</div>
</div>
<a id="a06d08080266d2a23666361030910f4ae" name="a06d08080266d2a23666361030910f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d08080266d2a23666361030910f4ae">&#9670;&#160;</a></span>printGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::printGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PointesPerDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is some kind of debug functionality. </p>
<p>It writes a file, that can be used with gnuplot the print the grid.</p>
<p>Is only implemented for 1D and 2D grids!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">PointesPerDimension</td><td>the distance between evaluation points </td></tr>
    <tr><td class="paramname">tfilename</td><td>absolute path to file into which the grid's evaluation is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac78e4cc143f26d2d106495cd81058ba3">sgpp::pde::PDESolver</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinterForStretching.html#a37c70396b4ee04f62eab49f18a84f095">sgpp::base::GridPrinterForStretching::printGrid()</a>.</p>

</div>
</div>
<a id="a4b842e84c97d964e4cdd65efcbf63d0f" name="a4b842e84c97d964e4cdd65efcbf63d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b842e84c97d964e4cdd65efcbf63d0f">&#9670;&#160;</a></span>printGridDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::printGridDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PointesPerDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>GridArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is a placeholder, is not used. </p>

<p>Reimplemented from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab1cfdd7dbd2df1ac9d53f481f0411f2">sgpp::pde::PDESolver</a>.</p>

</div>
</div>
<a id="ae25c8115e2d2f00da1ffa78b3c49616d" name="ae25c8115e2d2f00da1ffa78b3c49616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25c8115e2d2f00da1ffa78b3c49616d">&#9670;&#160;</a></span>printGridDomainStretching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::printGridDomainStretching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PointesPerDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1Stretching.html">sgpp::base::Stretching</a> &amp;&#160;</td>
          <td class="paramname"><em>GridArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is some kind of debug functionality. </p>
<p>It writes a file, that can be used with gnuplot the print the grid.</p>
<p>Is only implemented for 2D grids!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">PointesPerDimension</td><td>the distance between evaluation points </td></tr>
    <tr><td class="paramname">GridArea</td><td>the area in which the function should be plotted </td></tr>
    <tr><td class="paramname">tfilename</td><td>absolute path to file into which the grid's evaluation is written </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinterForStretching.html#acd33e89465fe1c1070fa48b5249b652f">sgpp::base::GridPrinterForStretching::printGridDomainStretching()</a>.</p>

</div>
</div>
<a id="aa2ff946fa227995f2c9da26a40e7f89c" name="aa2ff946fa227995f2c9da26a40e7f89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ff946fa227995f2c9da26a40e7f89c">&#9670;&#160;</a></span>printSparseGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::printSparseGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSurplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus. </p>
<p>This function is available for all dimensions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the grid's ansatzfunctions </td></tr>
    <tr><td class="paramname">tfilename</td><td>absoulte path to the file the grid is written into </td></tr>
    <tr><td class="paramname">bSurplus</td><td>specifies whether the surplus (true) or the node basis value (false) is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aee38bcddb2e020457a73e1fbbb7f27ec">sgpp::pde::PDESolver</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinterForStretching.html#ab0c4dd354a1e7b16c7fceb21ac1b4ac9">sgpp::base::GridPrinterForStretching::printSparseGrid()</a>.</p>

</div>
</div>
<a id="a7a21274ef0d75e14039d98ef16ec5bd2" name="a7a21274ef0d75e14039d98ef16ec5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a21274ef0d75e14039d98ef16ec5bd2">&#9670;&#160;</a></span>printSparseGridExpTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::printSparseGridExpTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSurplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus. </p>
<p>This function is available for all dimensions.</p>
<p>The coordinates of the grid points are pushed the exp function. So log transformed grids can be plotted in cartesion coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the grid's ansatzfunctions </td></tr>
    <tr><td class="paramname">tfilename</td><td>absoulte path to the file the grid is written into </td></tr>
    <tr><td class="paramname">bSurplus</td><td>specifies whether the surplus (true) or the node basis value (false) is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac64c62361bc2dbf9133fda9128a4631b">sgpp::pde::PDESolver</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinterForStretching.html#a260c0388c7093c1a5e220da50d8ce1b1">sgpp::base::GridPrinterForStretching::printSparseGridExpTransform()</a>.</p>

</div>
</div>
<a id="a8d7bb45dc1b34d92d18e6cc8977f3567" name="a8d7bb45dc1b34d92d18e6cc8977f3567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7bb45dc1b34d92d18e6cc8977f3567">&#9670;&#160;</a></span>setHeatCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::setHeatCoefficient </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the heat coefficient of the regarded material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the heat coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa61ab5f30a7b33949bf765d240039897" name="aa61ab5f30a7b33949bf765d240039897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61ab5f30a7b33949bf765d240039897">&#9670;&#160;</a></span>solveCrankNicolson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::solveCrankNicolson </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numTimesteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxCGIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilonCG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumImEul</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this routine to use the Crank Nicolson algorithm to solve the parabolic PDE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numTimesteps</td><td>the number of timesteps that should be executed </td></tr>
    <tr><td class="paramname">timestepsize</td><td>the size of the interval one timestep moves forward </td></tr>
    <tr><td class="paramname">maxCGIterations</td><td>the maximum of interation in the CG solver </td></tr>
    <tr><td class="paramname">epsilonCG</td><td>the epsilon used in the CG </td></tr>
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">NumImEul</td><td>specifies how many ImEul steps should be executed before CrNic is used, default is 0 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html#af75f4d3f5aa196a045002db53e6d09c0">sgpp::pde::ParabolicPDESolver</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, <a class="el" href="classsgpp_1_1solver_1_1CrankNicolson.html#adec80d15e28879f5ee56d209f97c7b4e">sgpp::solver::CrankNicolson::solve()</a>, <a class="el" href="classsgpp_1_1solver_1_1Euler.html#a9c34b5dfba750ced8c3980d423ec97b1">sgpp::solver::Euler::solve()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a52995019a2098f3c074e2fb22d31c719">sgpp::base::SGppStopwatch::start()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a7a2728cc20706494d8b84748bec1e543">sgpp::base::SGppStopwatch::stop()</a>, <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#ae7c12eb5b73edf0267db7a3a197227dd">sgpp::base::ScreenOutput::writeEmptyLines()</a>, and <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#a1527366a11e5442763e1246d5ac88b0e">sgpp::base::ScreenOutput::writeStartSolve()</a>.</p>

</div>
</div>
<a id="a830bd0a65ab2cb7624786c71bba5cc67" name="a830bd0a65ab2cb7624786c71bba5cc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830bd0a65ab2cb7624786c71bba5cc67">&#9670;&#160;</a></span>solveExplicitEuler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::solveExplicitEuler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numTimesteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxCGIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilonCG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateAnimation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this routine to use an explicit Euler algorithm to solve the parabolic PDE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numTimesteps</td><td>the number of timesteps that should be executed </td></tr>
    <tr><td class="paramname">timestepsize</td><td>the size of the interval one timestep moves forward </td></tr>
    <tr><td class="paramname">maxCGIterations</td><td>the maximum of interation in the CG solver </td></tr>
    <tr><td class="paramname">epsilonCG</td><td>the epsilon used in the CG </td></tr>
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">verbose</td><td>enables verbose output during solving </td></tr>
    <tr><td class="paramname">generateAnimation</td><td>set this to true, if you want to generate a grid output in every timestep </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html#a0eecc1cec6afddfc03a5e59bcf267412">sgpp::pde::ParabolicPDESolver</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, <a class="el" href="classsgpp_1_1solver_1_1Euler.html#a9c34b5dfba750ced8c3980d423ec97b1">sgpp::solver::Euler::solve()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a52995019a2098f3c074e2fb22d31c719">sgpp::base::SGppStopwatch::start()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a7a2728cc20706494d8b84748bec1e543">sgpp::base::SGppStopwatch::stop()</a>, <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#ae7c12eb5b73edf0267db7a3a197227dd">sgpp::base::ScreenOutput::writeEmptyLines()</a>, and <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#a1527366a11e5442763e1246d5ac88b0e">sgpp::base::ScreenOutput::writeStartSolve()</a>.</p>

</div>
</div>
<a id="a333b0cfdf1d92be4b35623773100247d" name="a333b0cfdf1d92be4b35623773100247d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333b0cfdf1d92be4b35623773100247d">&#9670;&#160;</a></span>solveImplicitEuler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::HeatEquationSolverWithStretching::solveImplicitEuler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numTimesteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxCGIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilonCG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateAnimation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this routine to use an explicit Euler algorithm to solve the parabolic PDE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numTimesteps</td><td>the number of timesteps that should be executed </td></tr>
    <tr><td class="paramname">timestepsize</td><td>the size of the interval one timestep moves forward </td></tr>
    <tr><td class="paramname">maxCGIterations</td><td>the maximum of interation in the CG solver </td></tr>
    <tr><td class="paramname">epsilonCG</td><td>the epsilon used in the CG </td></tr>
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">verbose</td><td>enables verbose output during solving </td></tr>
    <tr><td class="paramname">generateAnimation</td><td>set this to true, if you want to generate a grid output in every timestep </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsgpp_1_1pde_1_1ParabolicPDESolver.html#ad08881d37c18b8fa6a39f1edeb180343">sgpp::pde::ParabolicPDESolver</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">sgpp::pde::PDESolver::bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">sgpp::pde::PDESolver::myGrid</a>, <a class="el" href="classsgpp_1_1solver_1_1Euler.html#a9c34b5dfba750ced8c3980d423ec97b1">sgpp::solver::Euler::solve()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a52995019a2098f3c074e2fb22d31c719">sgpp::base::SGppStopwatch::start()</a>, <a class="el" href="classsgpp_1_1base_1_1SGppStopwatch.html#a7a2728cc20706494d8b84748bec1e543">sgpp::base::SGppStopwatch::stop()</a>, <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#ae7c12eb5b73edf0267db7a3a197227dd">sgpp::base::ScreenOutput::writeEmptyLines()</a>, and <a class="el" href="classsgpp_1_1base_1_1ScreenOutput.html#a1527366a11e5442763e1246d5ac88b0e">sgpp::base::ScreenOutput::writeStartSolve()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pde/src/sgpp/pde/application/<a class="el" href="HeatEquationSolverWithStretching_8hpp.html">HeatEquationSolverWithStretching.hpp</a></li>
<li>pde/src/sgpp/pde/application/<a class="el" href="HeatEquationSolverWithStretching_8cpp.html">HeatEquationSolverWithStretching.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesgpp.html">sgpp</a></li><li class="navelem"><a class="el" href="namespacesgpp_1_1pde.html">pde</a></li><li class="navelem"><a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html">HeatEquationSolverWithStretching</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:24:16 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
