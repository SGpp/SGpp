<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Refinement Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_refinement_cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Refinement Example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here we demonstrate how to refine a grid.</p>
<p>As a refinement indicator, we take the surpluses of the grid points directly. We start with a regular sparse grid of level 3 with linear basis functions and refine five times. In each refinement step, we refine the grid point with the highest absolute surplus.</p>
<p>The following example interpolates the (non-symmetric) function f : [0,1]x[0,1] -&gt; R, <a class="el" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f(x,y)</a> := 16 (x-1) * x * (y-1) * y</p>
<p>The number of grid points is printed in each iteration. After refinement, the surplusses have to be set for all new grid points, i.e., the alpha-Vector has to be extended. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DataVector_8hpp.html">sgpp/base/datatypes/DataVector.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Grid_8hpp.html">sgpp/base/grid/Grid.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridStorage_8hpp.html">sgpp/base/grid/GridStorage.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridGenerator_8hpp.html">sgpp/base/grid/generation/GridGenerator.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SurplusRefinementFunctor_8hpp.html">sgpp/base/grid/generation/functors/SurplusRefinementFunctor.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="BaseOpFactory_8hpp.html">sgpp/base/operation/BaseOpFactory.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="OperationEval_8hpp.html">sgpp/base/operation/hash/OperationEval.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1GridGenerator.html">sgpp::base::GridGenerator</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1HashGridPoint.html">sgpp::base::GridPoint</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::GridStorage</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1SurplusRefinementFunctor.html">sgpp::base::SurplusRefinementFunctor</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1OperationHierarchisation.html">sgpp::base::OperationHierarchisation</a>;</div>
<div class="ttc" id="aBaseOpFactory_8hpp_html"><div class="ttname"><a href="BaseOpFactory_8hpp.html">BaseOpFactory.hpp</a></div></div>
<div class="ttc" id="aDataVector_8hpp_html"><div class="ttname"><a href="DataVector_8hpp.html">DataVector.hpp</a></div></div>
<div class="ttc" id="aGridGenerator_8hpp_html"><div class="ttname"><a href="GridGenerator_8hpp.html">GridGenerator.hpp</a></div></div>
<div class="ttc" id="aGridStorage_8hpp_html"><div class="ttname"><a href="GridStorage_8hpp.html">GridStorage.hpp</a></div></div>
<div class="ttc" id="aGrid_8hpp_html"><div class="ttname"><a href="Grid_8hpp.html">Grid.hpp</a></div></div>
<div class="ttc" id="aOperationEval_8hpp_html"><div class="ttname"><a href="OperationEval_8hpp.html">OperationEval.hpp</a></div></div>
<div class="ttc" id="aSurplusRefinementFunctor_8hpp_html"><div class="ttname"><a href="SurplusRefinementFunctor_8hpp.html">SurplusRefinementFunctor.hpp</a></div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1GridGenerator_html"><div class="ttname"><a href="classsgpp_1_1base_1_1GridGenerator.html">sgpp::base::GridGenerator</a></div><div class="ttdoc">Abstract class that defines the interfaces for the different grid's GridGenerators.</div><div class="ttdef"><b>Definition</b> GridGenerator.hpp:26</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Grid_html"><div class="ttname"><a href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a></div><div class="ttdoc">abstract base class for all types grids used in sgpp the class gives pure virtual function definition...</div><div class="ttdef"><b>Definition</b> Grid.hpp:191</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridPoint_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridPoint.html">sgpp::base::HashGridPoint</a></div><div class="ttdoc">This Class represents one Gridpoint.</div><div class="ttdef"><b>Definition</b> HashGridPoint.hpp:33</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridStorage_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a></div><div class="ttdoc">Generic hash table based storage of grid points.</div><div class="ttdef"><b>Definition</b> HashGridStorage.hpp:42</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1OperationHierarchisation_html"><div class="ttname"><a href="classsgpp_1_1base_1_1OperationHierarchisation.html">sgpp::base::OperationHierarchisation</a></div><div class="ttdoc">This class implements the hierarchisation and dehierarchisation on the sparse grid.</div><div class="ttdef"><b>Definition</b> OperationHierarchisation.hpp:19</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1SurplusRefinementFunctor_html"><div class="ttname"><a href="classsgpp_1_1base_1_1SurplusRefinementFunctor.html">sgpp::base::SurplusRefinementFunctor</a></div><div class="ttdoc">A refinement functor, refining according to the maximal absolute values in a DataVector provided.</div><div class="ttdef"><b>Definition</b> SurplusRefinementFunctor.hpp:21</div></div>
</div><!-- fragment --><p>Function to interpolate. This is a two-dimensional parabola. - nonsymmetric(!). </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(<span class="keywordtype">double</span> x0, <span class="keywordtype">double</span> x1) { <span class="keywordflow">return</span> 16.0 * (x0 - 1) * x0 * (x1 - 1) * x1; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>Create a two-dimensional piecewise bi-linear grid. </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> dim = 2;</div>
<div class="line">  std::unique_ptr&lt;Grid&gt; <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>(Grid::createLinearGrid(dim));</div>
<div class="line">  GridStorage&amp; gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getStorage();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dimensionality:                   &quot;</span> &lt;&lt; gridStorage.getDimension() &lt;&lt; std::endl;</div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
</div><!-- fragment --><p>Create regular sparse grid, level 3. </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a> = 3;</div>
<div class="line">  <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getGenerator().regular(<a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;number of initial grid points:    &quot;</span> &lt;&lt; gridStorage.getSize() &lt;&lt; std::endl;</div>
<div class="ttc" id="amultHPX_8cpp_html_a6a330c3b2adf87bfa27e9a9450d8bc40"><div class="ttname"><a href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a></div><div class="ttdeci">uint32_t level</div><div class="ttdef"><b>Definition</b> multHPX.cpp:26</div></div>
</div><!-- fragment --><p>Create coefficient vector with size corresponding to the grid size. Initially, all the values are set to zero. </p><div class="fragment"><div class="line">  DataVector <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>(gridStorage.getSize());</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;length of alpha vector:           &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a4ec9b893255175cc583323968788b1b1"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize</a></div><div class="ttdeci">size_t getSize() const</div><div class="ttdoc">gets the elements stored in the vector</div><div class="ttdef"><b>Definition</b> DataVector.hpp:365</div></div>
<div class="ttc" id="amultHPX_8cpp_html_afaae4b3ccddbff855673417650052c63"><div class="ttname"><a href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a></div><div class="ttdeci">sgpp::base::DataVector alpha</div><div class="ttdef"><b>Definition</b> multHPX.cpp:40</div></div>
</div><!-- fragment --><p>Create a vector for storing (possibly expensive) function evaluations at each gridpoint. </p><div class="fragment"><div class="line">  DataVector funEvals(gridStorage.getSize());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; gridStorage.getSize(); i++) {</div>
<div class="line">    GridPoint&amp; gp = gridStorage.getPoint(i);</div>
<div class="line">    funEvals[i] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(gp.getStandardCoordinate(0), gp.getStandardCoordinate(1));</div>
<div class="line">  }</div>
</div><!-- fragment --><p>create a vector for storing newly added points by their sequence id. </p><div class="fragment"><div class="line">  std::vector&lt;size_t&gt; addedPoints;</div>
</div><!-- fragment --><p>Refine adaptively 5 times. </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> step = 0; step &lt; 5; step++) {</div>
</div><!-- fragment --><p>Refine a single grid point each time. The SurplusRefinementFunctor chooses the grid point with the highest absolute surplus. Refining the point means, that all children of this point (if not already present) are added to the grid. Also all missing parents are added (recursively). All new points are appended to the addedPoints vector. </p><div class="fragment"><div class="line">    SurplusRefinementFunctor functor(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, 1);</div>
<div class="line">    <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getGenerator().refine(functor, &amp;addedPoints);</div>
</div><!-- fragment --><p>Extend alpha and funEval vector (new entries uninitialized). Note that right now, the size of both vectors matches number of gridpoints again, but the values of the new points are set to zero. </p><div class="fragment"><div class="line">    <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.resize(gridStorage.getSize());</div>
<div class="line">    funEvals.resize(gridStorage.getSize());</div>
</div><!-- fragment --><p>Evaluate the function f at the newly created gridpoints and set the corresponding entries in the funEval vector with these values. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; addedPoints.size(); i++) {</div>
<div class="line">      <span class="keywordtype">size_t</span> seq = addedPoints[i];</div>
<div class="line">      GridPoint&amp; gp = gridStorage.getPoint(seq);</div>
<div class="line">      funEvals[seq] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(gp.getStandardCoordinate(0), gp.getStandardCoordinate(1));</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Reset the alpha vector to function evals to prepare for hierarchisation. </p><div class="fragment"><div class="line">    <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a90875364942ed589bfeb6409187853ed">copyFrom</a>(funEvals);</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a90875364942ed589bfeb6409187853ed"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a90875364942ed589bfeb6409187853ed">sgpp::base::DataVector::copyFrom</a></div><div class="ttdeci">void copyFrom(const DataVector &amp;vec)</div><div class="ttdoc">Copies the data from another DataVector vec.</div><div class="ttdef"><b>Definition</b> DataVector.cpp:182</div></div>
</div><!-- fragment --><p>Each time, we have to hierarchize the grid again, because in the previous interation, new grid points have been added. </p><div class="fragment"><div class="line">    <a class="code hl_function" href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a>(*grid)-&gt;<a class="code hl_function" href="classsgpp_1_1base_1_1OperationHierarchisation.html#a99b9b460bff87d78614da15a0a3c1e8d">doHierarchisation</a>(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>);</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1OperationHierarchisation_html_a99b9b460bff87d78614da15a0a3c1e8d"><div class="ttname"><a href="classsgpp_1_1base_1_1OperationHierarchisation.html#a99b9b460bff87d78614da15a0a3c1e8d">sgpp::base::OperationHierarchisation::doHierarchisation</a></div><div class="ttdeci">virtual void doHierarchisation(DataVector &amp;node_values)=0</div><div class="ttdoc">Implements the hierarchisation on a sparse grid.</div></div>
<div class="ttc" id="anamespacesgpp_1_1op__factory_html_a08b6aa545e0f57f47b5cfdafd4f781e4"><div class="ttname"><a href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a></div><div class="ttdeci">base::OperationHierarchisation * createOperationHierarchisation(base::Grid &amp;grid)</div><div class="ttdoc">Factory method, returning an OperationHierarchisation for the grid at hand.</div><div class="ttdef"><b>Definition</b> BaseOpFactory.cpp:275</div></div>
</div><!-- fragment --><p>Clear the addedPoints vector for the next iteration. </p><div class="fragment"><div class="line">    addedPoints.clear();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;refinement step &quot;</span> &lt;&lt; step + 1 &lt;&lt; <span class="stringliteral">&quot;, new grid size: &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>(); i++) {</div>
<div class="line">    std::cout &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>[i] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This results in the following output: </p><pre class="fragment">dimensionality:                   2
number of initial grid points:    17
length of alpha vector:           17
refinement step 1, new grid size: 21
refinement step 2, new grid size: 24
refinement step 3, new grid size: 27
refinement step 4, new grid size: 29
refinement step 5, new grid size: 33</pre><p>There are clearly more efficient approaches than to hierarchize the whole grid each time. But this works even where no efficient alternatives are available and suffices for demonstration purposes.</p>
<p>This use of the SurplusRefinementFunctor takes as arguments the coefficient vector (it doesn't have to be the coefficient vector, it could be something modified!) and the number of grid points to refine (if available). It bases its refinement decision on the absolute values of the vector's entries, choosing the largest ones. Other refinement functors are available or can be implemented. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_cpp.html">C++ Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:51:15 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
