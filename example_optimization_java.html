<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Optimization Example (Java)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_optimization_java.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Optimization Example (Java)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>On this page, we look at an example application of the <a class="el" href="namespacesgpp_1_1optimization.html">sgpp::optimization</a> module.</p>
<p>Versions of the example are given in all languages currently supported by SG++: C++, Python, Java, and MATLAB.</p>
<p>The example interpolates a bivariate test function with B-splines instead of piecewise linear basis functions to obtain a smoother interpolant. The resulting sparse grid function is then minimized with the method of steepest descent. For comparison, we also minimize the objective function with Nelder-Mead's method.</p>
<p>The example uses the following external class (stored in <code>ExampleFunction.java</code>). The function \(f\colon [0, 1]^d \to \mathbb{R}\) to be minimized is called <em>objective function</em> and has to derive from sgpp.ScalarFunction. In the constructor, we give the dimensionality of the domain (in this case \(d = 2\)). The eval method evaluates the objective function and returns the function value \(f(\vec{x})\) for a given point \(\vec{x} \in [0, 1]^d\). </p><div class="fragment"><div class="line"><span class="comment">// Copyright (C) 2008-today The SG++ project</span></div>
<div class="line"><span class="comment">// This file is part of the SG++ project. For conditions of distribution and</span></div>
<div class="line"><span class="comment">// use, please see the copyright notice provided with SG++ or at</span></div>
<div class="line"><span class="comment">// sgpp.sparsegrids.org</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>ExampleFunction <span class="keyword">extends</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.ScalarFunction {</div>
<div class="line">  <span class="keyword">public</span> ExampleFunction() {</div>
<div class="line">    super(2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span> <span class="keywordtype">double</span> eval(<a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector x) {</div>
<div class="line">    <span class="keywordflow">if</span> ((x.get(0) &gt;= 0.0) &amp;&amp; (x.get(0) &lt;= 1.0) &amp;&amp;</div>
<div class="line">        (x.get(1) &gt;= 0.0) &amp;&amp; (x.get(1) &lt;= 1.0)) {</div>
<div class="line">      <span class="comment">// minimum is f(x) = -2 for x[0] = 3*pi/16, x[1] = 3*pi/14</span></div>
<div class="line">      <span class="keywordflow">return</span> Math.sin(8.0 * x.get(0)) + Math.sin(7.0 * x.get(1));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> Double.POSITIVE_INFINITY;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span> <span class="keywordtype">void</span> clone(<a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.SWIGTYPE_p_std__unique_ptrT_sgpp__base__ScalarFunction_t clone) {</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesgpp_html"><div class="ttname"><a href="namespacesgpp.html">sgpp</a></div><div class="ttdoc">Class that stores, generates and manipulates a density function during online phase in on/off learnin...</div><div class="ttdef"><b>Definition</b> AlgorithmDGEMV.hpp:22</div></div>
</div><!-- fragment --><p>The actual example looks as follows.  </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>optimization {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> printLine() {</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;----------------------------------------&quot;</span> +</div>
<div class="line">                       <span class="stringliteral">&quot;----------------------------------------&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> String numToStr(<span class="keywordtype">double</span> number) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> java.text.DecimalFormat(<span class="stringliteral">&quot;#.#####&quot;</span>).format(number);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(String[] args) {</div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>At the beginning of the program, we have to load the shared library object file. We can do so by using <code>java.lang.System.load</code> or <code>sgpp.LoadJSGPPLib.loadJSGPPLib</code>. Also, we disable OpenMP within jsgpp since it interferes with SWIG's director feature. </p><div class="fragment"><div class="line">    <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.LoadJSGPPLib.loadJSGPPLib();</div>
<div class="line">    <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.jsgpp.omp_set_num_threads(1);</div>
<div class="line"> </div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;sgpp::optimization example program started.\n&quot;</span>);</div>
<div class="line">    <span class="comment">// increase verbosity of the output</span></div>
<div class="line">    <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Printer.getInstance().setVerbosity(2);</div>
</div><!-- fragment --><p>Here, we define some parameters: objective function, dimensionality, B-spline degree, maximal number of grid points, and adaptivity. </p><div class="fragment"><div class="line">    <span class="comment">// objective function</span></div>
<div class="line">    ExampleFunction <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a> = <span class="keyword">new</span> ExampleFunction();</div>
<div class="line">    <span class="comment">// dimension of domain</span></div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">long</span> d = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>.getNumberOfParameters();</div>
<div class="line">    <span class="comment">// B-spline degree</span></div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">long</span> p = 3;</div>
<div class="line">    <span class="comment">// maximal number of grid points</span></div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">long</span> N = 30;</div>
<div class="line">    <span class="comment">// adaptivity of grid generation</span></div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">double</span> gamma = 0.95;</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
</div><!-- fragment --><p>First, we define a grid with modified B-spline basis functions and an iterative grid generator, which can generate the grid adaptively. </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1Grid.html">sgpp.Grid</a> <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Grid.createModBsplineGrid(d, p);</div>
<div class="line">    sgpp.OptIterativeGridGeneratorRitterNovak gridGen =</div>
<div class="line">        <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptIterativeGridGeneratorRitterNovak(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>, <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, N, gamma);</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Grid_html"><div class="ttname"><a href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a></div><div class="ttdoc">abstract base class for all types grids used in sgpp the class gives pure virtual function definition...</div><div class="ttdef"><b>Definition</b> Grid.hpp:191</div></div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
</div><!-- fragment --><p>With the iterative grid generator, we generate adaptively a sparse grid. </p><div class="fragment"><div class="line">    printLine();</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;Generating grid...\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!gridGen.generate()) {</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;Grid generation failed, exiting.&quot;</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Then, we hierarchize the function values to get hierarchical B-spline coefficients of the B-spline sparse grid interpolant \(\tilde{f}\colon [0, 1]^d \to \mathbb{R}\). </p><div class="fragment"><div class="line">    printLine();</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;Hierarchizing...\n&quot;</span>);</div>
<div class="line">    <span class="keyword">final</span> <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp.DataVector</a> functionValues = gridGen.getFunctionValues();</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp.DataVector</a> coeffs = <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(functionValues.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>());</div>
<div class="line">    sgpp.HierarchisationSLE hierSLE = <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.HierarchisationSLE(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>);</div>
<div class="line">    sgpp.AutoSLESolver sleSolver = <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.AutoSLESolver();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// solve linear system</span></div>
<div class="line">    <span class="keywordflow">if</span> (!sleSolver.solve(hierSLE, gridGen.getFunctionValues(), coeffs)) {</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;Solving failed, exiting.&quot;</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a4ec9b893255175cc583323968788b1b1"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize</a></div><div class="ttdeci">size_t getSize() const</div><div class="ttdoc">gets the elements stored in the vector</div><div class="ttdef"><b>Definition</b> DataVector.hpp:365</div></div>
</div><!-- fragment --><p>We define the interpolant \(\tilde{f}\) and its gradient \(\nabla\tilde{f}\) for use with the gradient method (steepest descent). Of course, one can also use other optimization algorithms from <a class="el" href="namespacesgpp_1_1optimization_1_1optimizer.html">sgpp::optimization::optimizer</a>. </p><div class="fragment"><div class="line">    printLine();</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;Optimizing smooth interpolant...\n&quot;</span>);</div>
<div class="line">    sgpp.InterpolantScalarFunction ft =</div>
<div class="line">        <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.InterpolantScalarFunction(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, coeffs);</div>
<div class="line">    sgpp.InterpolantScalarFunctionGradient ftGradient =</div>
<div class="line">        <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.InterpolantScalarFunctionGradient(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, coeffs);</div>
<div class="line">    sgpp.OptGradientDescent gradientDescent =</div>
<div class="line">        <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptGradientDescent(ft, ftGradient);</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp.DataVector</a> x0 = <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(d);</div>
<div class="line">    <span class="keywordtype">double</span> fX0;</div>
<div class="line">    <span class="keywordtype">double</span> ftX0;</div>
</div><!-- fragment --><p>The gradient method needs a starting point. We use a point of our adaptively generated sparse grid as starting point. More specifically, we use the point with the smallest (most promising) function value and save it in x0. </p><div class="fragment"><div class="line">    {</div>
<div class="line">      sgpp.GridStorage gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>.getStorage();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// index of grid point with minimal function value</span></div>
<div class="line">      <span class="keywordtype">int</span> x0Index = 0;</div>
<div class="line">      fX0 = functionValues.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a6a37936ca9ad94deb49e860823472110">get</a>(0);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; functionValues.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>(); i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (functionValues.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a6a37936ca9ad94deb49e860823472110">get</a>(i) &lt; fX0) {</div>
<div class="line">          fX0 = functionValues.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a6a37936ca9ad94deb49e860823472110">get</a>(i);</div>
<div class="line">          x0Index = i;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      x0 = gridStorage.getCoordinates(gridStorage.getPoint(x0Index));</div>
<div class="line">      ftX0 = ft.eval(x0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;x0 = &quot;</span> + x0);</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;f(x0) = &quot;</span> + numToStr(fX0) +</div>
<div class="line">                       <span class="stringliteral">&quot;, ft(x0) = &quot;</span> + numToStr(ftX0) + <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a6a37936ca9ad94deb49e860823472110"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a6a37936ca9ad94deb49e860823472110">sgpp::base::DataVector::get</a></div><div class="ttdeci">double get(size_t i) const</div><div class="ttdoc">Returns the i-th element.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:174</div></div>
</div><!-- fragment --><p>We apply the gradient method and print the results. </p><div class="fragment"><div class="line">    gradientDescent.setStartingPoint(x0);</div>
<div class="line">    gradientDescent.optimize();</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp.DataVector</a> xOpt = gradientDescent.getOptimalPoint();</div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">double</span> ftXOpt = gradientDescent.getOptimalValue();</div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">double</span> fXOpt = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>.eval(xOpt);</div>
<div class="line"> </div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;\nxOpt = &quot;</span> + xOpt);</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;f(xOpt) = &quot;</span> + numToStr(fXOpt) +</div>
<div class="line">                       <span class="stringliteral">&quot;, ft(xOpt) = &quot;</span> + numToStr(ftXOpt) + <span class="stringliteral">&quot;\n&quot;</span>);</div>
</div><!-- fragment --><p>For comparison, we apply the classical gradient-free Nelder-Mead method directly to the objective function \(f\). </p><div class="fragment"><div class="line">    printLine();</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;Optimizing objective function (for comparison)...\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    sgpp.OptNelderMead nelderMead = <span class="keyword">new</span> <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptNelderMead(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>, 1000);</div>
<div class="line">    nelderMead.optimize();</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp.DataVector</a> xOptNM = nelderMead.getOptimalPoint();</div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">double</span> fXOptNM = nelderMead.getOptimalValue();</div>
<div class="line">    <span class="keyword">final</span> <span class="keywordtype">double</span> ftXOptNM = ft.eval(xOptNM);</div>
<div class="line"> </div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;\nxOptNM = &quot;</span> + xOptNM);</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;f(xOptNM) = &quot;</span> + numToStr(fXOptNM) +</div>
<div class="line">                       <span class="stringliteral">&quot;, ft(xOptNM) = &quot;</span> + numToStr(ftXOptNM) + <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    printLine();</div>
<div class="line">    System.out.println(<span class="stringliteral">&quot;\nsgpp::optimization example program terminated.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}  <span class="comment">// end of class</span></div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">sgpp::optimization example program started.

--------------------------------------------------------------------------------
Generating grid...

Adaptive grid generation (Ritter-Novak)...
    100.0% (N = 29, k = 3)
Done in 3ms.
--------------------------------------------------------------------------------
Hierarchizing...

Solving linear system (automatic method)...
    estimated nnz ratio: 59.8% 
    Solving linear system (Armadillo)...
        constructing matrix (100.0%)
        nnz ratio: 58.0%
        solving with Armadillo
    Done in 0ms.
Done in 1ms.
--------------------------------------------------------------------------------
Optimizing smooth interpolant...

x0 = [0.625, 0.75]
f(x0) = -1.81786, ft(x0) = -1.81786

Optimizing (gradient method)...
    9 steps, f(x) = -2.000780
Done in 1ms.

xOpt = [0.589526, 0.673268]
f(xOpt) = -1.99999, ft(xOpt) = -2.00078

--------------------------------------------------------------------------------
Optimizing objective function (for comparison)...

Optimizing (Nelder-Mead)...
    280 steps, f(x) = -2.000000
Done in 2ms.

xOptNM = [0.589049, 0.673198]
f(xOptNM) = -2, ft(xOptNM) = -2.00077

--------------------------------------------------------------------------------

sgpp::optimization example program terminated.
</pre><p>We see that both the gradient-based optimization of the smooth sparse grid interpolant and the gradient-free optimization of the objective function find reasonable approximations of the minimum, which lies at \((3\pi/16, 3\pi/14) \approx (0.58904862, 0.67319843)\). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_java.html">Java Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:37:56 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
