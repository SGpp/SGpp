<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: tutorial.cpp (Start Here)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_tutorial_cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">tutorial.cpp (Start Here)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To be able to quickly start with a toolkit, it is often advantageous (not only for the impatient users), to look at some code examples first.</p>
<p>In this tutorial, we give a short example program which interpolates a bivariate function on a regular sparse grid. Identical versions of the example are given in all languages currently supported by SG++: C++, Python, Java, and MATLAB.</p>
<p>In the example, we create a two-dimensional regular sparse grid of level 3 (with grid points \(\vec{x}_j \in [0, 1]^2\)) using piecewise bilinear basis functions \(\varphi_j\colon [0, 1]^2 \to \mathbb{R}\). We then interpolate the function</p>
<p class="formulaDsp">
\[
f\colon [0, 1]^2 \to \mathbb{R},\quad
f(x_0, x_1) := 16 (x_0 - 1) x_0 (x_1 - 1) x_1
\]
</p>
<p>with</p>
<p class="formulaDsp">
\[
u\colon [0, 1]^2 \to \mathbb{R},\quad
u(x_0, x_1) := \sum_{j=0}^{N-1} \alpha_j \varphi_j(x_0, x_1)
\]
</p>
<p>by calculating the coefficients \(\alpha_j\) such that \(u(\vec{x}_j) = f(\vec{x}_j)\) for all \(j\). This process is called <em>hierarchization</em> in sparse grid contexts; the \(\alpha_j\) are called <em>(hierarchical) surpluses</em>. Note that \(f\) vanishes at the boundary of the domain \([0, 1]^2\); therefore, we don't have to spend sparse grid points on the boundary. Finally, we evaluate the sparse grid function \(u\) at a point \(\vec{p} = (0.52, 0.73)\).</p>
<p>First, we have to include the SG++ headers. We can include the meta-header <code><a class="el" href="sgpp__base_8hpp.html">sgpp_base.hpp</a></code>, which includes itself all headers from the base module, or we can include only those headers we need. </p><div class="fragment"><div class="line"><span class="comment">// include all SG++ base headers</span></div>
<div class="line"><span class="comment">// #include &lt;sgpp_base.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// or, better, include only the ones needed</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DataVector_8hpp.html">sgpp/base/datatypes/DataVector.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Grid_8hpp.html">sgpp/base/grid/Grid.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridStorage_8hpp.html">sgpp/base/grid/GridStorage.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridGenerator_8hpp.html">sgpp/base/grid/generation/GridGenerator.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="BaseOpFactory_8hpp.html">sgpp/base/operation/BaseOpFactory.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="OperationEval_8hpp.html">sgpp/base/operation/hash/OperationEval.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="ttc" id="aBaseOpFactory_8hpp_html"><div class="ttname"><a href="BaseOpFactory_8hpp.html">BaseOpFactory.hpp</a></div></div>
<div class="ttc" id="aDataVector_8hpp_html"><div class="ttname"><a href="DataVector_8hpp.html">DataVector.hpp</a></div></div>
<div class="ttc" id="aGridGenerator_8hpp_html"><div class="ttname"><a href="GridGenerator_8hpp.html">GridGenerator.hpp</a></div></div>
<div class="ttc" id="aGridStorage_8hpp_html"><div class="ttname"><a href="GridStorage_8hpp.html">GridStorage.hpp</a></div></div>
<div class="ttc" id="aGrid_8hpp_html"><div class="ttname"><a href="Grid_8hpp.html">Grid.hpp</a></div></div>
<div class="ttc" id="aOperationEval_8hpp_html"><div class="ttname"><a href="OperationEval_8hpp.html">OperationEval.hpp</a></div></div>
</div><!-- fragment --><p>Before starting with the <code>main</code> function, the function \(f\), which we want to interpolate, is defined. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(<span class="keywordtype">double</span> x0, <span class="keywordtype">double</span> x1) { <span class="keywordflow">return</span> 16.0 * (x0 - 1) * x0 * (x1 - 1) * x1; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>First, we create a two-dimensional grid (type <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a>) with piecewise bilinear basis functions with the help of the factory method <a class="el" href="classsgpp_1_1base_1_1Grid.html#aedee852987dbba26cbb973ece5dea3db" title="Creates and returns a grid without grid points on the boundary (zero boundary conditions) with piecew...">sgpp::base::Grid::createLinearGrid()</a>. </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> dim = 2;</div>
<div class="line">  std::unique_ptr&lt;sgpp::base::Grid&gt; <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>(<a class="code hl_function" href="classsgpp_1_1base_1_1Grid.html#aedee852987dbba26cbb973ece5dea3db">sgpp::base::Grid::createLinearGrid</a>(dim));</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Grid_html_aedee852987dbba26cbb973ece5dea3db"><div class="ttname"><a href="classsgpp_1_1base_1_1Grid.html#aedee852987dbba26cbb973ece5dea3db">sgpp::base::Grid::createLinearGrid</a></div><div class="ttdeci">static Grid * createLinearGrid(size_t dim)</div><div class="ttdoc">Creates and returns a grid without grid points on the boundary (zero boundary conditions) with piecew...</div><div class="ttdef"><b>Definition</b> Grid.cpp:73</div></div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
</div><!-- fragment --><p>Then we obtain a reference to the grid's <a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089" title="Main typedef for GridStorage.">sgpp::base::GridStorage</a> object which allows us, e.g., to access grid points, to obtain the dimensionality (which we print) and the number of grid points. </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::GridStorage</a>&amp; gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getStorage();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dimensionality:         &quot;</span> &lt;&lt; gridStorage.getDimension() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridStorage_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a></div><div class="ttdoc">Generic hash table based storage of grid points.</div><div class="ttdef"><b>Definition</b> HashGridStorage.hpp:42</div></div>
</div><!-- fragment --><p>Now, we use a <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html" title="Abstract class that defines the interfaces for the different grid&#39;s GridGenerators.">sgpp::base::GridGenerator</a> to create a regular sparse grid of level 3. Thus, <code>gridStorage.getSize()</code> returns 17, the number of grid points of a two-dimensional regular sparse grid of level 3. </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a> = 3;</div>
<div class="line">  <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getGenerator().regular(<a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;number of grid points:  &quot;</span> &lt;&lt; gridStorage.getSize() &lt;&lt; std::endl;</div>
<div class="ttc" id="amultHPX_8cpp_html_a6a330c3b2adf87bfa27e9a9450d8bc40"><div class="ttname"><a href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a></div><div class="ttdeci">uint32_t level</div><div class="ttdef"><b>Definition</b> multHPX.cpp:26</div></div>
</div><!-- fragment --><p>We create an object of type <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> which is essentially a wrapper around a <code>double</code> array. The <code>DataVector</code> is initialized with as many entries as there are grid points. It serves as a coefficient vector for the sparse grid interpolant we want to construct. As the entries of a freshly created <code>DataVector</code> are not initialized, we set them to 0.0. (This is superfluous here as we initialize them in the next few lines anyway.) </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>(gridStorage.getSize());</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;length of alpha vector: &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a4ec9b893255175cc583323968788b1b1"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize</a></div><div class="ttdeci">size_t getSize() const</div><div class="ttdoc">gets the elements stored in the vector</div><div class="ttdef"><b>Definition</b> DataVector.hpp:365</div></div>
<div class="ttc" id="amultHPX_8cpp_html_afaae4b3ccddbff855673417650052c63"><div class="ttname"><a href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a></div><div class="ttdeci">sgpp::base::DataVector alpha</div><div class="ttdef"><b>Definition</b> multHPX.cpp:40</div></div>
</div><!-- fragment --><p>The <code>for</code> loop iterates over all grid points: For each grid point <code>gp</code>, the corresponding coefficient \(\alpha_j\) is set to the function value at the grid point's coordinates which are obtained by <code>getStandardCoordinate(dim)</code>. The current coefficient vector is then printed. </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; gridStorage.getSize(); i++) {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1HashGridPoint.html">sgpp::base::GridPoint</a>&amp; gp = gridStorage.getPoint(i);</div>
<div class="line">    <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>[i] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(gp.<a class="code hl_function" href="classsgpp_1_1base_1_1HashGridPoint.html#af7fd47e5ee557a38518b06f9787b7c1f">getStandardCoordinate</a>(0), gp.<a class="code hl_function" href="classsgpp_1_1base_1_1HashGridPoint.html#af7fd47e5ee557a38518b06f9787b7c1f">getStandardCoordinate</a>(1));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;alpha before hierarchization: &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">toString</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_ab353c20b73b16a72e68ce733e09eff8b"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">sgpp::base::DataVector::toString</a></div><div class="ttdeci">void toString(std::string &amp;text) const</div><div class="ttdoc">Writes the data stored in the DataVector into a string.</div><div class="ttdef"><b>Definition</b> DataVector.cpp:415</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridPoint_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridPoint.html">sgpp::base::HashGridPoint</a></div><div class="ttdoc">This Class represents one Gridpoint.</div><div class="ttdef"><b>Definition</b> HashGridPoint.hpp:33</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridPoint_html_af7fd47e5ee557a38518b06f9787b7c1f"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridPoint.html#af7fd47e5ee557a38518b06f9787b7c1f">sgpp::base::HashGridPoint::getStandardCoordinate</a></div><div class="ttdeci">double getStandardCoordinate(size_t d) const</div><div class="ttdoc">determines the coordinate in a given dimension &quot;Standard&quot; means no bounding box (i....</div><div class="ttdef"><b>Definition</b> HashGridPoint.hpp:196</div></div>
</div><!-- fragment --><p>An object of <a class="el" href="classsgpp_1_1base_1_1OperationHierarchisation.html" title="This class implements the hierarchisation and dehierarchisation on the sparse grid.">sgpp::base::OperationHierarchisation</a> is created and used to hierarchize the coefficient vector, which we print. </p><div class="fragment"><div class="line">  std::unique_ptr&lt;sgpp::base::OperationHierarchisation&gt;(</div>
<div class="line">      <a class="code hl_function" href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a>(*<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>))</div>
<div class="line">      -&gt;doHierarchisation(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;alpha after hierarchization:  &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">toString</a>() &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespacesgpp_1_1op__factory_html_a08b6aa545e0f57f47b5cfdafd4f781e4"><div class="ttname"><a href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a></div><div class="ttdeci">base::OperationHierarchisation * createOperationHierarchisation(base::Grid &amp;grid)</div><div class="ttdoc">Factory method, returning an OperationHierarchisation for the grid at hand.</div><div class="ttdef"><b>Definition</b> BaseOpFactory.cpp:275</div></div>
</div><!-- fragment --><p>Finally, a second <code>DataVector</code> is created which is used as a point to evaluate the sparse grid function at. An object is obtained which provides an evaluation operation (of type sgpp::base::OperationEvaluation), and the sparse grid interpolant is evaluated at \(\vec{p}\), which is close to (but not exactly at) a grid point. </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> p(dim);</div>
<div class="line">  p[0] = 0.52;</div>
<div class="line">  p[1] = 0.73;</div>
<div class="line">  std::unique_ptr&lt;sgpp::base::OperationEval&gt; opEval(<a class="code hl_function" href="namespacesgpp_1_1op__factory.html#afa95f55361a896584bf43d487d8c4ca8">sgpp::op_factory::createOperationEval</a>(*<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;u(0.52, 0.73) = &quot;</span> &lt;&lt; opEval-&gt;eval(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, p) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesgpp_1_1op__factory_html_afa95f55361a896584bf43d487d8c4ca8"><div class="ttname"><a href="namespacesgpp_1_1op__factory.html#afa95f55361a896584bf43d487d8c4ca8">sgpp::op_factory::createOperationEval</a></div><div class="ttdeci">base::OperationEval * createOperationEval(base::Grid &amp;grid)</div><div class="ttdoc">Factory method, returning an OperationEval for the grid at hand.</div><div class="ttdef"><b>Definition</b> BaseOpFactory.cpp:561</div></div>
</div><!-- fragment --><p>The example results in the following output: </p><pre class="fragment">dimensionality:         2
number of grid points:  17
length of alpha vector: 17
alpha before hierarchization: [1, 0.75, 0.75, 0.4375, 0.9375, 0.9375, 0.4375, 0.75, 0.75, 0.4375, 0.9375, 0.9375, 0.4375, 0.5625, 0.5625, 0.5625, 0.5625]
alpha after hierarchization:  [1, 0.25, 0.25, 0.0625, 0.0625, 0.0625, 0.0625, 0.25, 0.25, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625]
u(0.52, 0.73) = 0.7696
</pre><p> It can be clearly seen that the surpluses decay with a factor of 1/4: On the first level, we obtain 1, on the second 1/4, and on the third 1/16 as surpluses. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_cpp.html">C++ Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:37:56 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
