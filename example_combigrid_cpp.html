<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Combigrid Example (C++)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_combigrid_cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Combigrid Example (C++)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example, we use the combigrid module to interpolate a test function on a two-dimensional regular sparse grid with the combination technique and hierarchical B-splines.</p>
<p>First, we include the required modules. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sgpp__base_8hpp.html">sgpp_base.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sgpp__combigrid_8hpp.html">sgpp_combigrid.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="ttc" id="asgpp__base_8hpp_html"><div class="ttname"><a href="sgpp__base_8hpp.html">sgpp_base.hpp</a></div></div>
<div class="ttc" id="asgpp__combigrid_8hpp_html"><div class="ttname"><a href="sgpp__combigrid_8hpp.html">sgpp_combigrid.hpp</a></div></div>
</div><!-- fragment --><p>We define some parameters such as dimensionality and level of the regular sparse grid. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">  <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> dim = 2;</div>
<div class="line">  <span class="comment">// regular level</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 4;</div>
<div class="line">  <span class="comment">// B-spline degree</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> p = 3;</div>
<div class="line">  <span class="comment">// whether there are points on the boundary</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasBoundary = <span class="keyword">true</span>;</div>
<div class="line">  <span class="comment">// test function</span></div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a> = [](<span class="keyword">const</span> <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a>&amp; x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::sin(7.0 * x[0] - 3.0) * std::cos(5.0 * x[1] - 5.0);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// disable log output</span></div>
<div class="line">  <a class="code hl_function" href="classsgpp_1_1base_1_1Printer.html#a5cc60c954810dc07092dd0052a6ba000">sgpp::base::Printer::getInstance</a>().<a class="code hl_function" href="classsgpp_1_1base_1_1Printer.html#a4de90f658c31985edab233cee46162a9">setVerbosity</a>(-1);</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Printer_html_a4de90f658c31985edab233cee46162a9"><div class="ttname"><a href="classsgpp_1_1base_1_1Printer.html#a4de90f658c31985edab233cee46162a9">sgpp::base::Printer::setVerbosity</a></div><div class="ttdeci">void setVerbosity(int level)</div><div class="ttdef"><b>Definition</b> Printer.hpp:154</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Printer_html_a5cc60c954810dc07092dd0052a6ba000"><div class="ttname"><a href="classsgpp_1_1base_1_1Printer.html#a5cc60c954810dc07092dd0052a6ba000">sgpp::base::Printer::getInstance</a></div><div class="ttdeci">static Printer &amp; getInstance()</div><div class="ttdef"><b>Definition</b> Printer.cpp:43</div></div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>The basis functions are defined via an <a class="el" href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html" title="Potentially hetereogeneous basis on full grids, i.e., a dim-dimensional vector of 1D bases of type sg...">sgpp::combigrid::HeterogeneousBasis</a> object. In contrast to <a class="el" href="classsgpp_1_1base_1_1Basis.html" title="Basis class for basis functions.">sgpp::base::Basis</a>, this allows for different types of basis functions for the different dimensions. However, for this example, we do not need this flexibility, so we use the same basis function types for both dimensions. </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1BsplineBasis.html">sgpp::base::SBsplineBase</a> basis1d(p);</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html">sgpp::combigrid::HeterogeneousBasis</a> basis(dim, basis1d);</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1BsplineBasis_html"><div class="ttname"><a href="classsgpp_1_1base_1_1BsplineBasis.html">sgpp::base::BsplineBasis&lt; unsigned int, unsigned int &gt;</a></div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1HeterogeneousBasis_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html">sgpp::combigrid::HeterogeneousBasis</a></div><div class="ttdoc">Potentially hetereogeneous basis on full grids, i.e., a dim-dimensional vector of 1D bases of type sg...</div><div class="ttdef"><b>Definition</b> HeterogeneousBasis.hpp:24</div></div>
</div><!-- fragment --><p>An <a class="el" href="classsgpp_1_1combigrid_1_1CombinationGrid.html" title="Class for representing a collection of full grids together with one scalar coefficient per full grid.">sgpp::combigrid::CombinationGrid</a> is a collection of full grids (nodal subspaces) together with scalar-valued coefficients. Here, we construct an <a class="el" href="classsgpp_1_1combigrid_1_1CombinationGrid.html" title="Class for representing a collection of full grids together with one scalar coefficient per full grid.">sgpp::combigrid::CombinationGrid</a> object for a regular sparse grid via the combination technique. </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1CombinationGrid.html">sgpp::combigrid::CombinationGrid</a> combiGrid =</div>
<div class="line">      <a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a9846ba8ffe91e25bde6519389e831175">sgpp::combigrid::CombinationGrid::fromRegularSparse</a>(dim, n, basis,</div>
<div class="line">                                                          hasBoundary);</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html">sgpp::combigrid::CombinationGrid</a></div><div class="ttdoc">Class for representing a collection of full grids together with one scalar coefficient per full grid.</div><div class="ttdef"><b>Definition</b> CombinationGrid.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a9846ba8ffe91e25bde6519389e831175"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a9846ba8ffe91e25bde6519389e831175">sgpp::combigrid::CombinationGrid::fromRegularSparse</a></div><div class="ttdeci">static CombinationGrid fromRegularSparse(size_t dim, level_t n, const HeterogeneousBasis &amp;basis, bool hasBoundary=true)</div><div class="ttdoc">Factory method to create a CombinationGrid corresponding to the combination technique for a regular s...</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:29</div></div>
</div><!-- fragment --><p>We obtain the grid points of the regular sparse grid by combining the grid points of all full grids that are contained in the combination grid. </p><div class="fragment"><div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a> gridStorage(dim);</div>
<div class="line">  combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a65b546bb18bb5fcb1747f031fb654743">combinePoints</a>(gridStorage);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// evaluate test function at grid points</span></div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> fX(gridStorage.getSize());</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> x(dim);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; gridStorage.getSize(); k++) {</div>
<div class="line">    gridStorage.getPoint(k).getStandardCoordinates(x);</div>
<div class="line">    fX[k] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(x);</div>
<div class="line">  }</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridStorage_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a></div><div class="ttdoc">Generic hash table based storage of grid points.</div><div class="ttdef"><b>Definition</b> HashGridStorage.hpp:42</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a65b546bb18bb5fcb1747f031fb654743"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a65b546bb18bb5fcb1747f031fb654743">sgpp::combigrid::CombinationGrid::combinePoints</a></div><div class="ttdeci">void combinePoints(base::GridStorage &amp;gridStorage) const</div><div class="ttdoc">Combine the grid points of all full grids of this combination grid and store the grid points in an ex...</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:97</div></div>
</div><!-- fragment --><p>We now want to perform an operation on each full grid. For this, we distribute the values of the combined grid (sparse grid) to the full grids. The result is a <code>std::vector</code> of <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a>; each <code>DataVector</code> contains the values at all grid points for one specific full grid. </p><div class="fragment"><div class="line">  std::vector&lt;sgpp::base::DataVector&gt; values;</div>
<div class="line">  combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a55e9dcb8817afdc3b43577a966a07463">distributeValuesToFullGrids</a>(gridStorage, fX, values);</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a55e9dcb8817afdc3b43577a966a07463"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a55e9dcb8817afdc3b43577a966a07463">sgpp::combigrid::CombinationGrid::distributeValuesToFullGrids</a></div><div class="ttdeci">void distributeValuesToFullGrids(const base::GridStorage &amp;gridStorage, const base::DataVector &amp;values, std::vector&lt; base::DataVector &gt; &amp;result) const</div><div class="ttdoc">Distribute values given on the combined grid to the full grids contained in this combination grid.</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:200</div></div>
</div><!-- fragment --><p>The operation we want to perform on each full grid is hierarchization. Since the grids are full grids, we can use the unidirectional principle for this, which performs 1D hierarchization on each pole (one-dimensional sub-grid), iterating over all dimensions. </p><div class="fragment"><div class="line">  <span class="comment">// copy the values (surpluses will be modified in-place)</span></div>
<div class="line">  std::vector&lt;sgpp::base::DataVector&gt; surpluses(values);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create pole operation</span></div>
<div class="line">  std::vector&lt;std::unique_ptr&lt;sgpp::combigrid::OperationPole&gt;&gt; opPole;</div>
<div class="line">  <a class="code hl_function" href="classsgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral.html#acf4d283e783ae49278d071ce2212ed25">sgpp::combigrid::OperationPoleHierarchisationGeneral::fromHeterogenerousBasis</a>(</div>
<div class="line">      basis, opPole);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create operation for unidirectional principle and hierarchize in-place</span></div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a> opHier(combiGrid, opPole);</div>
<div class="line">  opHier.apply(surpluses);</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral_html_acf4d283e783ae49278d071ce2212ed25"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral.html#acf4d283e783ae49278d071ce2212ed25">sgpp::combigrid::OperationPoleHierarchisationGeneral::fromHeterogenerousBasis</a></div><div class="ttdeci">static void fromHeterogenerousBasis(const HeterogeneousBasis &amp;basis, std::vector&lt; std::unique_ptr&lt; OperationPole &gt; &gt; &amp;operation)</div><div class="ttdoc">Factory method to create a vector of unique_ptr to OperationPoleHierarchisationGeneral objects from a...</div><div class="ttdef"><b>Definition</b> OperationPoleHierarchisationGeneral.cpp:23</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationUPCombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a></div><div class="ttdoc">Operation for applying 1D OperationPole operators on all poles of all full grids of some combination ...</div><div class="ttdef"><b>Definition</b> OperationUPCombinationGrid.hpp:22</div></div>
</div><!-- fragment --><p>The resulting surpluses are also a <code>std::vector</code> of <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a>, separated by full grids. We could combine the full grid surpluses via the combination formula to the sparse grid surpluses via <code>combineSparseGridValues</code>. However, the operation <a class="el" href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html" title="Operation for evaluating a combination grid function (linear combination of linear combinations of fu...">sgpp::combigrid::OperationEvalCombinationGrid</a> does this automatically.</p>
<p>We evaluate the combined function (combination of all full grid interpolants) at some arbitrary point and print the value. </p><div class="fragment"><div class="line">  <span class="comment">// test point at which to evaluate</span></div>
<div class="line">  x.assign({0.12, 0.34});</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Value of test function at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1]</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(x) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create operation for evaluating and evaluate</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html">sgpp::combigrid::OperationEvalCombinationGrid</a> opEval(combiGrid);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(surpluses, x);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of combined sparse grid interpolant at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">              &lt;&lt; x[1] &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationEvalCombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html">sgpp::combigrid::OperationEvalCombinationGrid</a></div><div class="ttdoc">Operation for evaluating a combination grid function (linear combination of linear combinations of fu...</div><div class="ttdef"><b>Definition</b> OperationEvalCombinationGrid.hpp:23</div></div>
</div><!-- fragment --><p>Finally, we do the same for one full grid of the combination grid: We evaluate the corresponding interpolant. We extract the surpluses from the already calculated <code>vector</code> of <code>DataVector</code>. Alternatively, we could also apply <a class="el" href="classsgpp_1_1combigrid_1_1OperationUPFullGrid.html" title="Operation for applying 1D OperationPole operators on all poles of a full grid in all dimensions via t...">sgpp::combigrid::OperationUPFullGrid</a> with opPole to obtain the surpluses for this single full grid. </p><div class="fragment"><div class="line">  <span class="comment">// select the second full grid of the combination grid (arbitrary choice)</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> fullGridIndex = 1;</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classsgpp_1_1combigrid_1_1FullGrid.html">sgpp::combigrid::FullGrid</a>&amp; fullGrid =</div>
<div class="line">      combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a7cf25bf88929f7d47b243b8865e379f3">getFullGrids</a>()[fullGridIndex];</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_typedef" href="namespacesgpp_1_1combigrid.html#a5d2134ac1c4fbda63cf234522b27d5a5">sgpp::combigrid::LevelVector</a>&amp; l = fullGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1FullGrid.html#ad646af428f584d9e606eea8cd1041610">getLevel</a>();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Level of selected full grid with index &quot;</span> &lt;&lt; fullGridIndex</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; l[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; l[1] &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create operation for evaluating and evaluate</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalFullGrid.html">sgpp::combigrid::OperationEvalFullGrid</a> opEval(fullGrid);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(surpluses[fullGridIndex], x);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of full grid interpolant at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a7cf25bf88929f7d47b243b8865e379f3"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a7cf25bf88929f7d47b243b8865e379f3">sgpp::combigrid::CombinationGrid::getFullGrids</a></div><div class="ttdeci">const std::vector&lt; FullGrid &gt; &amp; getFullGrids() const</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:229</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1FullGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1FullGrid.html">sgpp::combigrid::FullGrid</a></div><div class="ttdoc">Full grid essentially represented by its level and a HeterogeneousBasis.</div><div class="ttdef"><b>Definition</b> FullGrid.hpp:22</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1FullGrid_html_ad646af428f584d9e606eea8cd1041610"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1FullGrid.html#ad646af428f584d9e606eea8cd1041610">sgpp::combigrid::FullGrid::getLevel</a></div><div class="ttdeci">const LevelVector &amp; getLevel() const</div><div class="ttdef"><b>Definition</b> FullGrid.hpp:86</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationEvalFullGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationEvalFullGrid.html">sgpp::combigrid::OperationEvalFullGrid</a></div><div class="ttdoc">Operation for evaluating a full grid function (linear combination of full grid basis functions).</div><div class="ttdef"><b>Definition</b> OperationEvalFullGrid.hpp:20</div></div>
<div class="ttc" id="anamespacesgpp_1_1combigrid_html_a5d2134ac1c4fbda63cf234522b27d5a5"><div class="ttname"><a href="namespacesgpp_1_1combigrid.html#a5d2134ac1c4fbda63cf234522b27d5a5">sgpp::combigrid::LevelVector</a></div><div class="ttdeci">std::vector&lt; level_t &gt; LevelVector</div><div class="ttdoc">level multi-index</div><div class="ttdef"><b>Definition</b> LevelIndexTypes.hpp:20</div></div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">Value of test function at [0.12 0.34]: 0.820974
Value of combined sparse grid interpolant at [0.12 0.34]: 0.774666
Level of selected full grid with index 1: [3 1]
Value of full grid interpolant at [0.12 0.34]: 0.564036
</pre><p>We see that the value of the combined sparse grid interpolant at the evaluation point is closer to the actual value of the test function than the value of the chosen full grid interpolant, which corresponds to the full grid of level \((3, 1)\). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_cpp.html">C++ Examples</a></li>
    <li class="footer">Generated on Mon Feb 24 2025 09:21:46 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
