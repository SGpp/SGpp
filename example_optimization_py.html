<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Optimization Example (Python)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_optimization_py.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Optimization Example (Python)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>On this page, we look at an example application of the <a class="el" href="namespacesgpp_1_1optimization.html">sgpp::optimization</a> module.</p>
<p>Versions of the example are given in all languages currently supported by SG++: C++, Python, Java, and MATLAB.</p>
<p>The example interpolates a bivariate test function with B-splines instead of piecewise linear basis functions to obtain a smoother interpolant. The resulting sparse grid function is then minimized with the method of steepest descent. For comparison, we also minimize the objective function with Nelder-Mead's method.</p>
<p>First, we import pysgpp and the required modules. </p><div class="fragment"><div class="line"><span class="keyword">import</span> pysgpp</div>
<div class="line"><span class="keyword">import</span> math</div>
<div class="line"><span class="keyword">import</span> sys</div>
<div class="line"> </div>
</div><!-- fragment --><p>The function \(f\colon [0, 1]^d \to \mathbb{R}\) to be minimized is called <em>objective function</em> and has to derive from pysgpp.ScalarFunction. In the constructor, we give the dimensionality of the domain (in this case \(d = 2\)). The eval method evaluates the objective function and returns the function value \(f(\vec{x})\) for a given point \(\vec{x} \in [0, 1]^d\). </p><div class="fragment"><div class="line"><span class="keyword">class </span>ExampleFunction(pysgpp.ScalarFunction):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Example objective function from the title of my Master&#39;s thesis.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        super(ExampleFunction, self).__init__(2)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>eval(self, x):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Evaluates the function.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> math.sin(8.0 * x[0]) + math.sin(7.0 * x[1])</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>printLine():</div>
<div class="line">    print(<span class="stringliteral">&quot;----------------------------------------&quot;</span> + \</div>
<div class="line">          <span class="stringliteral">&quot;----------------------------------------&quot;</span>)</div>
<div class="line"> </div>
</div><!-- fragment --><p>We have to disable OpenMP within pysgpp since it interferes with SWIG's director feature. </p><div class="fragment"><div class="line">pysgpp.omp_set_num_threads(1)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;sgpp::optimization example program started.\n&quot;</span>)</div>
<div class="line"><span class="comment"># increase verbosity of the output</span></div>
<div class="line">pysgpp.Printer.getInstance().setVerbosity(2)</div>
</div><!-- fragment --><p>Here, we define some parameters: objective function, dimensionality, B-spline degree, maximal number of grid points, and adaptivity. </p><div class="fragment"><div class="line"><span class="comment"># objective function</span></div>
<div class="line">f = ExampleFunction()</div>
<div class="line"><span class="comment"># dimension of domain</span></div>
<div class="line">d = f.getNumberOfParameters()</div>
<div class="line"><span class="comment"># B-spline degree</span></div>
<div class="line">p = 3</div>
<div class="line"><span class="comment"># maximal number of grid points</span></div>
<div class="line">N = 30</div>
<div class="line"><span class="comment"># adaptivity of grid generation</span></div>
<div class="line">gamma = 0.95</div>
</div><!-- fragment --><p>First, we define a grid with modified B-spline basis functions and an iterative grid generator, which can generate the grid adaptively. </p><div class="fragment"><div class="line">grid = pysgpp.Grid.createModBsplineGrid(d, p)</div>
<div class="line">gridGen = pysgpp.OptIterativeGridGeneratorRitterNovak(f, grid, N, gamma)</div>
</div><!-- fragment --><p>With the iterative grid generator, we generate adaptively a sparse grid. </p><div class="fragment"><div class="line">printLine()</div>
<div class="line">print(<span class="stringliteral">&quot;Generating grid...\n&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> gridGen.generate():</div>
<div class="line">    print(<span class="stringliteral">&quot;Grid generation failed, exiting.&quot;</span>)</div>
<div class="line">    sys.exit(1)</div>
</div><!-- fragment --><p>Then, we hierarchize the function values to get hierarchical B-spline coefficients of the B-spline sparse grid interpolant \(\tilde{f}\colon [0, 1]^d \to \mathbb{R}\). </p><div class="fragment"><div class="line">printLine()</div>
<div class="line">print(<span class="stringliteral">&quot;Hierarchizing...\n&quot;</span>)</div>
<div class="line">functionValues = gridGen.getFunctionValues()</div>
<div class="line">coeffs = pysgpp.DataVector(len(functionValues))</div>
<div class="line">hierSLE = pysgpp.HierarchisationSLE(grid)</div>
<div class="line">sleSolver = pysgpp.AutoSLESolver()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># solve linear system</span></div>
<div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> sleSolver.solve(hierSLE, gridGen.getFunctionValues(), coeffs):</div>
<div class="line">    print(<span class="stringliteral">&quot;Solving failed, exiting.&quot;</span>)</div>
<div class="line">    sys.exit(1)</div>
</div><!-- fragment --><p>We define the interpolant \(\tilde{f}\) and its gradient \(\nabla\tilde{f}\) for use with the gradient method (steepest descent). Of course, one can also use other optimization algorithms from <a class="el" href="namespacesgpp_1_1optimization_1_1optimizer.html">sgpp::optimization::optimizer</a>. </p><div class="fragment"><div class="line">printLine()</div>
<div class="line">print(<span class="stringliteral">&quot;Optimizing smooth interpolant...\n&quot;</span>)</div>
<div class="line">ft = pysgpp.InterpolantScalarFunction(grid, coeffs)</div>
<div class="line">ftGradient = pysgpp.InterpolantScalarFunctionGradient(grid, coeffs)</div>
<div class="line">gradientDescent = pysgpp.OptGradientDescent(ft, ftGradient)</div>
<div class="line">x0 = pysgpp.DataVector(d)</div>
</div><!-- fragment --><p>The gradient method needs a starting point. We use a point of our adaptively generated sparse grid as starting point. More specifically, we use the point with the smallest (most promising) function value and save it in x0. </p><div class="fragment"><div class="line">gridStorage = gridGen.getGrid().getStorage()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># index of grid point with minimal function value</span></div>
<div class="line">x0Index = 0</div>
<div class="line">fX0 = functionValues[0]</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, len(functionValues)):</div>
<div class="line">    <span class="keywordflow">if</span> functionValues[i] &lt; fX0:</div>
<div class="line">        fX0 = functionValues[i]</div>
<div class="line">        x0Index = i</div>
<div class="line"> </div>
<div class="line">x0 = gridStorage.getCoordinates(gridStorage.getPoint(x0Index));</div>
<div class="line">ftX0 = ft.eval(x0)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;x0 = {}&quot;</span>.format(x0))</div>
<div class="line">print(<span class="stringliteral">&quot;f(x0) = {:.6g}, ft(x0) = {:.6g}\n&quot;</span>.format(fX0, ftX0))</div>
</div><!-- fragment --><p>We apply the gradient method and print the results. </p><div class="fragment"><div class="line">gradientDescent.setStartingPoint(x0)</div>
<div class="line">gradientDescent.optimize()</div>
<div class="line">xOpt = gradientDescent.getOptimalPoint()</div>
<div class="line">ftXOpt = gradientDescent.getOptimalValue()</div>
<div class="line">fXOpt = f.eval(xOpt)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\nxOpt = {}&quot;</span>.format(xOpt))</div>
<div class="line">print(<span class="stringliteral">&quot;f(xOpt) = {:.6g}, ft(xOpt) = {:.6g}\n&quot;</span>.format(fXOpt, ftXOpt))</div>
</div><!-- fragment --><p>For comparison, we apply the classical gradient-free Nelder-Mead method directly to the objective function \(f\). </p><div class="fragment"><div class="line">printLine()</div>
<div class="line">print(<span class="stringliteral">&quot;Optimizing objective function (for comparison)...\n&quot;</span>)</div>
<div class="line">nelderMead = pysgpp.OptNelderMead(f, 1000)</div>
<div class="line">nelderMead.optimize()</div>
<div class="line">xOptNM = nelderMead.getOptimalPoint()</div>
<div class="line">fXOptNM = nelderMead.getOptimalValue()</div>
<div class="line">ftXOptNM = ft.eval(xOptNM)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\nxOptNM = {}&quot;</span>.format(xOptNM))</div>
<div class="line">print(<span class="stringliteral">&quot;f(xOptNM) = {:.6g}, ft(xOptNM) = {:.6g}\n&quot;</span>.format(fXOptNM, ftXOptNM))</div>
<div class="line"> </div>
<div class="line">printLine()</div>
<div class="line">print(<span class="stringliteral">&quot;\nsgpp::optimization example program terminated.&quot;</span>)</div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">sgpp::optimization example program started.

--------------------------------------------------------------------------------
Generating grid...

Adaptive grid generation (Ritter-Novak)...
    100.0% (N = 29, k = 3)
Done in 3ms.
--------------------------------------------------------------------------------
Hierarchizing...

Solving linear system (automatic method)...
    estimated nnz ratio: 59.8% 
    Solving linear system (Armadillo)...
        constructing matrix (100.0%)
        nnz ratio: 58.0%
        solving with Armadillo
    Done in 0ms.
Done in 1ms.
--------------------------------------------------------------------------------
Optimizing smooth interpolant...

x0 = [0.625, 0.75]
f(x0) = -1.81786, ft(x0) = -1.81786

Optimizing (gradient method)...
    9 steps, f(x) = -2.000780
Done in 1ms.

xOpt = [0.589526, 0.673268]
f(xOpt) = -1.99999, ft(xOpt) = -2.00078

--------------------------------------------------------------------------------
Optimizing objective function (for comparison)...

Optimizing (Nelder-Mead)...
    280 steps, f(x) = -2.000000
Done in 2ms.

xOptNM = [0.589049, 0.673198]
f(xOptNM) = -2, ft(xOptNM) = -2.00077

--------------------------------------------------------------------------------

sgpp::optimization example program terminated.
</pre><p>We see that both the gradient-based optimization of the smooth sparse grid interpolant and the gradient-free optimization of the objective function find reasonable approximations of the minimum, which lies at \((3\pi/16, 3\pi/14) \approx (0.58904862, 0.67319843)\). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_py.html">Python Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:24:10 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
