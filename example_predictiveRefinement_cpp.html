<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Spatially-Dimension-Adaptive Refinement in C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_predictiveRefinement_cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Spatially-Dimension-Adaptive Refinement in C++</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We compute the sparse grid interpolant of the function \( f(x) =
\sin(\pi x).\) We perform spatially-dimension-adaptive refinement of the sparse grid model, which means we refine a particular grid point (locality) only in some dimensions (dimensionality).</p>
<p>For details on spatially-dimension-adaptive refinement see </p><pre class="fragment">V. Khakhutskyy and M. Hegland: Spatially-Dimension-Adaptive Sparse Grids for Online Learning.
In D. Pflüger and J. Garcke (ed.), Sparse Grids and Applications - Stuttgart 2014, Volume 109 of
LNCSE, p. 133–162. Springer International Publishing, March 2016.
</pre><p>The example can be found in the file <code>predictiveRefinement.cpp</code>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DataMatrix_8hpp.html">sgpp/base/datatypes/DataMatrix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DataVector_8hpp.html">sgpp/base/datatypes/DataVector.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Grid_8hpp.html">sgpp/base/grid/Grid.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridStorage_8hpp.html">sgpp/base/grid/GridStorage.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridGenerator_8hpp.html">sgpp/base/grid/generation/GridGenerator.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PredictiveRefinementIndicator_8hpp.html">sgpp/base/grid/generation/functors/PredictiveRefinementIndicator.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="HashRefinement_8hpp.html">sgpp/base/grid/generation/hashmap/HashRefinement.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PredictiveRefinement_8hpp.html">sgpp/base/grid/generation/refinement_strategy/PredictiveRefinement.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="BaseOpFactory_8hpp.html">sgpp/base/operation/BaseOpFactory.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="OperationEval_8hpp.html">sgpp/base/operation/hash/OperationEval.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1DataMatrix.html">sgpp::base::DataMatrix</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1GridGenerator.html">sgpp::base::GridGenerator</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::GridStorage</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1HashRefinement.html">sgpp::base::HashRefinement</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1OperationEval.html">sgpp::base::OperationEval</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1PredictiveRefinement.html">sgpp::base::PredictiveRefinement</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1PredictiveRefinementIndicator.html">sgpp::base::PredictiveRefinementIndicator</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="classsgpp_1_1base_1_1OperationHierarchisation.html">sgpp::base::OperationHierarchisation</a>;</div>
<div class="ttc" id="aBaseOpFactory_8hpp_html"><div class="ttname"><a href="BaseOpFactory_8hpp.html">BaseOpFactory.hpp</a></div></div>
<div class="ttc" id="aDataMatrix_8hpp_html"><div class="ttname"><a href="DataMatrix_8hpp.html">DataMatrix.hpp</a></div></div>
<div class="ttc" id="aDataVector_8hpp_html"><div class="ttname"><a href="DataVector_8hpp.html">DataVector.hpp</a></div></div>
<div class="ttc" id="aGridGenerator_8hpp_html"><div class="ttname"><a href="GridGenerator_8hpp.html">GridGenerator.hpp</a></div></div>
<div class="ttc" id="aGridStorage_8hpp_html"><div class="ttname"><a href="GridStorage_8hpp.html">GridStorage.hpp</a></div></div>
<div class="ttc" id="aGrid_8hpp_html"><div class="ttname"><a href="Grid_8hpp.html">Grid.hpp</a></div></div>
<div class="ttc" id="aHashRefinement_8hpp_html"><div class="ttname"><a href="HashRefinement_8hpp.html">HashRefinement.hpp</a></div></div>
<div class="ttc" id="aOperationEval_8hpp_html"><div class="ttname"><a href="OperationEval_8hpp.html">OperationEval.hpp</a></div></div>
<div class="ttc" id="aPredictiveRefinementIndicator_8hpp_html"><div class="ttname"><a href="PredictiveRefinementIndicator_8hpp.html">PredictiveRefinementIndicator.hpp</a></div></div>
<div class="ttc" id="aPredictiveRefinement_8hpp_html"><div class="ttname"><a href="PredictiveRefinement_8hpp.html">PredictiveRefinement.hpp</a></div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataMatrix_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataMatrix.html">sgpp::base::DataMatrix</a></div><div class="ttdoc">A class to store two-dimensional data.</div><div class="ttdef"><b>Definition</b> DataMatrix.hpp:28</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1GridGenerator_html"><div class="ttname"><a href="classsgpp_1_1base_1_1GridGenerator.html">sgpp::base::GridGenerator</a></div><div class="ttdoc">Abstract class that defines the interfaces for the different grid's GridGenerators.</div><div class="ttdef"><b>Definition</b> GridGenerator.hpp:26</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Grid_html"><div class="ttname"><a href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a></div><div class="ttdoc">abstract base class for all types grids used in sgpp the class gives pure virtual function definition...</div><div class="ttdef"><b>Definition</b> Grid.hpp:191</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridStorage_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a></div><div class="ttdoc">Generic hash table based storage of grid points.</div><div class="ttdef"><b>Definition</b> HashGridStorage.hpp:42</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashRefinement_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashRefinement.html">sgpp::base::HashRefinement</a></div><div class="ttdoc">Free refinement class for sparse grids.</div><div class="ttdef"><b>Definition</b> HashRefinement.hpp:24</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1OperationEval_html"><div class="ttname"><a href="classsgpp_1_1base_1_1OperationEval.html">sgpp::base::OperationEval</a></div><div class="ttdoc">Operation that evaluates the current sparse grid function defined by the coefficient vector alpha at ...</div><div class="ttdef"><b>Definition</b> OperationEval.hpp:23</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1OperationHierarchisation_html"><div class="ttname"><a href="classsgpp_1_1base_1_1OperationHierarchisation.html">sgpp::base::OperationHierarchisation</a></div><div class="ttdoc">This class implements the hierarchisation and dehierarchisation on the sparse grid.</div><div class="ttdef"><b>Definition</b> OperationHierarchisation.hpp:19</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1PredictiveRefinementIndicator_html"><div class="ttname"><a href="classsgpp_1_1base_1_1PredictiveRefinementIndicator.html">sgpp::base::PredictiveRefinementIndicator</a></div><div class="ttdoc">A refinement error indicator for regression problems based on the residuals of the datasets.</div><div class="ttdef"><b>Definition</b> PredictiveRefinementIndicator.hpp:37</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1PredictiveRefinement_html"><div class="ttname"><a href="classsgpp_1_1base_1_1PredictiveRefinement.html">sgpp::base::PredictiveRefinement</a></div><div class="ttdef"><b>Definition</b> PredictiveRefinement.hpp:63</div></div>
</div><!-- fragment --><p>We define the function \( f(x) =
\sin(\pi x).\) to interpolate. / double <a class="el" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f(double x0, double x1)</a> { return sin(x0 * M_PI); } </p><div class="fragment"><div class="line"> </div>
</div><!-- fragment --><p>Spatially-dimension-adaptive refinement uses squared prediction error on a dataset to compute refinement indicators. Hence, here we define a function to compute these squared errors.</p>
<div class="fragment"><div class="line">DataVector&amp; calculateError(<span class="keyword">const</span> DataMatrix&amp; dataSet, Grid&amp; <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, <span class="keyword">const</span> DataVector&amp; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>,</div>
<div class="line">                           DataVector&amp; error) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;calculating error&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// traverse dataSet</span></div>
<div class="line">  DataVector vec(2);</div>
<div class="line">  std::unique_ptr&lt;OperationEval&gt; opEval(<a class="code hl_function" href="namespacesgpp_1_1op__factory.html#afa95f55361a896584bf43d487d8c4ca8">sgpp::op_factory::createOperationEval</a>(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dataSet.getNrows(); i++) {</div>
<div class="line">    dataSet.getRow(i, vec);</div>
<div class="line">    error[i] = pow(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(dataSet.get(i, 0), dataSet.get(i, 1)) - opEval-&gt;eval(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, vec), 2);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> error;</div>
<div class="line">}</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
<div class="ttc" id="amultHPX_8cpp_html_afaae4b3ccddbff855673417650052c63"><div class="ttname"><a href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a></div><div class="ttdeci">sgpp::base::DataVector alpha</div><div class="ttdef"><b>Definition</b> multHPX.cpp:40</div></div>
<div class="ttc" id="anamespacesgpp_1_1op__factory_html_afa95f55361a896584bf43d487d8c4ca8"><div class="ttname"><a href="namespacesgpp_1_1op__factory.html#afa95f55361a896584bf43d487d8c4ca8">sgpp::op_factory::createOperationEval</a></div><div class="ttdeci">base::OperationEval * createOperationEval(base::Grid &amp;grid)</div><div class="ttdoc">Factory method, returning an OperationEval for the grid at hand.</div><div class="ttdef"><b>Definition</b> BaseOpFactory.cpp:561</div></div>
</div><!-- fragment --><p>Start with the main function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>create a two-dimensional piecewise bilinear grid </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> dim = 2;</div>
<div class="line">  std::unique_ptr&lt;Grid&gt; <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>(Grid::createModLinearGrid(dim));</div>
<div class="line">  GridStorage&amp; gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getStorage();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dimensionality:                   &quot;</span> &lt;&lt; gridStorage.getDimension() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create regular grid, level 3</span></div>
<div class="line">  <span class="keywordtype">size_t</span> <a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a> = 1;</div>
<div class="line">  <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>-&gt;getGenerator().regular(<a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;number of initial grid points:    &quot;</span> &lt;&lt; gridStorage.getSize() &lt;&lt; std::endl;</div>
<div class="ttc" id="amultHPX_8cpp_html_a6a330c3b2adf87bfa27e9a9450d8bc40"><div class="ttname"><a href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a></div><div class="ttdeci">uint32_t level</div><div class="ttdef"><b>Definition</b> multHPX.cpp:26</div></div>
</div><!-- fragment --><p>To create a dataset we use points on a regular 2d grid with a step size of 1 / rows and 1 / cols. </p><div class="fragment"><div class="line">  <span class="keywordtype">int</span> rows = 100;</div>
<div class="line">  <span class="keywordtype">int</span> cols = 100;</div>
<div class="line"> </div>
<div class="line">  DataMatrix dataSet(rows * cols, dim);</div>
<div class="line">  DataVector vals(rows * cols);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; cols; j++) {</div>
<div class="line">      <span class="comment">// xcoord</span></div>
<div class="line">      dataSet.set(i * cols + j, 0, i * 1.0 / rows);</div>
<div class="line">      <span class="comment">// ycoord</span></div>
<div class="line">      dataSet.set(i * cols + j, 1, j * 1.0 / cols);</div>
<div class="line">      vals[i * cols + j] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(i * 1.0 / rows, j * 1.0 / cols);</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>We refine adaptively 20 times. In every step we recompute the vector of surpluses <code>alpha</code>, the vector with squared errors on the dataset <code>errorVector</code>, and then call the refinement routines. </p><div class="fragment"><div class="line">  <span class="comment">// create coefficient vector</span></div>
<div class="line">  DataVector <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>(gridStorage.getSize());</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;length of alpha vector:           &quot;</span> &lt;&lt; <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> step = 0; step &lt; 20; step++) {</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a4ec9b893255175cc583323968788b1b1"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize</a></div><div class="ttdeci">size_t getSize() const</div><div class="ttdoc">gets the elements stored in the vector</div><div class="ttdef"><b>Definition</b> DataVector.hpp:365</div></div>
</div><!-- fragment --><p>Step 1: calculate the surplus vector alpha. In data mining with do it by solving a regression problem. Here, the function can be evaluated at any point. Hence. we simply evaluate it at the coordinates of the grid points to obtain the nodal values. Then we use hierarchization to obtain the surplus value.</p>
<div class="fragment"><div class="line">    <span class="comment">// set function values in alpha</span></div>
<div class="line">    DataVector gridPointCoordinates(dim);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; gridStorage.getSize(); i++) {</div>
<div class="line">      gridStorage.getPoint(i).getStandardCoordinates(gridPointCoordinates);</div>
<div class="line">      <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>[i] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(gridPointCoordinates[0], gridPointCoordinates[1]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// hierarchize</span></div>
<div class="line">    std::unique_ptr&lt;OperationHierarchisation&gt;(</div>
<div class="line">        <a class="code hl_function" href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a>(*<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>))</div>
<div class="line">        -&gt;doHierarchisation(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>);</div>
<div class="ttc" id="anamespacesgpp_1_1op__factory_html_a08b6aa545e0f57f47b5cfdafd4f781e4"><div class="ttname"><a href="namespacesgpp_1_1op__factory.html#a08b6aa545e0f57f47b5cfdafd4f781e4">sgpp::op_factory::createOperationHierarchisation</a></div><div class="ttdeci">base::OperationHierarchisation * createOperationHierarchisation(base::Grid &amp;grid)</div><div class="ttdoc">Factory method, returning an OperationHierarchisation for the grid at hand.</div><div class="ttdef"><b>Definition</b> BaseOpFactory.cpp:275</div></div>
</div><!-- fragment --><p>Step 2: calculate squared errors. </p><div class="fragment"><div class="line">    DataVector errorVector(dataSet.getNrows());</div>
<div class="line">    calculateError(dataSet, *<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, errorVector);</div>
</div><!-- fragment --><p>Step 3: call refinement routines. <code>PredictiveRefinement</code> implements the decorator pattern and extends the functionality of <code>HashRefinement</code>. <code>PredictiveRefinement</code> requires a special kind of refinement functor &ndash; <code>PredictiveRefinementIndicator</code> that can access the dataset and the error vector. The refinement itself if performed by calling <code>.free_refine()</code> same for normal refinement in <code>HashRefinement</code>.</p>
<div class="fragment"><div class="line">    <span class="comment">// refinement  stuff</span></div>
<div class="line">    HashRefinement refinement;</div>
<div class="line">    PredictiveRefinement decorator(&amp;refinement);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// refine a single grid point each time</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Error over all = &quot;</span> &lt;&lt; errorVector.sum() &lt;&lt; std::endl;</div>
<div class="line">    PredictiveRefinementIndicator indicator(*<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, dataSet, errorVector, 1);</div>
<div class="line">    decorator.free_refine(gridStorage, indicator);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; step + 1 &lt;&lt; <span class="stringliteral">&quot;, new grid size: &quot;</span> &lt;&lt; gridStorage.getSize()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// extend alpha vector (new entries uninitialized)</span></div>
<div class="line">    <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.resize(gridStorage.getSize());</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The output of the program should look like this</p>
<pre class="fragment">dimensionality:                   2
number of initial grid points:    1
length of alpha vector:           1
calculating error
Error over all = 2268.65
Refinement step 1, new grid size: 3
calculating error
Error over all = 264.09
Refinement step 2, new grid size: 5
calculating error
Error over all = 125.378
Refinement step 3, new grid size: 7
calculating error
Error over all = 3.48359
Refinement step 4, new grid size: 9
calculating error
Error over all = 1.99757
Refinement step 5, new grid size: 11
calculating error
Error over all = 0.845349
Refinement step 6, new grid size: 13
calculating error
Error over all = 0.464096
Refinement step 7, new grid size: 15
calculating error
Error over all = 0.0828432
Refinement step 8, new grid size: 17
calculating error
Error over all = 0.0828432
Refinement step 9, new grid size: 19
calculating error
Error over all = 0.068976
Refinement step 10, new grid size: 21
calculating error
Error over all = 0.0551672
Refinement step 11, new grid size: 23
calculating error
Error over all = 0.0413584
Refinement step 12, new grid size: 25
calculating error
Error over all = 0.0330229
Refinement step 13, new grid size: 27
calculating error
Error over all = 0.0230578
Refinement step 14, new grid size: 29
calculating error
Error over all = 0.0130926
Refinement step 15, new grid size: 31
calculating error
Error over all = 0.00856834
Refinement step 16, new grid size: 33
calculating error
Error over all = 0.00404405
Refinement step 17, new grid size: 35
calculating error
Error over all = 0.00404405
Refinement step 18, new grid size: 37
calculating error
Error over all = 0.00404405
Refinement step 19, new grid size: 41
calculating error
Error over all = 0.00404405
Refinement step 20, new grid size: 45
</pre><div class="fragment"></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_cpp.html">C++ Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:24:10 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
