// Copyright (C) 2008-today The SG++ project
// This file is part of the SG++ project. For conditions of distribution and
// use, please see the copyright notice provided with SG++ or at
// sgpp.sparsegrids.org

#pragma once

#include <sgpp/base/exception/not_implemented_exception.hpp>
#include <sgpp/base/grid/generation/functors/RefinementFunctor.hpp>
#include <sgpp/datadriven/algorithm/CombiScheme.hpp>
#include <sgpp/datadriven/algorithm/DBMatObjectStore.hpp>
#include <sgpp/datadriven/datamining/modules/fitting/FitterConfigurationDensityEstimation.hpp>
#include <sgpp/datadriven/datamining/modules/fitting/ModelFittingDensityEstimation.hpp>
#include <sgpp/datadriven/datamining/modules/fitting/ModelFittingDensityEstimationOnOff.hpp>
#include <sgpp/globaldef.hpp>

#include <list>
#include <utility>
#include <vector>

namespace sgpp {
namespace datadriven {

/**
 * Abstract super class to encapsulate density estimation models working with
 * multiple Grids.
 */

class ModelFittingDensityEstimationCombi : public ModelFittingDensityEstimation {
 public:
  /**
   * Default constructor
   */
  ModelFittingDensityEstimationCombi();

  /**
   * Constructor from a configuration object generated by the datamining
   * pipeline
   * @param config configuration object generated by the datamining pipeline
   */
  explicit ModelFittingDensityEstimationCombi(const FitterConfigurationDensityEstimation& config);

  /**
   * @brief Construct from a configuration object generated from the datamining
   * pipeline and a
   * object store to obtain and store already decomposed offline objects.
   *
   * @param config   Configuration object generated by the datamining pipeline.
   * @param objectStore  Offline object store.
   */
  explicit ModelFittingDensityEstimationCombi(const FitterConfigurationDensityEstimation& config,
                                              std::shared_ptr<DBMatObjectStore> objectStore);

  /**
   * Fit the grids to the given dataset by determining the weights of the
   * initial grid by the
   * SGDE approach.
   * @param newDataset the training dataset that is used to fit the model.
   */
  void fit(Dataset& newDataset) override;
  void fit(Dataset& newDatasetP, Dataset& newDatasetQ) override {
    throw base::application_exception("This model requires a single input dataset");
  }

  /**
   * Fit the grids to the given dataset by determining the surpluses of the
   * initial grid by the
   * SGDE approach. Requires only data samples and no targets (since those are
   * irrelevant for the
   * density estimation whatsoever)
   * @param newDataset the training dataset that is used to fit the model.
   */
  void fit(DataMatrix& newDataset) override;
  void fit(DataMatrix& newDatasetP, DataMatrix& newDatasetQ) override {
    throw base::application_exception("This model requires a single input dataset");
  }

  void update(Dataset& dataset) override;
  void update(Dataset& datasetP, Dataset& datasetQ) override {
    throw base::application_exception("This model requires a single input dataset");
  }

  /**
   * Updates the model based on new data samples (streaming, batch learning).
   * Requires only
   * the data samples and no targets (since those are irrelevant for the density
   * estimation
   * whatsoever)
   * @param samples the new data samples
   */
  void update(DataMatrix& samples) override;
  void update(DataMatrix& samplesP, DataMatrix& samplesQ) override {
    throw base::application_exception("This model requires a single input dataset");
  }

  /**
   * Evaluate the fitted density at a single data point - requires a trained
   * grid.
   * @param sample vector with the coordinates in all dimensions of that sample.
   * @return evaluation of the trained grid.
   */
  double evaluate(const DataVector& sample) override;

  /**
   * Evaluate the fitted density on a set of data points - requires a trained
   * grid.
   * @param samples matrix where each row represents a sample and the columns
   * contain the
   * coordinates in all dimensions of that sample.
   * @param results vector where each row will contain the evaluation of the
   * respective sample on
   * the current model.
   */
  void evaluate(DataMatrix& samples, DataVector& results) override;

  /**
   * Refines the component with the biggest error
   * @return if a component was refined
   */
  bool adapt() override;

  /**
   * Currently not implemented for this class due to missing strategy for
   * dimensional adaptive refinement. Throws an application_exception.
   */
  bool adapt(size_t newNoPoints, std::vector<size_t>& deletedGridPoints) override;

  /**
   * Resets the state of the entire model
   */
  void reset() override;

  /**
   * Should compute some kind of Residual to evaluate the fit of the model.
   *
   * In the case of density estimation, this is
   * || R * alpha_lambda - b_val ||_2
   *
   * This is useful for unsupervised learning models, where normal evaluation
   * cannot be used as
   * there are no targets.
   *
   * @param validationData Matrix for validation data
   *
   * @returns the residual score
   */
  double computeResidual(DataMatrix& validationData) const override {
    throw sgpp::base::not_implemented_exception(
        "ModelFittingDensityEstimationCombi::computeResidual() is not "
        "implemented!");
  }

  /**
   * Updates the regularization parameter lambda of the underlying model.
   *
   * @param lambda the new lambda parameter
   */
  void updateRegularization(double lambda) override {
    throw sgpp::base::not_implemented_exception(
        "ModelFittingDensityEstimationCombi::updateRegularization() is not "
        "implemented!");
  }

  /**
   * Resets any trained representations of the model, but does not reset the
   * entire state.
   */
  void resetTraining() override {
    throw sgpp::base::not_implemented_exception(
        "ModelFittingDensityEstimationCombi::resetTraining() is not "
        "implemented!");
  }

 protected:
  /**
   * @brief The object store passed to component objects
   *
   */
  std::shared_ptr<DBMatObjectStore> objectStore;

  /**
   * @brief True if the instance has an object store
   *
   */
  bool hasObjectStore;
  /**
   * Contains the component grids witch form the sparse grids
   */
  std::vector<std::unique_ptr<ModelFittingDensityEstimation>> components;

  /**
   * Contains all level vector and weights of the current component grid set
   */
  std::vector<std::pair<std::vector<size_t>, int>> componentConfigs;

  /**
   * Contains the status of the component grids.
   * true: fitted
   * false: unfitted
   */
  std::vector<bool> fitted;

  /**
   * Delivers the initial level vectors and weighs and manages refinements
   */
  CombiScheme scheme;

  bool isRefinable() override;

  /**
   * Creates a density estimation model that fits the model settings.
   * @param densityEstimationConfig configuration for the density estimation
   * @return a new density estimation model
   */
  std::unique_ptr<ModelFittingDensityEstimation> createNewModel(
      sgpp::datadriven::FitterConfigurationDensityEstimation& densityEstimationConfig);

  void addNewModel(const std::pair<std::vector<size_t>, int> combiconfig);

  /**
   * @param indexRev the reverse index (distance from the end of the vector) of
   * the component that
   * must be removed
   */
  void removeModel(size_t indexRev);

  // sgpp::DataMatrix datamatrix;
};

}  // namespace datadriven
}  // namespace sgpp
