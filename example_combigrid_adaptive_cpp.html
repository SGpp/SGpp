<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Combigrid Example Dimensional Adaptivity (C++)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_combigrid_adaptive_cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Combigrid Example Dimensional Adaptivity (C++)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example, we use the combigrid module to adapt a combination grid solution to best interpolate a test function at a given point.</p>
<p>First, we include the required modules. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sgpp__base_8hpp.html">sgpp_base.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sgpp__combigrid_8hpp.html">sgpp_combigrid.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>std {</div>
<div class="line"><span class="comment">// needed for printing vectors</span></div>
<div class="line"><span class="keyword">using </span>sgpp::base::operator&lt;&lt;;</div>
<div class="line">}  <span class="comment">// namespace std</span></div>
<div class="ttc" id="asgpp__base_8hpp_html"><div class="ttname"><a href="sgpp__base_8hpp.html">sgpp_base.hpp</a></div></div>
<div class="ttc" id="asgpp__combigrid_8hpp_html"><div class="ttname"><a href="sgpp__combigrid_8hpp.html">sgpp_combigrid.hpp</a></div></div>
</div><!-- fragment --><p>We define parameters and perform hierarchization exactly as in the combigrid example </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">  <span class="comment">// dimensionality</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> dim = 2;</div>
<div class="line">  <span class="comment">// regular level</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = 4;</div>
<div class="line">  <span class="comment">// B-spline degree</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> p = 3;</div>
<div class="line">  <span class="comment">// whether there are points on the boundary</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> hasBoundary = <span class="keyword">true</span>;</div>
<div class="line">  <span class="comment">// test function</span></div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a> = [](<span class="keyword">const</span> <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a>&amp; x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::sin(7.0 * x[0] - 3.0) * std::cos(5.0 * x[1] - 5.0);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// disable log output</span></div>
<div class="line">  <a class="code hl_function" href="classsgpp_1_1base_1_1Printer.html#a5cc60c954810dc07092dd0052a6ba000">sgpp::base::Printer::getInstance</a>().<a class="code hl_function" href="classsgpp_1_1base_1_1Printer.html#a4de90f658c31985edab233cee46162a9">setVerbosity</a>(-1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1BsplineBasis.html">sgpp::base::SBsplineBase</a> basis1d(p);</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html">sgpp::combigrid::HeterogeneousBasis</a> basis(dim, basis1d);</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1CombinationGrid.html">sgpp::combigrid::CombinationGrid</a> combiGrid =</div>
<div class="line">      <a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a9846ba8ffe91e25bde6519389e831175">sgpp::combigrid::CombinationGrid::fromRegularSparse</a>(dim, n, basis, hasBoundary);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a> gridStorage(dim);</div>
<div class="line">  combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a65b546bb18bb5fcb1747f031fb654743">combinePoints</a>(gridStorage);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> fX(gridStorage.getSize());</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> x(dim);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; gridStorage.getSize(); k++) {</div>
<div class="line">    gridStorage.getPoint(k).getStandardCoordinates(x);</div>
<div class="line">    fX[k] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(x);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;sgpp::base::DataVector&gt; values;</div>
<div class="line">  combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a55e9dcb8817afdc3b43577a966a07463">distributeValuesToFullGrids</a>(gridStorage, fX, values);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;sgpp::base::DataVector&gt; surpluses(values);</div>
<div class="line">  std::vector&lt;std::unique_ptr&lt;sgpp::combigrid::OperationPole&gt;&gt; opPole;</div>
<div class="line">  <a class="code hl_function" href="classsgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral.html#acf4d283e783ae49278d071ce2212ed25">sgpp::combigrid::OperationPoleHierarchisationGeneral::fromHeterogenerousBasis</a>(basis, opPole);</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a> opHier(combiGrid, opPole);</div>
<div class="line">  opHier.apply(surpluses);</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1BsplineBasis_html"><div class="ttname"><a href="classsgpp_1_1base_1_1BsplineBasis.html">sgpp::base::BsplineBasis&lt; unsigned int, unsigned int &gt;</a></div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a></div><div class="ttdoc">A class to store one-dimensional data.</div><div class="ttdef"><b>Definition</b> DataVector.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1HashGridStorage_html"><div class="ttname"><a href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a></div><div class="ttdoc">Generic hash table based storage of grid points.</div><div class="ttdef"><b>Definition</b> HashGridStorage.hpp:42</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Printer_html_a4de90f658c31985edab233cee46162a9"><div class="ttname"><a href="classsgpp_1_1base_1_1Printer.html#a4de90f658c31985edab233cee46162a9">sgpp::base::Printer::setVerbosity</a></div><div class="ttdeci">void setVerbosity(int level)</div><div class="ttdef"><b>Definition</b> Printer.hpp:154</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1Printer_html_a5cc60c954810dc07092dd0052a6ba000"><div class="ttname"><a href="classsgpp_1_1base_1_1Printer.html#a5cc60c954810dc07092dd0052a6ba000">sgpp::base::Printer::getInstance</a></div><div class="ttdeci">static Printer &amp; getInstance()</div><div class="ttdef"><b>Definition</b> Printer.cpp:43</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html">sgpp::combigrid::CombinationGrid</a></div><div class="ttdoc">Class for representing a collection of full grids together with one scalar coefficient per full grid.</div><div class="ttdef"><b>Definition</b> CombinationGrid.hpp:25</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a55e9dcb8817afdc3b43577a966a07463"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a55e9dcb8817afdc3b43577a966a07463">sgpp::combigrid::CombinationGrid::distributeValuesToFullGrids</a></div><div class="ttdeci">void distributeValuesToFullGrids(const base::GridStorage &amp;gridStorage, const base::DataVector &amp;values, std::vector&lt; base::DataVector &gt; &amp;result) const</div><div class="ttdoc">Distribute values given on the combined grid to the full grids contained in this combination grid.</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:200</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a65b546bb18bb5fcb1747f031fb654743"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a65b546bb18bb5fcb1747f031fb654743">sgpp::combigrid::CombinationGrid::combinePoints</a></div><div class="ttdeci">void combinePoints(base::GridStorage &amp;gridStorage) const</div><div class="ttdoc">Combine the grid points of all full grids of this combination grid and store the grid points in an ex...</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:97</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a9846ba8ffe91e25bde6519389e831175"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a9846ba8ffe91e25bde6519389e831175">sgpp::combigrid::CombinationGrid::fromRegularSparse</a></div><div class="ttdeci">static CombinationGrid fromRegularSparse(size_t dim, level_t n, const HeterogeneousBasis &amp;basis, bool hasBoundary=true)</div><div class="ttdoc">Factory method to create a CombinationGrid corresponding to the combination technique for a regular s...</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:29</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1HeterogeneousBasis_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1HeterogeneousBasis.html">sgpp::combigrid::HeterogeneousBasis</a></div><div class="ttdoc">Potentially hetereogeneous basis on full grids, i.e., a dim-dimensional vector of 1D bases of type sg...</div><div class="ttdef"><b>Definition</b> HeterogeneousBasis.hpp:24</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral_html_acf4d283e783ae49278d071ce2212ed25"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationPoleHierarchisationGeneral.html#acf4d283e783ae49278d071ce2212ed25">sgpp::combigrid::OperationPoleHierarchisationGeneral::fromHeterogenerousBasis</a></div><div class="ttdeci">static void fromHeterogenerousBasis(const HeterogeneousBasis &amp;basis, std::vector&lt; std::unique_ptr&lt; OperationPole &gt; &gt; &amp;operation)</div><div class="ttdoc">Factory method to create a vector of unique_ptr to OperationPoleHierarchisationGeneral objects from a...</div><div class="ttdef"><b>Definition</b> OperationPoleHierarchisationGeneral.cpp:23</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationUPCombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a></div><div class="ttdoc">Operation for applying 1D OperationPole operators on all poles of all full grids of some combination ...</div><div class="ttdef"><b>Definition</b> OperationUPCombinationGrid.hpp:22</div></div>
<div class="ttc" id="adensityMultiplication_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="densityMultiplication_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> densityMultiplication.cpp:22</div></div>
</div><!-- fragment --><p>Let's assume that this time we are even more interested in the interpolated value at a given point x, so much so that we would like to extend the combination scheme in a way that makes this value more accurate. <a class="el" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f(x)</a> can be considered the quantity of interest or QoI. </p><div class="fragment"><div class="line">  x.assign({0.12, 0.34});</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Value of test function at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1] &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(x) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create operation for evaluating and evaluate</span></div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html">sgpp::combigrid::OperationEvalCombinationGrid</a> opEval(combiGrid);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(surpluses, x);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of combined sparse grid interpolant at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationEvalCombinationGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html">sgpp::combigrid::OperationEvalCombinationGrid</a></div><div class="ttdoc">Operation for evaluating a combination grid function (linear combination of linear combinations of fu...</div><div class="ttdef"><b>Definition</b> OperationEvalCombinationGrid.hpp:23</div></div>
</div><!-- fragment --><p>We start an AdaptiveCombinationGridGenerator from the full grids that are already in the combiGrid we have now. This object is going to store the LevelVectors that are currently adapted and the QoI results we know about them, as well as QoIs of grids that are not currently adapted to yet. </p><div class="fragment"><div class="line">  <span class="comment">// default parameters are linear summation for the QoIs, AveragingPriorityEstimator, and</span></div>
<div class="line">  <span class="comment">// WeightedRelevanceCalculator</span></div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html">sgpp::combigrid::AdaptiveCombinationGridGenerator</a> adaptiveCombinationGridGenerator =</div>
<div class="line">      <a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a7222b3b26c07dc016f9a2fa29066cc8f">sgpp::combigrid::AdaptiveCombinationGridGenerator::fromCombinationGrid</a>(combiGrid);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// for each of the full grids, we calculate the value at point x and hand it to the generator</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> fullGridIndex = 0; fullGridIndex &lt; combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a7cf25bf88929f7d47b243b8865e379f3">getFullGrids</a>().size(); ++fullGridIndex) {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classsgpp_1_1combigrid_1_1FullGrid.html">sgpp::combigrid::FullGrid</a>&amp; fullGrid = combiGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a7cf25bf88929f7d47b243b8865e379f3">getFullGrids</a>()[fullGridIndex];</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="namespacesgpp_1_1combigrid.html#a5d2134ac1c4fbda63cf234522b27d5a5">sgpp::combigrid::LevelVector</a>&amp; l = fullGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1FullGrid.html#ad646af428f584d9e606eea8cd1041610">getLevel</a>();</div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalFullGrid.html">sgpp::combigrid::OperationEvalFullGrid</a> opEval(fullGrid);</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(surpluses[fullGridIndex], x);</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Value of full grid [&quot;</span> &lt;&lt; l[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; l[1] &lt;&lt; <span class="stringliteral">&quot;] interpolant at [&quot;</span> &lt;&lt; x[0]</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1] &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">      adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a9066a7db662b8c0d891e280f237fee57">setQoIInformation</a>(l, y);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// for (auto&amp; l : adaptiveCombinationGridGenerator.getLevels()) {</span></div>
<div class="line">  <span class="comment">//   std::cout &lt;&lt; l &lt;&lt; &quot;, &quot;;</span></div>
<div class="line">  <span class="comment">// }</span></div>
<div class="line">  <span class="comment">// std::cout &lt;&lt; std::endl;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// all of the full grids known so far should already be in the generator&#39;s &#39;old set&#39;, so this call</span></div>
<div class="line">  <span class="comment">// here would return false:</span></div>
<div class="line">  <span class="keywordtype">bool</span> adapted = adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a3555202b579cbdc42205447a01ee016a">adaptAllKnown</a>();</div>
<div class="line">  assert(!adapted);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// looking at the &#39;active set&#39;, we see which full grid spaces could potentially be interesting</span></div>
<div class="line">  <span class="comment">// next, they are the upper neighbors of the old set</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> activeSet = adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#aa1476e8bcdf02e3e2ad47cd6239b92f3">getActiveSet</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// we also get the values at x for those full grids and add the QoI information to the generator</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; levelVector : activeSet) {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classsgpp_1_1combigrid_1_1FullGrid.html">sgpp::combigrid::FullGrid</a> fullGrid{levelVector, basis, hasBoundary};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// to evaluate, we fill the full grid with values of f</span></div>
<div class="line">    <span class="comment">// TODO(pollinta) this feels like a really ugly way to evaluate a function on the grid</span></div>
<div class="line">    <span class="comment">// TODO(pollinta) I am happy about syntax suggestions to make this more readable</span></div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> fullGridValues(fullGrid.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1FullGrid.html#a5a66261bf909fae2507d5252da2b1544">getNumberOfIndexVectors</a>());</div>
<div class="line">    <span class="keyword">auto</span> range = <a class="code hl_class" href="classsgpp_1_1combigrid_1_1IndexVectorRange.html">sgpp::combigrid::IndexVectorRange</a>(fullGrid);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = range.begin(); it != range.end(); ++it) {</div>
<div class="line">      <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> z(dim);</div>
<div class="line">      it.getStandardCoordinates(z);</div>
<div class="line">      fullGridValues[it.getSequenceNumber()] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(z);</div>
<div class="line">      <span class="comment">// std::cout &lt;&lt; &quot;Value of full grid [&quot; &lt;&lt; levelVector[0] &lt;&lt; &quot; &quot; &lt;&lt; levelVector[1] &lt;&lt; &quot;] at [&quot;</span></div>
<div class="line">      <span class="comment">//           &lt;&lt; z[0] &lt;&lt; &quot; &quot; &lt;&lt; z[1] &lt;&lt; &quot;]: &quot; &lt;&lt; f(z) &lt;&lt; &quot;\n&quot;;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// like before, hierarchize the full grid to evaluate using the basis functions</span></div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a> opHierSingleGrid(</div>
<div class="line">        <a class="code hl_class" href="classsgpp_1_1combigrid_1_1CombinationGrid.html">sgpp::combigrid::CombinationGrid</a>(fullGrid), opPole);</div>
<div class="line">    <span class="keyword">auto</span> fullGridSurpluses = std::vector&lt;sgpp::base::DataVector&gt;(1, fullGridValues);</div>
<div class="line">    opHierSingleGrid.apply(fullGridSurpluses);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalFullGrid.html">sgpp::combigrid::OperationEvalFullGrid</a> opEval(fullGrid);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(fullGridSurpluses[0], x);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of new full grid [&quot;</span> &lt;&lt; levelVector[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; levelVector[1]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;] interpolant at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1] &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a9066a7db662b8c0d891e280f237fee57">setQoIInformation</a>(levelVector, y);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; l : adaptiveCombinationGridGenerator.getOldSet()) {</div>
<div class="line">    std::cout &lt;&lt; l &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// now, we can adapt some grids</span></div>
<div class="line">  adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a64bbfd15cc3ab354c32357cebb486ea5">adaptNextLevelVector</a>();</div>
<div class="line">  adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a64bbfd15cc3ab354c32357cebb486ea5">adaptNextLevelVector</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; l : adaptiveCombinationGridGenerator.getOldSet()) {</div>
<div class="line">    std::cout &lt;&lt; l &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// if the computation would become expensive, e.g. for higher resolutions, we could get a priority</span></div>
<div class="line">  <span class="comment">// estimate which levels should be calculated first</span></div>
<div class="line">  <span class="keyword">auto</span> priorityQueue = adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a2e9b5845aa0606eb5229f45645655ff7">getPriorityQueue</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// finally, we may adapt the generator to all calculated values</span></div>
<div class="line">  adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a3555202b579cbdc42205447a01ee016a">adaptAllKnown</a>();</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html">sgpp::combigrid::AdaptiveCombinationGridGenerator</a></div><div class="ttdoc">The AdaptiveCombinationGridGenerator is a (potentially changing) representation of a combination grid...</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.hpp:52</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a2e9b5845aa0606eb5229f45645655ff7"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a2e9b5845aa0606eb5229f45645655ff7">sgpp::combigrid::AdaptiveCombinationGridGenerator::getPriorityQueue</a></div><div class="ttdeci">std::vector&lt; LevelVector &gt; getPriorityQueue() const</div><div class="ttdoc">get a priority queue of elements in the active set that don't have a result / QoI / delta yet</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:229</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a3555202b579cbdc42205447a01ee016a"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a3555202b579cbdc42205447a01ee016a">sgpp::combigrid::AdaptiveCombinationGridGenerator::adaptAllKnown</a></div><div class="ttdeci">bool adaptAllKnown()</div><div class="ttdoc">add all subspaces of known result to the old set</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:116</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a64bbfd15cc3ab354c32357cebb486ea5"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a64bbfd15cc3ab354c32357cebb486ea5">sgpp::combigrid::AdaptiveCombinationGridGenerator::adaptNextLevelVector</a></div><div class="ttdeci">bool adaptNextLevelVector(bool regular=false)</div><div class="ttdoc">add the next most important subspace of known result to the old set</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:98</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a7222b3b26c07dc016f9a2fa29066cc8f"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a7222b3b26c07dc016f9a2fa29066cc8f">sgpp::combigrid::AdaptiveCombinationGridGenerator::fromCombinationGrid</a></div><div class="ttdeci">static AdaptiveCombinationGridGenerator fromCombinationGrid(const CombinationGrid &amp;combinationGrid, const std::vector&lt; double &gt; &amp;&amp;QoIValues, std::function&lt; double(double, double)&gt; summationFunction=std::plus&lt; double &gt;(), std::shared_ptr&lt; RelevanceCalculator &gt; relevanceCalculator=std::shared_ptr&lt; RelevanceCalculator &gt;(new WeightedRelevanceCalculator()), std::shared_ptr&lt; PriorityEstimator &gt; priorityEstimator=std::shared_ptr&lt; PriorityEstimator &gt;(new AveragingPriorityEstimator()))</div><div class="ttdoc">Construct a new AdaptiveCombinationGridGenerator object.</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:66</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a9066a7db662b8c0d891e280f237fee57"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a9066a7db662b8c0d891e280f237fee57">sgpp::combigrid::AdaptiveCombinationGridGenerator::setQoIInformation</a></div><div class="ttdeci">void setQoIInformation(const LevelVector &amp;level, double qoi)</div><div class="ttdoc">set QoI information / a result for LevelVector level</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.hpp:159</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_aa1476e8bcdf02e3e2ad47cd6239b92f3"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#aa1476e8bcdf02e3e2ad47cd6239b92f3">sgpp::combigrid::AdaptiveCombinationGridGenerator::getActiveSet</a></div><div class="ttdeci">std::vector&lt; LevelVector &gt; getActiveSet() const</div><div class="ttdoc">Get the level vectors of the active set (= admissible upward neighbors of the old set)</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:143</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1CombinationGrid_html_a7cf25bf88929f7d47b243b8865e379f3"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1CombinationGrid.html#a7cf25bf88929f7d47b243b8865e379f3">sgpp::combigrid::CombinationGrid::getFullGrids</a></div><div class="ttdeci">const std::vector&lt; FullGrid &gt; &amp; getFullGrids() const</div><div class="ttdef"><b>Definition</b> CombinationGrid.cpp:229</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1FullGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1FullGrid.html">sgpp::combigrid::FullGrid</a></div><div class="ttdoc">Full grid essentially represented by its level and a HeterogeneousBasis.</div><div class="ttdef"><b>Definition</b> FullGrid.hpp:22</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1FullGrid_html_a5a66261bf909fae2507d5252da2b1544"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1FullGrid.html#a5a66261bf909fae2507d5252da2b1544">sgpp::combigrid::FullGrid::getNumberOfIndexVectors</a></div><div class="ttdeci">index_t getNumberOfIndexVectors(size_t d) const</div><div class="ttdoc">Number of index vectors (grid points) in 1D.</div><div class="ttdef"><b>Definition</b> FullGrid.hpp:160</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1FullGrid_html_ad646af428f584d9e606eea8cd1041610"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1FullGrid.html#ad646af428f584d9e606eea8cd1041610">sgpp::combigrid::FullGrid::getLevel</a></div><div class="ttdeci">const LevelVector &amp; getLevel() const</div><div class="ttdef"><b>Definition</b> FullGrid.hpp:86</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1IndexVectorRange_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1IndexVectorRange.html">sgpp::combigrid::IndexVectorRange</a></div><div class="ttdoc">Class for iterating over the indices contained in a FullGrid via ranged-based for loops.</div><div class="ttdef"><b>Definition</b> IndexVectorRange.hpp:29</div></div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1OperationEvalFullGrid_html"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1OperationEvalFullGrid.html">sgpp::combigrid::OperationEvalFullGrid</a></div><div class="ttdoc">Operation for evaluating a full grid function (linear combination of full grid basis functions).</div><div class="ttdef"><b>Definition</b> OperationEvalFullGrid.hpp:20</div></div>
<div class="ttc" id="anamespacesgpp_1_1combigrid_html_a5d2134ac1c4fbda63cf234522b27d5a5"><div class="ttname"><a href="namespacesgpp_1_1combigrid.html#a5d2134ac1c4fbda63cf234522b27d5a5">sgpp::combigrid::LevelVector</a></div><div class="ttdeci">std::vector&lt; level_t &gt; LevelVector</div><div class="ttdoc">level multi-index</div><div class="ttdef"><b>Definition</b> LevelIndexTypes.hpp:20</div></div>
</div><!-- fragment --><p>Now, we can generate a new combination grid that contains all the subspaces / full grids that we have adapted to. We again interpolate the value at x and see whether it has become more accurate. </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> combiGridAdapted = adaptiveCombinationGridGenerator.<a class="code hl_function" href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a8aa8c2687e046a2cd0f213177f70e1b7">getCombinationGrid</a>(basis, hasBoundary);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// fill the combination grid with analytical values</span></div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1HashGridStorage.html">sgpp::base::HashGridStorage</a> gridStorageAdapted(dim);</div>
<div class="line">  combiGridAdapted.combinePoints(gridStorageAdapted);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> fAdapted(gridStorageAdapted.getSize());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; gridStorageAdapted.getSize(); k++) {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> z(dim);</div>
<div class="line">    gridStorageAdapted.getPoint(k).getStandardCoordinates(z);</div>
<div class="line">    fAdapted[k] = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(z);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// distribute the values to the full grids again and hierarchize</span></div>
<div class="line">  std::vector&lt;sgpp::base::DataVector&gt; valuesAdapted;</div>
<div class="line">  combiGridAdapted.distributeValuesToFullGrids(gridStorageAdapted, fAdapted, valuesAdapted);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;sgpp::base::DataVector&gt; surplusesAdapted(valuesAdapted);</div>
<div class="line">  <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationUPCombinationGrid.html">sgpp::combigrid::OperationUPCombinationGrid</a> opHierAdapted(combiGridAdapted, opPole);</div>
<div class="line">  opHierAdapted.apply(surplusesAdapted);</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_class" href="classsgpp_1_1combigrid_1_1OperationEvalCombinationGrid.html">sgpp::combigrid::OperationEvalCombinationGrid</a> opEval(combiGridAdapted);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = opEval.eval(surplusesAdapted, x);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value of combined sparse grid interpolant at [&quot;</span> &lt;&lt; x[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; x[1]</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;]: &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasssgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator_html_a8aa8c2687e046a2cd0f213177f70e1b7"><div class="ttname"><a href="classsgpp_1_1combigrid_1_1AdaptiveCombinationGridGenerator.html#a8aa8c2687e046a2cd0f213177f70e1b7">sgpp::combigrid::AdaptiveCombinationGridGenerator::getCombinationGrid</a></div><div class="ttdeci">CombinationGrid getCombinationGrid(const HeterogeneousBasis &amp;basis, bool hasBoundary=true) const</div><div class="ttdoc">Get the the currently valid combination grid consisting of the &quot;old set&quot; (the combination grid only h...</div><div class="ttdef"><b>Definition</b> AdaptiveCombinationGridGenerator.cpp:82</div></div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">Value of test function at [0.12 0.34]: 0.820974
Value of combined sparse grid interpolant at [0.12 0.34]: 0.774666
Value of full grid [4 0] interpolant at [0.12 0.34]: -0.489125
Value of full grid [3 1] interpolant at [0.12 0.34]: 0.564036
Value of full grid [2 2] interpolant at [0.12 0.34]: 0.670577
Value of full grid [1 3] interpolant at [0.12 0.34]: -0.0557937
Value of full grid [0 4] interpolant at [0.12 0.34]: 0.216
Value of full grid [3 0] interpolant at [0.12 0.34]: -0.487013
Value of full grid [2 1] interpolant at [0.12 0.34]: 0.458568
Value of full grid [1 2] interpolant at [0.12 0.34]: -0.0563141
Value of full grid [0 3] interpolant at [0.12 0.34]: 0.215787
Value of new full grid [5 0] interpolant at [0.12 0.34]: -0.488799
Value of new full grid [4 1] interpolant at [0.12 0.34]: 0.566482
Value of new full grid [3 2] interpolant at [0.12 0.34]: 0.824806
Value of new full grid [2 3] interpolant at [0.12 0.34]: 0.664381
Value of new full grid [1 4] interpolant at [0.12 0.34]: -0.0558487
Value of new full grid [0 5] interpolant at [0.12 0.34]: 0.216003
[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [0, 1], [1, 1], [2, 1], [3, 1], [0, 2], [1, 2], [2, 2], [0, 3], [1, 3], [0, 4], 
[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [0, 1], [1, 1], [2, 1], [3, 1], [0, 2], [1, 2], [2, 2], [0, 3], [1, 3], [0, 4], [3, 2], [2, 3], 
Value of combined sparse grid interpolant at [0.12 0.34]: 0.82133</pre><p>We see that the value of the adapted combined sparse grid interpolant at the evaluation point is even closer to the actual value of the test function than the smaller non-adapted combination grid we used in the last example. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_cpp.html">C++ Examples</a></li>
    <li class="footer">Generated on Mon Feb 24 2025 09:21:46 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
