/******************************************************************************
* Copyright (C) 2011 Technische Universitaet Muenchen                         *
* This file is part of the SG++ project. For conditions of distribution and   *
* use, please see the copyright notice at http://www5.in.tum.de/SGpp          *
******************************************************************************/
// @author Alexander Heinecke (Alexander.Heinecke@mytum.de)

double OCLKernels::multTransSPOCL(float* ptrSource, float* ptrData, float* ptrLevel, float* ptrIndex, float* ptrGlobalResult, size_t sourceSize, size_t storageSize, size_t dims, size_t gpu_partition)
{
	double time = 0.0;

	if (isFirstTimeMultTransSP)
	{
		std::stringstream stream_program_src;

		stream_program_src << "__kernel void multTransSPOCL(__global float* ptrSource," << std::endl;
		stream_program_src << "						__global float* ptrData," << std::endl;
		stream_program_src << "						__global float* ptrLevel," << std::endl;
		stream_program_src << "						__global float* ptrIndex," << std::endl;
		stream_program_src << "						__global float* ptrResult," << std::endl;
		stream_program_src << "						uint sourceSize," << std::endl;
		stream_program_src << "						uint offset)" << std::endl;
		stream_program_src << "{" << std::endl;
		stream_program_src << "	int globalIdx = get_global_id(0);" << std::endl;
		stream_program_src << "	int localIdx = get_local_id(0);" << std::endl;
		stream_program_src << "	globalIdx = globalIdx + offset;" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "	float eval, index_calc, abs, last, localSupport, curSupport;" << std::endl << std::endl;
		stream_program_src << "	float myResult = 0.0f;" << std::endl << std::endl;
		stream_program_src << "	__local float locData[" << dims*OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/2 << "];" << std::endl;
		stream_program_src << "	__local float locSource[" << OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/2 << "];" << std::endl << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "	float level_" << d << " = ptrLevel[(globalIdx*" << dims << ")+" << d << "];" << std::endl;
			stream_program_src << "	float index_" << d << " = ptrIndex[(globalIdx*" << dims << ")+" << d << "];" << std::endl;
		}
		stream_program_src << std::endl;
		stream_program_src << "	// Iterate over all grid points" << std::endl;
		stream_program_src << "	for(int i = 0; i < sourceSize; i+=" << OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/2 << ")" << std::endl;
		stream_program_src << "	{" << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "		locData[(localIdx*" << dims << ")+" << d << "] = ptrData[((i+localIdx)*" << dims << ")+" << d << "];" << std::endl;
		}
		stream_program_src << "		locSource[localIdx] = ptrSource[i+localIdx];" << std::endl;
		stream_program_src << "		barrier(CLK_LOCAL_MEM_FENCE);" << std::endl << std::endl;
		stream_program_src << "		for(int k = 0; k < " << OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/2 << "; k++)" << std::endl;
		stream_program_src << "		{" << std::endl;

		stream_program_src << "			curSupport = locSource[k];" << std::endl << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "			eval = ((level_" << d << ") * (locData[(k*" << dims << ")+" << d << "]));" << std::endl;
			stream_program_src << "			index_calc = eval - (index_" << d << ");" << std::endl;
			stream_program_src << "			abs = fabs(index_calc);" << std::endl;
			stream_program_src << "			last = 1.0f - abs;" << std::endl;
			stream_program_src << "			localSupport = fmax(last, 0.0f);" << std::endl;
			stream_program_src << "			curSupport *= localSupport;" << std::endl;
		}
		stream_program_src << std::endl << "		myResult += curSupport;" << std::endl;
		stream_program_src << "		}" << std::endl << std::endl;
		stream_program_src << "		barrier(CLK_LOCAL_MEM_FENCE);" << std::endl;
		stream_program_src << "	}" << std::endl;
		stream_program_src << "	ptrResult[globalIdx] = myResult;" << std::endl;
		stream_program_src << "}" << std::endl;

		std::string program_src = stream_program_src.str();

		//std::cout << program_src << std::endl;

	    // setting the program
	    const char* kernel_src = program_src.c_str();
	    program_multTransSP = clCreateProgramWithSource(context, 1, &kernel_src, NULL, &err);
	    if (err != CL_SUCCESS)
		{
	    	std::cout << "OCL Error: Failed to create program! Error Code: " << err << std::endl;
	    	return 0.0;
		}

	    // compiling the program
	    err = clBuildProgram(program_multTransSP, 0, NULL, "-cl-finite-math-only -cl-strict-aliasing -cl-fast-relaxed-math -cl-single-precision-constant", NULL, NULL);
	    //err = clBuildProgram(program_multTransSP, 0, NULL, "-cl-opt-disable", NULL, NULL);
	    //err = clBuildProgram(program_multTransSP, 0, NULL, NULL, NULL, NULL);
	    if (err != CL_SUCCESS)
	    {
	    	std::cout << "OCL Error: OpenCL Build Error. Error Code: " << err << std::endl;

	    	size_t len;
	    	char buffer[2048];

	    	// get the build log
	    	clGetProgramBuildInfo(program_multTransSP, device_ids[0], CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);

	    	std::cout << "--- Build Log ---" << std::endl << buffer << std::endl;
	    	return 0.0;
	    }

	    // creating the kernel
	    for (size_t i = 0; i < num_devices; i++)
	    {
			kernel_multTransSP[i] = clCreateKernel(program_multTransSP, "multTransSPOCL", &err);
			if (err != CL_SUCCESS)
			{
				std::cout << "OCL Error: Failed to create kernel! Error Code: " << err << std::endl;
				return 0.0;
			}
	    }
	}

	if (isFirstTimeMultSP && isFirstTimeMultTransSP)
	{
		for (size_t i = 0; i < num_devices; i++)
		{
			clLevelSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*storageSize, ptrLevel, NULL);
			clIndexSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*storageSize, ptrIndex, NULL);
		}
	}

	if (isVeryFirstTimeSP)
	{
		for (size_t i = 0; i < num_devices; i++)
		{
			clDataSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*sourceSize, ptrData, NULL);
		}
		isVeryFirstTimeSP = false;
	}

	cl_mem clSource[MAX_OCL_DEVICE_COUNT], clResult[MAX_OCL_DEVICE_COUNT];
	for (size_t i = 0; i < num_devices; i++)
	{
		clSource[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*sourceSize, ptrSource, NULL);
		clResult[i] = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(float)*gpu_partition, NULL, NULL);
	}

    cl_uint clSourceSize = (cl_uint)sourceSize;
    cl_uint clOffsets[MAX_OCL_DEVICE_COUNT];

    // determine best fit
	size_t numWGs = gpu_partition/OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP;
    size_t global = numWGs*(OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/num_devices);
    size_t local = OCL_MULT_N_DATAPREFETCH_BLOCKSIZE_SP/2;
    size_t offset = 0;

    // if there is not enough workload for GPUs
    if (global == 0)
    {
    	return 0.0;
    }

    // set kernel arguments
    for (size_t i = 0; i < num_devices; i++)
    {
    	clOffsets[i] = (cl_uint)offset;
		if ( clSetKernelArg(kernel_multTransSP[i], 0, sizeof(cl_mem), &clSource[i]) ||
				clSetKernelArg(kernel_multTransSP[i], 1, sizeof(cl_mem), &clDataSP[i]) ||
				clSetKernelArg(kernel_multTransSP[i], 2, sizeof(cl_mem), &clLevelSP[i]) ||
				clSetKernelArg(kernel_multTransSP[i], 3, sizeof(cl_mem), &clIndexSP[i]) ||
				clSetKernelArg(kernel_multTransSP[i], 4, sizeof(cl_mem), &clResult[i]) ||
				clSetKernelArg(kernel_multTransSP[i], 5, sizeof(cl_uint), &clSourceSize) ||
				clSetKernelArg(kernel_multTransSP[i], 6, sizeof(cl_uint), &clOffsets[i]) != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to create kernel Args for kernel " << i << "!" << std::endl;
			return 0.0;
		}

		offset += global;
    }

    cl_event clTimings[MAX_OCL_DEVICE_COUNT];
    cl_event GPUDone[MAX_OCL_DEVICE_COUNT];

    // enqueue kernels
    for (size_t i = 0; i < num_devices; i++)
    {
		err = clEnqueueNDRangeKernel(command_queue[i], kernel_multTransSP[i], 1, NULL, &global, &local, 0, NULL, &clTimings[i]);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to enqueue kernel command! Error Code: " << err << std::endl;
			return 0.0;
		}
    }

	// read data back
    offset = 0;
    for (size_t i = 0; i < num_devices; i++)
    {
    	err = clEnqueueReadBuffer(command_queue[i], clResult[i], CL_FALSE, sizeof(float)*offset, sizeof(float)*global, &ptrGlobalResult[offset], 0, NULL, &GPUDone[i]);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to enqueue read buffer command (mult)! Error Code: " << err << std::endl;
			return 0.0;
		}
		offset += global;
    }

    // sync GPUs
    clWaitForEvents(num_devices, GPUDone);

	// determine kernel execution time
    for (size_t i = 0; i < num_devices; i++)
	{
    	double tmpTime;
		cl_ulong startTime, endTime;
		err = clGetEventProfilingInfo(clTimings[i], CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &startTime, NULL);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to read start-time from command queue! Error Code: " << err << std::endl;
		}

		err = clGetEventProfilingInfo(clTimings[i], CL_PROFILING_COMMAND_END, sizeof(cl_ulong), &endTime, NULL);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to read end-time from command queue! Error Code: " << err << std::endl;
		}

		tmpTime = (double)(endTime - startTime);
		tmpTime *= 1e-9;

		if (tmpTime > time)
		{
			time = tmpTime;
		}
	}

    // clean up
    for (size_t i = 0; i < num_devices; i++)
    {
    	clReleaseMemObject(clSource[i]);
    	clReleaseMemObject(clResult[i]);
    }

    isFirstTimeMultTransSP = false;

	return time;
}

double OCLKernels::multSPOCL(float* ptrAlpha, float* ptrData, float* ptrLevel, float* ptrIndex, float* ptrResult, size_t result_size, size_t storageSize, size_t dims, size_t gpu_partition)
{
	double time = 0.0;

	if (isFirstTimeMultSP)
	{
		std::stringstream stream_program_src;

		stream_program_src << "__kernel void multSPOCL(__global float* ptrAlpha," << std::endl;
		stream_program_src << "						__global float* ptrData," << std::endl;
		stream_program_src << "						__global float* ptrLevel," << std::endl;
		stream_program_src << "						__global float* ptrIndex," << std::endl;
		stream_program_src << "						__global float* ptrResult," << std::endl;
		stream_program_src << "						uint fastStorageSize," << std::endl;
		stream_program_src << "						uint storageSize," << std::endl;
		stream_program_src << "						uint offset)" << std::endl;
		stream_program_src << "{" << std::endl;
		stream_program_src << "	int globalIdx = get_global_id(0);" << std::endl;
		stream_program_src << "	int localIdx = get_local_id(0);" << std::endl;
		stream_program_src << "	globalIdx = globalIdx + offset;" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "	__local float locLevel[" << dims * OCL_DATAPREFETCH_SIZE_SP << "];" << std::endl;
		stream_program_src << "	__local float locIndex[" << dims * OCL_DATAPREFETCH_SIZE_SP << "];" << std::endl;
		stream_program_src << "	__local float locAlpha[" << OCL_DATAPREFETCH_SIZE_SP << "];" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "	float eval, index_calc, abs, last, localSupport, curSupport;" << std::endl << std::endl;
		stream_program_src << "	float myResult = 0.0f;" << std::endl << std::endl;
		stream_program_src << "	// Create registers for the data" << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "	float data_" << d << " = ptrData[(globalIdx*" << dims << ")+" << d << "];" << std::endl;
		}
		stream_program_src << std::endl;
		stream_program_src << "	// Iterate over all grid points (fast ones, with cache)" << std::endl;
		stream_program_src << "	for(int j = 0; j < fastStorageSize; j+=" << OCL_DATAPREFETCH_SIZE_SP << ")" << std::endl;
		stream_program_src << "	{" << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "		locLevel[(localIdx*" << dims << ")+"<< d << "] = ptrLevel[((j+localIdx)*" << dims << ")+" << d << "];" << std::endl;
			stream_program_src << "		locIndex[(localIdx*" << dims << ")+"<< d << "] = ptrIndex[((j+localIdx)*" << dims << ")+" << d << "];" << std::endl;
		}
		stream_program_src << "		locAlpha[localIdx] = ptrAlpha[j+localIdx];" << std::endl;
		stream_program_src << "		barrier(CLK_LOCAL_MEM_FENCE);" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "		for(int k = 0; k < " << OCL_DATAPREFETCH_SIZE_SP << "; k++)" << std::endl;
		stream_program_src << "		{" << std::endl;
		stream_program_src << "			curSupport = locAlpha[k];" << std::endl << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "			eval = ((locLevel[(k*" << dims << ")+" << d << "]) * (data_" << d << "));" << std::endl;
			stream_program_src << "			index_calc = eval - (locIndex[(k*" << dims << ")+" << d << "]);" << std::endl;
			stream_program_src << "			abs = fabs(index_calc);" << std::endl;
			stream_program_src << "			last = 1.0f - abs;" << std::endl;
			stream_program_src << "			localSupport = fmax(last, 0.0f);" << std::endl;
			stream_program_src << "			curSupport *= localSupport;" << std::endl << std::endl;
		}
		stream_program_src << "			myResult += curSupport;" << std::endl;
		stream_program_src << "		}" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "		barrier(CLK_LOCAL_MEM_FENCE);" << std::endl;
		stream_program_src << "	}" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "	// Iterate over all grid points (slow ones, without cache)" << std::endl;
		stream_program_src << "	for(int m = fastStorageSize; m < storageSize; m++)" << std::endl;
		stream_program_src << "	{" << std::endl;
		stream_program_src << "		curSupport = ptrAlpha[m];" << std::endl << std::endl;
		for (size_t d = 0; d < dims; d++)
		{
			stream_program_src << "		eval = ((ptrLevel[(m*" << dims << ")+" << d << "]) * (data_" << d << "));" << std::endl;
			stream_program_src << "		index_calc = eval - (ptrIndex[(m*" << dims << ")+" << d << "]);" << std::endl;
			stream_program_src << "		abs = fabs(index_calc);" << std::endl;
			stream_program_src << "		last = 1.0f - abs;" << std::endl;
			stream_program_src << "		localSupport = fmax(last, 0.0f);" << std::endl;
			stream_program_src << "		curSupport *= localSupport;" << std::endl << std::endl;
		}
		stream_program_src << "		myResult += curSupport;" << std::endl;
		stream_program_src << "	}" << std::endl;
		stream_program_src << std::endl;
		stream_program_src << "	ptrResult[globalIdx] = myResult;" << std::endl;
		stream_program_src << "}" << std::endl;

		std::string program_src = stream_program_src.str();

		//std::cout << program_src << std::endl;

	    // setting the program
	    const char* kernel_src = program_src.c_str();
	    program_multSP = clCreateProgramWithSource(context, 1, &kernel_src, NULL, &err);
	    if (err != CL_SUCCESS)
		{
	    	std::cout << "OCL Error: Failed to create program! Error Code: " << err << std::endl;
	    	return 0.0;
		}

	    // compiling the program
	    err = clBuildProgram(program_multSP, 0, NULL,  "-cl-finite-math-only -cl-strict-aliasing -cl-fast-relaxed-math -cl-single-precision-constant", NULL, NULL);
	    //err = clBuildProgram(program_multSP, 0, NULL, "-cl-opt-disable", NULL, NULL);
	    //err = clBuildProgram(program_multSP, 0, NULL, NULL, NULL, NULL);
	    if (err != CL_SUCCESS)
	    {
	    	std::cout << "OCL Error: OpenCL Build Error. Error Code: " << err << std::endl;

	    	size_t len;
	    	char buffer[2048];

	    	// get the build log
	    	clGetProgramBuildInfo(program_multSP, device_ids[0], CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);

	    	std::cout << "--- Build Log ---" << std::endl << buffer << std::endl;
	    	return 0.0;
	    }

	    // creating the kernels
	    for (size_t i = 0; i < num_devices; i++)
	    {
			kernel_multSP[i] = clCreateKernel(program_multSP, "multSPOCL", &err);
			if (err != CL_SUCCESS)
			{
				std::cout << "OCL Error: Failed to create kernel! Error Code: " << err << std::endl;
				return 0.0;
			}
	    }
	}

	if (isFirstTimeMultSP && isFirstTimeMultTransSP)
	{
		for (size_t i = 0; i < num_devices; i++)
		{
			clLevelSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*storageSize, ptrLevel, NULL);
			clIndexSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*storageSize, ptrIndex, NULL);
		}
	}

	if (isVeryFirstTimeSP)
	{
		for (size_t i = 0; i < num_devices; i++)
		{
			clDataSP[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*dims*result_size, ptrData, NULL);
		}
		isVeryFirstTimeSP = false;
	}

	cl_mem clAlpha[MAX_OCL_DEVICE_COUNT], clResult[MAX_OCL_DEVICE_COUNT];

	for(size_t i = 0; i < num_devices; i++)
	{
		clAlpha[i] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*storageSize, ptrAlpha, NULL);
		clResult[i] = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(float)*gpu_partition, NULL, NULL);
	}

	size_t global = gpu_partition/num_devices;
    size_t local = OCL_DATAPREFETCH_SIZE_SP;
    size_t offset = 0;

	size_t oclStorageSize = storageSize/OCL_DATAPREFETCH_SIZE_SP;
    oclStorageSize *= OCL_DATAPREFETCH_SIZE_SP;

    cl_uint clFastStorageSize = (cl_uint)(oclStorageSize);
    cl_uint clStorageSize = (cl_uint)(storageSize);
    cl_uint clOffsets[MAX_OCL_DEVICE_COUNT];

    for (size_t i = 0; i < num_devices; i++)
    {
    	clOffsets[i] = (cl_uint)offset;
		// set kernel arguments
		if ( clSetKernelArg(kernel_multSP[i], 0, sizeof(cl_mem), &clAlpha[i]) ||
				clSetKernelArg(kernel_multSP[i], 1, sizeof(cl_mem), &clDataSP[i]) ||
				clSetKernelArg(kernel_multSP[i], 2, sizeof(cl_mem), &clLevelSP[i]) ||
				clSetKernelArg(kernel_multSP[i], 3, sizeof(cl_mem), &clIndexSP[i]) ||
				clSetKernelArg(kernel_multSP[i], 4, sizeof(cl_mem), &clResult[i]) ||
				clSetKernelArg(kernel_multSP[i], 5, sizeof(cl_uint), &clFastStorageSize) ||
				clSetKernelArg(kernel_multSP[i], 6, sizeof(cl_uint), &clStorageSize) ||
				clSetKernelArg(kernel_multSP[i], 7, sizeof(cl_uint), &clOffsets[i]) != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to create kernel Args!" << std::endl;
			return 0.0;
		}
		offset += global;
    }

    cl_event clTimings[MAX_OCL_DEVICE_COUNT];
    cl_event GPUDone[MAX_OCL_DEVICE_COUNT];

    // enqueue kernel
    for (size_t i = 0; i < num_devices; i++)
    {
		err = clEnqueueNDRangeKernel(command_queue[i], kernel_multSP[i], 1, NULL, &global, &local, 0, NULL, &(clTimings[i]));
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to enqueue kernel command! Error Code: " << err << std::endl;
			return 0.0;
		}
    }

    // read data back
    offset = 0;
    for (size_t i = 0; i < num_devices; i++)
    {
		err = clEnqueueReadBuffer(command_queue[i], clResult[i], CL_FALSE, sizeof(float)*offset, sizeof(float)*global, &(ptrResult[offset]), 0, NULL, &(GPUDone[i]));
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to enqueue read buffer command (multTrans)! Error Code: " << err << std::endl;
			return 0.0;
		}
		offset += global;
    }

    // sync GPUs
    clWaitForEvents(num_devices, GPUDone);

	// determine kernel execution time
    for (size_t i = 0; i < num_devices; i++)
	{
    	double tmpTime;
		cl_ulong startTime, endTime;
		err = clGetEventProfilingInfo(clTimings[i], CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &startTime, NULL);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to read start-time from command queue! Error Code: " << err << std::endl;
		}

		err = clGetEventProfilingInfo(clTimings[i], CL_PROFILING_COMMAND_END, sizeof(cl_ulong), &endTime, NULL);
		if (err != CL_SUCCESS)
		{
			std::cout << "OCL Error: Failed to read end-time from command queue! Error Code: " << err << std::endl;
		}

		tmpTime = (double)(endTime - startTime);
		tmpTime *= 1e-9;

		if (tmpTime > time)
		{
			time = tmpTime;
		}
	}

    // clean up
    for (size_t i = 0; i < num_devices; i++)
    {
    	clReleaseMemObject(clAlpha[i]);
    	clReleaseMemObject(clResult[i]);
    }

    isFirstTimeMultSP = false;

	return time;
}
