# Copyright (C) 2008-today The SG++ Project
# This file is part of the SG++ project. For conditions of distribution and
# use, please see the copyright notice provided with SG++ or at
# sgpp.sparsegrids.org

import os
import sys
import fnmatch

Import('env')
Import('BUILD_DIR')
Import('moduleName')
Import('headerSourceList')
Import('headerDestList')

env_parallel = env.Clone()
# can only build without mpi support, skip those files
# required define: -DUSE_MPI
# requires mpicxx
MPIOnlyFiles = [
    "MPICommunicator.cpp",
    "GlobalMPIComm.cpp",
    "ConjugateGradientsMPI.cpp",
    "BiCGStabMPI.cpp",
    "PoissonEquationSolverMPI.cpp",
    "HeatEquationSolverMPI.cpp",
    "BlackScholesSolverMPI.cpp",
    "OperationParabolicPDESolverSystemDirichletCombined.cpp",
    "DMSystemMatrixVectorizedIdentityMPI.cpp",
    "DMSystemMatrixSPVectorizedIdentityMPI.cpp",
    "DMSystemMatrixMPITypeFactory.cpp",
    "DMSystemMatrixSPMPITypeFactory.cpp",
    "PoissonEquationEllipticPDESolverSystemDirichletParallelMPI.cpp",
    "PoissonEquationEllipticPDESolverSystemDirichletVectorizedMPI.cpp",
    "HeatEquationParabolicPDESolverSystemParallelMPI.cpp",
    "HeatEquationParabolicPDESolverSystemVectorizedMPI.cpp",
    "BlackScholesParabolicPDESolverSystemEuroAmerParallelMPI.cpp",
    "BlackScholesPATParabolicPDESolverSystemEuroAmerParallelMPI.cpp",
    "BlackScholesPATParabolicPDESolverSystemEuroAmerVectorizedMPI.cpp",
    "OperationLaplaceVectorizedLinear.cpp",
    "OperationLaplaceVectorizedLinearBoundary.cpp",
    "OperationLTwoDotProductVectorizedLinear.cpp",
    "OperationLTwoDotProductVectorizedLinearBoundary.cpp",
    "OperationLTwoDotLaplaceVectorizedLinear.cpp",
    "OperationLTwoDotLaplaceVectorizedLinearBoundary.cpp",
    ]
  
# Nvidia OpenCL: -I$(OCLINCLUDE) -DUSEOCL -DUSEOCL_NVIDIA -fopenmp
# Intel OpenCL CPU: -I$(IOCLINCLUDE) -DUSEOCL -DUSEOCL_INTEL -fopenmp -DUSEOCL_CPU
# Intel OpenCL GPU: -I$(IOCLINCLUDE) -DUSEOCL -DUSEOCL_INTEL -fopenmp
# Intel OpenCL MIC: -I$(IOCLINCLUDE) -DUSEOCL -DUSEOCL_INTEL -DUSEOCL_MIC
# AMD OpenCL GPU: -I$(AMDOCLINCLUDE) -DUSEOCL -DUSEOCL_AMD -fopenmp
# Linkflags (for Intel MIC without -fopenmp): -L$(OCLLIB) -lOpenCL -fopenmp
OCLOnlyFiles = [
    "OCLKernelImplBase.cpp",
    "OCLMPILTwoDotLaplaceInnerExec.cpp",
    "OCLMPILTwoDotLaplaceBoundExec.cpp",
    "OCLMPILaplaceInnerExec.cpp",
    "OCLMPILaplaceBoundExec.cpp",
    "OCLMPILTwoDotInnerExec.cpp",
    "OCLMPILTwoDotBoundExec.cpp",
    "OCLPDEKernels.cpp",
    "OCLPDEInner.cpp",
    "OCLPDEBound.cpp",
    "OCLLaplaceInner.cpp",
    "OCLLaplaceBound.cpp",
    "OCLLTwoDotInner.cpp",
    "OCLLTwoDotLaplaceInner.cpp",
    "OCLLTwoDotLaplaceBound.cpp",
    "OCLLTwoDotBound.cpp",
    "OperationLaplaceVectorizedLinearOCL.cpp",
    "OperationLaplaceVectorizedLinearBoundaryOCL.cpp",
    "OperationLTwoDotLaplaceVectorizedLinearOCL.cpp",
    "OperationLTwoDotLaplaceVectorizedLinearBoundaryOCL.cpp",
    "OperationLTwoDotProductVectorizedLinearBoundaryOCL.cpp",
    "OperationLTwoDotProductVectorizedLinearOCL.cpp"
]

#-I$(ARBBINCLUDE) -DUSEARBB
#-L$(ARBBLIB) -larbb -ltbb
ArBBOnlyFiles = [
    "OperationMultipleEvalIterativeArBBLinear.cpp",
    "OperationMultipleEvalIterativeSPArBBLinear.cpp",
    "OperationMultipleEvalIterativeArBBModLinear.cpp",
    "OperationMultipleEvalIterativeSPArBBModLinear.cpp",
    "ArBBKernels.cpp",
    "ArBBKernels2D.cpp",
    "ArBBKernels4D.cpp",
    "ArBBKernels5D.cpp",
    "ArBBKernels10D.cpp"
]

MICOnlyFiles = [
    "MICKernelImpl.cpp",
    "SPMICKernelImpl.cpp"
]

moduleDependencies = ['sgppdatadriven', 'sgpppde', 'sgppsolver', 'sgppbase']
Export('moduleDependencies')

if env['COMPILER'] == 'vcc':
    sys.stderr.write("Error: The parallel package is not supported on MSVC++.\n")
    sys.exit(1)

libname = "sgpp%s" % moduleName
if env['USE_STATICLIB']:
    libname += "static"
    for i, _ in enumerate(moduleDependencies):
        moduleDependencies[i] = "%sstatic" % moduleDependencies[i]
Export('libname')
srcs = []
for currentFolder, subdirNames, fileNames in os.walk("."):
    if currentFolder.startswith(os.path.join(".", "src", "sgpp", "parallel", "exampleApplication")):
        continue #  ignore exampleApplication from build
    if currentFolder.startswith(os.path.join(".", "src")):
        for fileName in fnmatch.filter(fileNames, '*.cpp'):
            #if fileName in MPIOnlyFiles:
            #     continue
            if fileName in OCLOnlyFiles:
                 continue
            if fileName in ArBBOnlyFiles:
                 continue
            srcs.append(os.path.join(currentFolder, fileName))
    if currentFolder != 'src':
      for fileName in fnmatch.filter(fileNames, '*.hpp'):
        headerSourceList.append(os.path.join(moduleName, currentFolder, fileName))
        headerDestList.append(os.path.join(currentFolder, fileName).split(os.sep,1)[1])

objs = []
for sourceFile in srcs:
    objs.append(env_parallel.SharedObject(sourceFile))

if env['USE_STATICLIB']:
    libsuffix = env['LIBSUFFIX']
    lib = env.StaticLibrary(target=libname,
                            source=objs,
                            LIBS=moduleDependencies)
else:
    libsuffix = env['SHLIBSUFFIX']
    lib = env.SharedLibrary(target=libname,
                            source=objs,
                            LIBPATH=BUILD_DIR,
                            LIBS=moduleDependencies)

for lib_str in moduleDependencies:
    if lib_str.startswith("sgpp"):
        env.Depends(lib, os.path.join("#", BUILD_DIR.path,
                                      "%s%s%s" % (env["LIBPREFIX"],
                                                  lib_str,
                                                  libsuffix)))

libInstall = env_parallel.Install(BUILD_DIR, lib)

if not env['NO_UNIT_TESTS'] and env['SG_PYTHON']:
  Import('testTargetList')
  py_test_env = env.Clone()
  moduleTest = py_test_env.Test(os.path.join('tests', 'test_%s.py' % moduleName))
  testTargetList.append(moduleTest)

Import('exampleTargetList')
for fileName in os.listdir("examples"):
    if fnmatch.fnmatch(fileName, "*.cpp"):
        example = env.Program(source=os.path.join("examples", fileName),
                              LIBPATH=BUILD_DIR,
                              LIBS=[libname] + moduleDependencies)
        env.Requires(example, libInstall)
        exampleTargetList.append(example)

Import('libraryTargetList')
Import('installTargetList')
libraryTargetList.append(lib)
installTargetList.append(libInstall)
