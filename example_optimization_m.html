<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: Optimization Example (MATLAB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_optimization_m.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Optimization Example (MATLAB)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>On this page, we look at an example application of the <a class="el" href="namespacesgpp_1_1optimization.html">sgpp::optimization</a> module.</p>
<p>Versions of the example are given in all languages currently supported by SG++: C++, Python, Java, and MATLAB.</p>
<p>Note that the MATLAB example differs from the other languages as we do not optimize a custom objective function, but a built-in one. This is because the director feature in SWIG-matlab is still buggy. (In theory, it is possible to define a custom MATLAB class derived from sgpp.OptScalarFunction, but some SG++ functions then crash with "Cannot call SwigStorage".)</p>
<p>The example interpolates a bivariate test function with B-splines instead of piecewise linear basis functions to obtain a smoother interpolant. The resulting sparse grid function is then minimized with the method of steepest descent. For comparison, we also minimize the objective function with Nelder-Mead's method.</p>
<p>For this example to work, some extra steps are necessary. In the following, we assume that we want to run the example on Linux.</p>
<p>Please note that in order to get <a class="el" href="namespacesgpp_1_1optimization.html">sgpp::optimization</a> to work with MATLAB, you have to disable support for Armadillo and UMFPACK when compiling SG++, i.e. set USE_ARMADILLO and USE_UMFPACK to "no". This is due to incompatible BLAS and LAPACK libraries of Armadillo/UMFPACK and MATLAB (MATLAB uses instead MKL versions of LAPACK and BLAS with different pointer sizes of 64 bits). You can somehow override MATLAB's choice of libraries with the environmental variables BLAS_VERSION and LAPACK_VERSION, but this is strongly discouraged as MATLAB itself may produce unexpected wrong results (e.g., <code>det [1 2; 3 4] = 2</code>). Static linking to Armadillo and UMFPACK would be a possible solution to circumvent this problem.</p>
<p>Now, you should be able to run the MATLAB example, which we describe in the rest of this page. </p>
<p>At the beginning of the program, we disable OpenMP within matsgpp since it interferes with SWIG's director feature. </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.omp_set_num_threads(1);</div>
<div class="line"> </div>
<div class="line">fprintf(<span class="stringliteral">&#39;sgpp::optimization example program started.\n\n&#39;</span>);</div>
<div class="line">% increase output verbosity</div>
<div class="line">printer = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Printer.getInstance();</div>
<div class="line">printer.setVerbosity(2);</div>
<div class="line">printLine = @() fprintf([repmat(<span class="charliteral">&#39;-&#39;</span>, 1, 80) <span class="charliteral">&#39;\n&#39;</span>]);</div>
<div class="ttc" id="anamespacesgpp_html"><div class="ttname"><a href="namespacesgpp.html">sgpp</a></div><div class="ttdoc">Class that stores, generates and manipulates a density function during online phase in on/off learnin...</div><div class="ttdef"><b>Definition</b> AlgorithmDGEMV.hpp:22</div></div>
</div><!-- fragment --><p>Here, we define some parameters: objective function, dimensionality, B-spline degree, maximal number of grid points, and adaptivity. </p><div class="fragment"><div class="line">% objective <span class="keyword">function</span></div>
<div class="line"><a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a> = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptHimmelblauObjective();</div>
<div class="line">% dimension of domain</div>
<div class="line">d = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>.getNumberOfParameters();</div>
<div class="line">% B-spline degree</div>
<div class="line">p = 3;</div>
<div class="line">% maximal number of <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> points</div>
<div class="line">N = 30;</div>
<div class="line">% adaptivity of <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> generation</div>
<div class="line">gamma = 0.95;</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
</div><!-- fragment --><p>First, we define a grid with modified B-spline basis functions and an iterative grid generator, which can generate the grid adaptively. </p><div class="fragment"><div class="line"><a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Grid.createModBsplineGrid(d, p);</div>
<div class="line">gridGen = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptIterativeGridGeneratorRitterNovak(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>, <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, N, gamma);</div>
</div><!-- fragment --><p>With the iterative grid generator, we generate adaptively a sparse grid. </p><div class="fragment"><div class="line">printLine();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;Generating grid...\n\n&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ~gridGen.generate()</div>
<div class="line">    error(<span class="stringliteral">&#39;Grid generation failed, exiting.&#39;</span>);</div>
<div class="line">end</div>
</div><!-- fragment --><p>Then, we hierarchize the function values to get hierarchical B-spline coefficients of the B-spline sparse grid interpolant \(\tilde{f}\colon [0, 1]^d \to \mathbb{R}\). </p><div class="fragment"><div class="line">printLine();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;Hierarchizing...\n\n&#39;</span>);</div>
<div class="line">functionValues = gridGen.getFunctionValues();</div>
<div class="line">coeffs = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(functionValues.getSize());</div>
<div class="line">hierSLE = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.HierarchisationSLE(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>);</div>
<div class="line">%sleSolver = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.AutoSLESolver();</div>
<div class="line">sleSolver = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Eigen();</div>
<div class="line"> </div>
<div class="line">% solve linear system</div>
<div class="line"><span class="keywordflow">if</span> ~sleSolver.solve(hierSLE, functionValues, coeffs)</div>
<div class="line">    error(<span class="stringliteral">&#39;Solving failed, exiting.&#39;</span>);</div>
<div class="line">end</div>
</div><!-- fragment --><p>We define the interpolant \(\tilde{f}\) and its gradient \(\nabla\tilde{f}\) for use with the gradient method (steepest descent). Of course, one can also use other optimization algorithms from <a class="el" href="namespacesgpp_1_1optimization_1_1optimizer.html">sgpp::optimization::optimizer</a>. </p><div class="fragment"><div class="line">printLine();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;Optimizing smooth interpolant...\n\n&#39;</span>);</div>
<div class="line">ft = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.InterpolantScalarFunction(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, coeffs);</div>
<div class="line">ftGradient = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.InterpolantScalarFunctionGradient(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>, coeffs);</div>
<div class="line">gradientDescent = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptGradientDescent(ft, ftGradient);</div>
<div class="line">x0 = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(d);</div>
</div><!-- fragment --><p>The gradient method needs a starting point. We use a point of our adaptively generated sparse grid as starting point. More specifically, we use the point with the smallest (most promising) function value and save it in x0. </p><div class="fragment"><div class="line">gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>.getStorage();</div>
<div class="line"> </div>
<div class="line">% index of <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> point with minimal <span class="keyword">function</span> value</div>
<div class="line">x0Index = 0;</div>
<div class="line">fX0 = functionValues.get(0);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> i = 1:functionValues.getSize()-1</div>
<div class="line">    if functionValues.get(i) &lt; fX0</div>
<div class="line">        fX0 = functionValues.get(i);</div>
<div class="line">        x0Index = i;</div>
<div class="line">    end</div>
<div class="line">end</div>
<div class="line"> </div>
<div class="line">x0 = gridStorage.getCoordinates(gridStorage.getPoint(x0Index));</div>
<div class="line">ftX0 = ft.eval(x0);</div>
<div class="line"> </div>
<div class="line">fprintf([<span class="stringliteral">&#39;x0 = &#39;</span> <span class="keywordtype">char</span>(x0.toString()) <span class="charliteral">&#39;\n&#39;</span>]);</div>
<div class="line">fprintf([<span class="stringliteral">&#39;f(x0) = &#39;</span> num2str(fX0, 6) <span class="stringliteral">&#39;, ft(x0) = &#39;</span> num2str(ftX0, 6) <span class="stringliteral">&#39;\n\n&#39;</span>]);</div>
</div><!-- fragment --><p>We apply the gradient method and print the results. </p><div class="fragment"><div class="line">gradientDescent.setStartingPoint(x0);</div>
<div class="line">gradientDescent.optimize();</div>
<div class="line">xOpt = gradientDescent.getOptimalPoint();</div>
<div class="line">ftXOpt = gradientDescent.getOptimalValue();</div>
<div class="line">fXOpt = <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>.eval(xOpt);</div>
<div class="line"> </div>
<div class="line">fprintf([<span class="stringliteral">&#39;\nxOpt = &#39;</span> <span class="keywordtype">char</span>(xOpt.toString()) <span class="charliteral">&#39;\n&#39;</span>]);</div>
<div class="line">fprintf([<span class="stringliteral">&#39;f(xOpt) = &#39;</span> num2str(fXOpt, 6) ...</div>
<div class="line">         <span class="stringliteral">&#39;, ft(xOpt) = &#39;</span> num2str(ftXOpt, 6) <span class="stringliteral">&#39;\n\n&#39;</span>]);</div>
</div><!-- fragment --><p>For comparison, we apply the classical gradient-free Nelder-Mead method directly to the objective function \(f\). </p><div class="fragment"><div class="line">printLine();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;Optimizing objective function (for comparison)...\n\n&#39;</span>);</div>
<div class="line"> </div>
<div class="line">nelderMead = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.OptNelderMead(<a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>, 1000);</div>
<div class="line">nelderMead.optimize();</div>
<div class="line">xOptNM = nelderMead.getOptimalPoint();</div>
<div class="line">fXOptNM = nelderMead.getOptimalValue();</div>
<div class="line">ftXOptNM = ft.eval(xOptNM);</div>
<div class="line"> </div>
<div class="line">fprintf([<span class="stringliteral">&#39;\nxOptNM = &#39;</span> <span class="keywordtype">char</span>(xOptNM.toString()) <span class="charliteral">&#39;\n&#39;</span>]);</div>
<div class="line">fprintf([<span class="stringliteral">&#39;f(xOptNM) = &#39;</span> num2str(fXOptNM, 6) ...</div>
<div class="line">         <span class="stringliteral">&#39;, ft(xOptNM) = &#39;</span> num2str(ftXOptNM, 6) <span class="stringliteral">&#39;\n\n&#39;</span>]);</div>
<div class="line"> </div>
<div class="line">printLine();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;\nsgpp::optimization example program terminated.\n&#39;</span>);</div>
</div><!-- fragment --><p>The example program outputs the following results: </p><pre class="fragment">sgpp::optimization example program started.

--------------------------------------------------------------------------------
Generating grid...

    Adaptive grid generation (Ritter-Novak)...
        100.0% (N = 29, k = 3)
    Done in 0ms.
--------------------------------------------------------------------------------
Hierarchizing...

    Solving linear system (automatic method)...
        Solving linear system (Gaussian elimination)...
        Done in 0ms.
    Done in 0ms.
--------------------------------------------------------------------------------
Optimizing smooth interpolant...

x0 = [7.50000000000000000000e-01, 7.50000000000000000000e-01]
f(x0) = 8.125, ft(x0) = 8.125

    Optimizing (gradient descent)...
        108 evaluations, x = [8.05312073972314856896e-01, 6.98251390596593024540e-01], f(x) = -2.784842
    Done in 0ms.

xOpt = [8.05312073972314856896e-01, 6.98251390596593024540e-01]
f(xOpt) = 0.0927254, ft(xOpt) = -2.78484

--------------------------------------------------------------------------------
Optimizing objective function (for comparison)...

    Optimizing (Nelder-Mead)...
        309 steps, f(x) = 0.000000
    Done in 0ms.

xOptNM = [8.00000000000000044409e-01, 6.99999999999999955591e-01]
f(xOptNM) = 0, ft(xOptNM) = -2.64809

--------------------------------------------------------------------------------

sgpp::optimization example program terminated.
</pre><p>We see that both the gradient-based optimization of the smooth sparse grid interpolant and the gradient-free optimization of the objective function find reasonable approximations of one of the four global minima ( \((0.8, 0.7)\)). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_m.html">MATLAB Examples</a></li>
    <li class="footer">Generated on Mon Feb 24 2025 09:29:11 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
