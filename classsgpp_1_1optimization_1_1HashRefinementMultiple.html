<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: sgpp::optimization::HashRefinementMultiple Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsgpp_1_1optimization_1_1HashRefinementMultiple.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsgpp_1_1optimization_1_1HashRefinementMultiple-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sgpp::optimization::HashRefinementMultiple Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Descendant of <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html" title="Free refinement class for sparse grids.">base::HashRefinement</a> refining without the generation of hierarchical ancestors.  
 <a href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html#details">More...</a></p>

<p><code>#include &lt;HashRefinementMultiple.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sgpp::optimization::HashRefinementMultiple:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsgpp_1_1optimization_1_1HashRefinementMultiple.png" usemap="#sgpp::optimization::HashRefinementMultiple_map" alt=""/>
  <map id="sgpp::optimization::HashRefinementMultiple_map" name="sgpp::optimization::HashRefinementMultiple_map">
<area href="classsgpp_1_1base_1_1HashRefinement.html" title="Free refinement class for sparse grids." alt="sgpp::base::HashRefinement" shape="rect" coords="0,56,251,80"/>
<area href="classsgpp_1_1base_1_1AbstractRefinement.html" title="Abstract refinement class for sparse grids." alt="sgpp::base::AbstractRefinement" shape="rect" coords="0,0,251,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa21a8e18bb916a88fa98cfd0f07260fa" id="r_aa21a8e18bb916a88fa98cfd0f07260fa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html#aa21a8e18bb916a88fa98cfd0f07260fa">getNumberOfRefinablePoints</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;storage) override</td></tr>
<tr class="memdesc:aa21a8e18bb916a88fa98cfd0f07260fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of refineable points, e.g.  <br /></td></tr>
<tr class="separator:aa21a8e18bb916a88fa98cfd0f07260fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2ecf86fff5219d874a97dcbfaf289c" id="r_a8c2ecf86fff5219d874a97dcbfaf289c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html#a8c2ecf86fff5219d874a97dcbfaf289c">refineGridpoint1D</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;storage, <a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">base::GridPoint</a> &amp;point, size_t t) override</td></tr>
<tr class="memdesc:a8c2ecf86fff5219d874a97dcbfaf289c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid point in one dimension.  <br /></td></tr>
<tr class="separator:a8c2ecf86fff5219d874a97dcbfaf289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsgpp_1_1base_1_1HashRefinement"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsgpp_1_1base_1_1HashRefinement')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html">sgpp::base::HashRefinement</a></td></tr>
<tr class="memitem:afec45d86b982cd66af4be1ab2d6072ff inherit pub_methods_classsgpp_1_1base_1_1HashRefinement" id="r_afec45d86b982cd66af4be1ab2d6072ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#afec45d86b982cd66af4be1ab2d6072ff">free_refine</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html">RefinementFunctor</a> &amp;functor, std::vector&lt; size_t &gt; *addedPoints=nullptr) override</td></tr>
<tr class="memdesc:afec45d86b982cd66af4be1ab2d6072ff inherit pub_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid according to a <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html" title="Abstract class that defines the interface that refinement functors have to provide.">RefinementFunctor</a> provided.  <br /></td></tr>
<tr class="separator:afec45d86b982cd66af4be1ab2d6072ff inherit pub_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2fb8d36f004774bb91b6da898b964 inherit pub_methods_classsgpp_1_1base_1_1HashRefinement" id="r_abba2fb8d36f004774bb91b6da898b964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#abba2fb8d36f004774bb91b6da898b964">refineGridpoint1D</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, size_t seq, size_t d) override</td></tr>
<tr class="memdesc:abba2fb8d36f004774bb91b6da898b964 inherit pub_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine one grid point along a single direction.  <br /></td></tr>
<tr class="separator:abba2fb8d36f004774bb91b6da898b964 inherit pub_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeea5daa612c1722d9a5ba7dc06f5ec inherit pub_methods_classsgpp_1_1base_1_1HashRefinement" id="r_aafeea5daa612c1722d9a5ba7dc06f5ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#aafeea5daa612c1722d9a5ba7dc06f5ec">~HashRefinement</a> () override</td></tr>
<tr class="separator:aafeea5daa612c1722d9a5ba7dc06f5ec inherit pub_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsgpp_1_1base_1_1AbstractRefinement')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html">sgpp::base::AbstractRefinement</a></td></tr>
<tr class="memitem:a6fe8bd9d8fa783be4da4e94b25a07f8e inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_a6fe8bd9d8fa783be4da4e94b25a07f8e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a6fe8bd9d8fa783be4da4e94b25a07f8e">getIndexOfMin</a> (<a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html#a304be3501a7ed2d99547271f5340f8ec">RefinementFunctor::value_type</a> *array, size_t length)</td></tr>
<tr class="memdesc:a6fe8bd9d8fa783be4da4e94b25a07f8e inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first occurrence of minimal element in array.  <br /></td></tr>
<tr class="separator:a6fe8bd9d8fa783be4da4e94b25a07f8e inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d52d0b39360fffcc302c5a3606c829 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_a76d52d0b39360fffcc302c5a3606c829"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a76d52d0b39360fffcc302c5a3606c829">isRefinable</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">GridPoint</a> &amp;point)</td></tr>
<tr class="memdesc:a76d52d0b39360fffcc302c5a3606c829 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the grid point is refinable.  <br /></td></tr>
<tr class="separator:a76d52d0b39360fffcc302c5a3606c829 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7e70c11df081faee0522332f876f69 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_a2d7e70c11df081faee0522332f876f69"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a2d7e70c11df081faee0522332f876f69">~AbstractRefinement</a> ()</td></tr>
<tr class="memdesc:a2d7e70c11df081faee0522332f876f69 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a2d7e70c11df081faee0522332f876f69 inherit pub_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9a74994df16f315a0e31eb38f80a31f4" id="r_a9a74994df16f315a0e31eb38f80a31f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html#a9a74994df16f315a0e31eb38f80a31f4">collectRefinablePoints</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;storage, <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html">base::RefinementFunctor</a> &amp;functor, <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#acc5b29d5726ed866e6fca398f4baf104">base::AbstractRefinement::refinement_container_type</a> &amp;collection) override</td></tr>
<tr class="memdesc:a9a74994df16f315a0e31eb38f80a31f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine the grid points and stores the indices those that can be refined and have maximal indicator values.  <br /></td></tr>
<tr class="separator:a9a74994df16f315a0e31eb38f80a31f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsgpp_1_1base_1_1HashRefinement"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsgpp_1_1base_1_1HashRefinement')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html">sgpp::base::HashRefinement</a></td></tr>
<tr class="memitem:a86048f1c85489a20315f9e00182c6aab inherit pro_methods_classsgpp_1_1base_1_1HashRefinement" id="r_a86048f1c85489a20315f9e00182c6aab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a86048f1c85489a20315f9e00182c6aab">addElementToCollection</a> (const <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#adb0e7837fa124a00ac920cda67f7b975">GridStorage::grid_map_iterator</a> &amp;iter, <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#accbe4a943a6f7db9cd6916aa2a333508">AbstractRefinement::refinement_list_type</a> current_value_list, size_t refinements_num, <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#acc5b29d5726ed866e6fca398f4baf104">AbstractRefinement::refinement_container_type</a> &amp;collection)</td></tr>
<tr class="memdesc:a86048f1c85489a20315f9e00182c6aab inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements to the collection.  <br /></td></tr>
<tr class="separator:a86048f1c85489a20315f9e00182c6aab inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f59c8994044b294bb1b5ed0980c882c inherit pro_methods_classsgpp_1_1base_1_1HashRefinement" id="r_a2f59c8994044b294bb1b5ed0980c882c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a2f59c8994044b294bb1b5ed0980c882c">createGridpoint</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">GridPoint</a> &amp;point) override</td></tr>
<tr class="memdesc:a2f59c8994044b294bb1b5ed0980c882c inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a new point on the grid.  <br /></td></tr>
<tr class="separator:a2f59c8994044b294bb1b5ed0980c882c inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659fd43ed26f12da3075d713cd44fa5 inherit pro_methods_classsgpp_1_1base_1_1HashRefinement" id="r_a3659fd43ed26f12da3075d713cd44fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#accbe4a943a6f7db9cd6916aa2a333508">AbstractRefinement::refinement_list_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a3659fd43ed26f12da3075d713cd44fa5">getIndicator</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, const <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#adb0e7837fa124a00ac920cda67f7b975">GridStorage::grid_map_iterator</a> &amp;iter, const <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html">RefinementFunctor</a> &amp;functor) const override</td></tr>
<tr class="memdesc:a3659fd43ed26f12da3075d713cd44fa5 inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list with indicator elements.  <br /></td></tr>
<tr class="separator:a3659fd43ed26f12da3075d713cd44fa5 inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9c063cf0edc856cb5cba4a1652e6e inherit pro_methods_classsgpp_1_1base_1_1HashRefinement" id="r_ae1d9c063cf0edc856cb5cba4a1652e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#ae1d9c063cf0edc856cb5cba4a1652e6e">refineGridpoint</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, size_t refine_index) override</td></tr>
<tr class="memdesc:ae1d9c063cf0edc856cb5cba4a1652e6e inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method refines a grid point by generating the children in every dimension of the grid and all their missing ancestors by calling create_gridpoint().  <br /></td></tr>
<tr class="separator:ae1d9c063cf0edc856cb5cba4a1652e6e inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5b5aad66e3f4dead0688ad4d72d49d inherit pro_methods_classsgpp_1_1base_1_1HashRefinement" id="r_abe5b5aad66e3f4dead0688ad4d72d49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#abe5b5aad66e3f4dead0688ad4d72d49d">refineGridpointsCollection</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html">RefinementFunctor</a> &amp;functor, <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#acc5b29d5726ed866e6fca398f4baf104">AbstractRefinement::refinement_container_type</a> &amp;collection) override</td></tr>
<tr class="memdesc:abe5b5aad66e3f4dead0688ad4d72d49d inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the grid adding elements defined in collection.  <br /></td></tr>
<tr class="separator:abe5b5aad66e3f4dead0688ad4d72d49d inherit pro_methods_classsgpp_1_1base_1_1HashRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classsgpp_1_1base_1_1AbstractRefinement"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsgpp_1_1base_1_1AbstractRefinement')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html">sgpp::base::AbstractRefinement</a></td></tr>
<tr class="memitem:ad86b0febe9733acd807a255617676793 inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_ad86b0febe9733acd807a255617676793"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#ad86b0febe9733acd807a255617676793">createGridpoint1D</a> (<a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">GridPoint</a> &amp;point, size_t d, <a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="namespacesgpp_1_1base.html#a2dd1df606f8b82c63f2d1397483ef783">index_t</a> &amp;source_index, <a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">level_t</a> &amp;source_level)</td></tr>
<tr class="memdesc:ad86b0febe9733acd807a255617676793 inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates children grid points along single direction.  <br /></td></tr>
<tr class="separator:ad86b0febe9733acd807a255617676793 inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5121042f6e931e4bcb53c436f7631a4f inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_a5121042f6e931e4bcb53c436f7631a4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a5121042f6e931e4bcb53c436f7631a4f">createGridpointSubroutine</a> (<a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">GridStorage</a> &amp;storage, <a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">GridPoint</a> &amp;point)</td></tr>
<tr class="memdesc:a5121042f6e931e4bcb53c436f7631a4f inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subroutine for grid point creation.  <br /></td></tr>
<tr class="separator:a5121042f6e931e4bcb53c436f7631a4f inherit pro_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classsgpp_1_1base_1_1AbstractRefinement')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html">sgpp::base::AbstractRefinement</a></td></tr>
<tr class="memitem:acc5b29d5726ed866e6fca398f4baf104 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement" id="r_acc5b29d5726ed866e6fca398f4baf104"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a22ec72a61be2b9e5099230e3e5ce6015">refinement_pair_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#acc5b29d5726ed866e6fca398f4baf104">refinement_container_type</a></td></tr>
<tr class="memdesc:acc5b29d5726ed866e6fca398f4baf104 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the collection of the refinement atoms and the corresponding value.  <br /></td></tr>
<tr class="separator:acc5b29d5726ed866e6fca398f4baf104 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5726d0cc5d16046a3e7b966aa1ef6 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement" id="r_adbc5726d0cc5d16046a3e7b966aa1ef6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement__refinement__key.html">AbstractRefinement_refinement_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#adbc5726d0cc5d16046a3e7b966aa1ef6">refinement_key_type</a></td></tr>
<tr class="memdesc:adbc5726d0cc5d16046a3e7b966aa1ef6 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the identifier of the refinement atom (e.g.  <br /></td></tr>
<tr class="separator:adbc5726d0cc5d16046a3e7b966aa1ef6 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbe4a943a6f7db9cd6916aa2a333508 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement" id="r_accbe4a943a6f7db9cd6916aa2a333508"><td class="memItemLeft" align="right" valign="top">typedef std::forward_list&lt; <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a22ec72a61be2b9e5099230e3e5ce6015">AbstractRefinement::refinement_pair_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#accbe4a943a6f7db9cd6916aa2a333508">refinement_list_type</a></td></tr>
<tr class="separator:accbe4a943a6f7db9cd6916aa2a333508 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ec72a61be2b9e5099230e3e5ce6015 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement" id="r_a22ec72a61be2b9e5099230e3e5ce6015"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::shared_ptr&lt; <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#adbc5726d0cc5d16046a3e7b966aa1ef6">refinement_key_type</a> &gt;, <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a73eb96ae8a839edd9139d273b3dbc57b">refinement_value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a22ec72a61be2b9e5099230e3e5ce6015">refinement_pair_type</a></td></tr>
<tr class="memdesc:a22ec72a61be2b9e5099230e3e5ce6015 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair for the refinement key and value.  <br /></td></tr>
<tr class="separator:a22ec72a61be2b9e5099230e3e5ce6015 inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eb96ae8a839edd9139d273b3dbc57b inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement" id="r_a73eb96ae8a839edd9139d273b3dbc57b"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a73eb96ae8a839edd9139d273b3dbc57b">refinement_value_type</a></td></tr>
<tr class="memdesc:a73eb96ae8a839edd9139d273b3dbc57b inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of functor value assigned to each refinement atom.  <br /></td></tr>
<tr class="separator:a73eb96ae8a839edd9139d273b3dbc57b inherit pub_types_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classsgpp_1_1base_1_1AbstractRefinement"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classsgpp_1_1base_1_1AbstractRefinement')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html">sgpp::base::AbstractRefinement</a></td></tr>
<tr class="memitem:a88d3859f2e3648262539407e9e690f3c inherit pub_static_methods_classsgpp_1_1base_1_1AbstractRefinement" id="r_a88d3859f2e3648262539407e9e690f3c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a88d3859f2e3648262539407e9e690f3c">compare_pairs</a> (const <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a22ec72a61be2b9e5099230e3e5ce6015">refinement_pair_type</a> &amp;lhs, const <a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#a22ec72a61be2b9e5099230e3e5ce6015">refinement_pair_type</a> &amp;rhs)</td></tr>
<tr class="memdesc:a88d3859f2e3648262539407e9e690f3c inherit pub_static_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of the refinement_pair_type.  <br /></td></tr>
<tr class="separator:a88d3859f2e3648262539407e9e690f3c inherit pub_static_methods_classsgpp_1_1base_1_1AbstractRefinement"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Descendant of <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html" title="Free refinement class for sparse grids.">base::HashRefinement</a> refining without the generation of hierarchical ancestors. </p>
<p>In SG++ grids (as in <a class="el" href="namespacesgpp_1_1base.html">sgpp::base</a>), every grid fulfills the "hierarchical ancestors" property, e.g. every gridpoint has a direct ancestor in every dimension whose level is &gt; 1.</p>
<p>By using this refinement class, the property doesn't necessarily hold anymore. The original <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html" title="Free refinement class for sparse grids.">base::HashRefinement</a> looks at the neigbors of a grid point to be refined. If a neighbor in a dimension and a direction (left/right) already exists, no new point is inserted. If it doesn't exist, it is inserted and all hierarchical ancestors are generated recursively.</p>
<p><a class="el" href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html" title="Descendant of base::HashRefinement refining without the generation of hierarchical ancestors.">HashRefinementMultiple</a> instead inserts exactly \(2d\) new grid points, if a point is to be refined (for Noboundary grids with \(d\) being the number of dimensions). This is done by looking at neighbors of higher levels (closer to the point to be refined) and inserting the first neighbor that doesn't exist in the grid. Additionally, no hierarchical ancestors are creating by omitting the <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a2f59c8994044b294bb1b5ed0980c882c" title="This method creates a new point on the grid.">base::HashRefinement::createGridpoint()</a> calls.</p>
<p>Grids without the "hierarchical ancestors" property don't allow most standard algorithms to be executed on them, therefore grids and basis functions are separated in this module from those in <a class="el" href="namespacesgpp_1_1base.html">sgpp::base</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a74994df16f315a0e31eb38f80a31f4" name="a9a74994df16f315a0e31eb38f80a31f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a74994df16f315a0e31eb38f80a31f4">&#9670;&#160;</a></span>collectRefinablePoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::optimization::HashRefinementMultiple::collectRefinablePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html">base::RefinementFunctor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1AbstractRefinement.html#acc5b29d5726ed866e6fca398f4baf104">base::AbstractRefinement::refinement_container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>collection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examine the grid points and stores the indices those that can be refined and have maximal indicator values. </p>
<p>This function differences from its counterpart in <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html" title="Free refinement class for sparse grids.">base::HashRefinement</a> insofar every grid point could potentially be refined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>hashmap that stores the grid points </td></tr>
    <tr><td class="paramname">functor</td><td>a PredictiveRefinementIndicator specifying the refinement criteria </td></tr>
    <tr><td class="paramname">collection</td><td>container that contains elements to refine (empty initially) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#ae4830d693c640925915d6f6e9d1d769c">sgpp::base::HashRefinement</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a86048f1c85489a20315f9e00182c6aab">sgpp::base::HashRefinement::addElementToCollection()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a1a071b11ae21ba077a473e57bada3b27">sgpp::base::HashGridStorage::begin()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a8cadbe057f429497f3bca54eb6b7ec62">sgpp::base::HashGridStorage::end()</a>, <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a3659fd43ed26f12da3075d713cd44fa5">sgpp::base::HashRefinement::getIndicator()</a>, and <a class="el" href="classsgpp_1_1base_1_1RefinementFunctor.html#a208d4add494c187ff56ac3b103c0b7bd">sgpp::base::RefinementFunctor::getRefinementsNum()</a>.</p>

</div>
</div>
<a id="aa21a8e18bb916a88fa98cfd0f07260fa" name="aa21a8e18bb916a88fa98cfd0f07260fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21a8e18bb916a88fa98cfd0f07260fa">&#9670;&#160;</a></span>getNumberOfRefinablePoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgpp::optimization::HashRefinementMultiple::getNumberOfRefinablePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of refineable points, e.g. </p>
<p>the number of all points (every grid point can be refined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>grid storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of refinable points </dd></dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a0f5cba4e555787f1525aeae025885d85">sgpp::base::HashRefinement</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>.</p>

</div>
</div>
<a id="a8c2ecf86fff5219d874a97dcbfaf289c" name="a8c2ecf86fff5219d874a97dcbfaf289c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2ecf86fff5219d874a97dcbfaf289c">&#9670;&#160;</a></span>refineGridpoint1D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::optimization::HashRefinementMultiple::refineGridpoint1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">base::GridStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a33a4f2457b9262613d8e2d6dd0d3e788">base::GridPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refines a grid point in one dimension. </p>
<p>This creates exactly two new grid points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>grid storage </td></tr>
    <tr><td class="paramname">point</td><td>point of the grid point </td></tr>
    <tr><td class="paramname">t</td><td>dimension in which the refinement should take place </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsgpp_1_1base_1_1HashRefinement.html#a7ce83c7e4858a6a65b84193d8deaf732">sgpp::base::HashRefinement</a>.</p>

<p class="reference">References <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#aeec2829448de9b5f7a72f3eed5c23fd8">sgpp::base::HashGridStorage::insert()</a>, and <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a94feb9779c78a5b637a4ead7c91cfd3e">sgpp::base::HashGridStorage::isContaining()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>optimization/src/sgpp/optimization/gridgen/<a class="el" href="HashRefinementMultiple_8hpp.html">HashRefinementMultiple.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesgpp.html">sgpp</a></li><li class="navelem"><a class="el" href="namespacesgpp_1_1optimization.html">optimization</a></li><li class="navelem"><a class="el" href="classsgpp_1_1optimization_1_1HashRefinementMultiple.html">HashRefinementMultiple</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:38:01 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
