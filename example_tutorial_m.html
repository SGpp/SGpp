<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: tutorial.m (Start Here)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('example_tutorial_m.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">tutorial.m (Start Here)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To be able to quickly start with a toolkit, it is often advantageous (not only for the impatient users), to look at some code examples first.</p>
<p>In this tutorial, we give a short example program which interpolates a bivariate function on a regular sparse grid. Identical versions of the example are given in all languages currently supported by SG++: C++, Python, Java, and MATLAB.</p>
<p>In the example, we create a two-dimensional regular sparse grid of level 3 (with grid points \(\vec{x}_j \in [0, 1]^2\)) using piecewise bilinear basis functions \(\varphi_j\colon [0, 1]^2 \to \mathbb{R}\). We then interpolate the function</p>
<p class="formulaDsp">
\[
   f\colon [0, 1]^2 \to \mathbb{R},\quad
   f(x_0, x_1) := 16 (x_0 - 1) x_0 (x_1 - 1) x_1
 \]
</p>
<p>with</p>
<p class="formulaDsp">
\[
   u\colon [0, 1]^2 \to \mathbb{R},\quad
   u(x_0, x_1) := \sum_{j=0}^{N-1} \alpha_j \varphi_j(x_0, x_1)
 \]
</p>
<p>by calculating the coefficients \(\alpha_j\) such that \(u(\vec{x}_j) = f(\vec{x}_j)\) for all \(j\). This process is called <em>hierarchization</em> in sparse grid contexts; the \(\alpha_j\) are called <em>(hierarchical) surpluses</em>. Note that \(f\) vanishes at the boundary of the domain \([0, 1]^2\); therefore, we don't have to spend sparse grid points on the boundary. Finally, we evaluate the sparse grid function \(u\) at a point \(\vec{p} = (0.52, 0.73)\).</p>
<p>Before starting, the function \(f\), which we want to interpolate, is defined. </p><div class="fragment"><div class="line"><a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a> = @(x0, x1) (16.0 * (x0 - 1.0) * x0 * (x1 - 1.0) * x1);</div>
<div class="ttc" id="aAugmentedLagrangian_8cpp_html_ac2eaf9e806b463971eb23d43900a64be"><div class="ttname"><a href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a></div><div class="ttdeci">base::ScalarFunction &amp; f</div><div class="ttdef"><b>Definition</b> AugmentedLagrangian.cpp:75</div></div>
</div><!-- fragment --><p>First, we create a two-dimensional grid (type <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a>) with piecewise bilinear basis functions with the help of the factory method <a class="el" href="classsgpp_1_1base_1_1Grid.html#aedee852987dbba26cbb973ece5dea3db" title="Creates and returns a grid without grid points on the boundary (zero boundary conditions) with piecew...">sgpp::base::Grid.createLinearGrid()</a>. </p><div class="fragment"><div class="line">dim = 2;</div>
<div class="line"><a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a> = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.Grid.createLinearGrid(dim);</div>
<div class="ttc" id="amultHPX_8cpp_html_ae871abe991ec98e4b1c09a6eaa9f1ddc"><div class="ttname"><a href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a></div><div class="ttdeci">std::unique_ptr&lt; sgpp::base::Grid &gt; grid(nullptr)</div></div>
<div class="ttc" id="anamespacesgpp_html"><div class="ttname"><a href="namespacesgpp.html">sgpp</a></div><div class="ttdoc">Class that stores, generates and manipulates a density function during online phase in on/off learnin...</div><div class="ttdef"><b>Definition</b> AlgorithmDGEMV.hpp:22</div></div>
</div><!-- fragment --><p>Then we obtain a reference to the grid's <a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089" title="Main typedef for GridStorage.">sgpp::base::GridStorage</a> object which allows us, e.g., to access grid points, to obtain the dimensionality (which we print) and the number of grid points. </p><div class="fragment"><div class="line">gridStorage = <a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>.getStorage();</div>
<div class="line">fprintf(<span class="stringliteral">&#39;dimensionality:         %u\n&#39;</span>, gridStorage.getDimension());</div>
</div><!-- fragment --><p>Now, we use a <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html" title="Abstract class that defines the interfaces for the different grid&#39;s GridGenerators.">sgpp::base::GridGenerator</a> to create a regular sparse grid of level 3. Thus, <code>gridStorage.getSize()</code> returns 17, the number of grid points of a two-dimensional regular sparse grid of level 3. </p><div class="fragment"><div class="line"><a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a> = 3;</div>
<div class="line"><a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>.getGenerator().regular(<a class="code hl_variable" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>);</div>
<div class="line">fprintf(<span class="stringliteral">&#39;number of grid points:  %u\n&#39;</span>, gridStorage.getSize());</div>
<div class="ttc" id="amultHPX_8cpp_html_a6a330c3b2adf87bfa27e9a9450d8bc40"><div class="ttname"><a href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a></div><div class="ttdeci">uint32_t level</div><div class="ttdef"><b>Definition</b> multHPX.cpp:26</div></div>
</div><!-- fragment --><p>We create an object of type <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> which is essentially a wrapper around a <code>double</code> array. The <code>DataVector</code> is initialized with as many entries as there are grid points. It serves as a coefficient vector for the sparse grid interpolant we want to construct. As the entries of a freshly created <code>DataVector</code> are not initialized, we set them to 0.0. (This is superfluous here as we initialize them in the next few lines anyway.) </p><div class="fragment"><div class="line"><a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a> = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(gridStorage.getSize());</div>
<div class="line"><a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a75b0df6e46f9d8a4bdfaaa0636a3d55a">setAll</a>(0);</div>
<div class="line">fprintf(<span class="stringliteral">&#39;length of alpha vector: %u\n&#39;</span>, <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">getSize</a>());</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a4ec9b893255175cc583323968788b1b1"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize</a></div><div class="ttdeci">size_t getSize() const</div><div class="ttdoc">gets the elements stored in the vector</div><div class="ttdef"><b>Definition</b> DataVector.hpp:365</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a75b0df6e46f9d8a4bdfaaa0636a3d55a"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a75b0df6e46f9d8a4bdfaaa0636a3d55a">sgpp::base::DataVector::setAll</a></div><div class="ttdeci">void setAll(double value)</div><div class="ttdoc">Sets all values of DataVector to value.</div><div class="ttdef"><b>Definition</b> DataVector.cpp:174</div></div>
<div class="ttc" id="amultHPX_8cpp_html_afaae4b3ccddbff855673417650052c63"><div class="ttname"><a href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a></div><div class="ttdeci">sgpp::base::DataVector alpha</div><div class="ttdef"><b>Definition</b> multHPX.cpp:40</div></div>
</div><!-- fragment --><p>The <code>for</code> loop iterates over all grid points: For each grid point <code>gp</code>, the corresponding coefficient \(\alpha_j\) is set to the function value at the grid point's coordinates which are obtained by <code>getStandardCoordinate(dim)</code>. The current coefficient vector is then printed. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0:gridStorage.getSize()-1</div>
<div class="line">    gp = gridStorage.getPoint(i);</div>
<div class="line">    <a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#a6d0d2be0da12b23b4bf5a62048fb3e7a">set</a>(i, <a class="code hl_variable" href="AugmentedLagrangian_8cpp.html#ac2eaf9e806b463971eb23d43900a64be">f</a>(gp.getStandardCoordinate(0), gp.getStandardCoordinate(1)));</div>
<div class="line">end</div>
<div class="line"> </div>
<div class="line">fprintf(<span class="stringliteral">&#39;alpha before hierarchization: %s\n&#39;</span>, <span class="keywordtype">char</span>(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">toString</a>()));</div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_a6d0d2be0da12b23b4bf5a62048fb3e7a"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#a6d0d2be0da12b23b4bf5a62048fb3e7a">sgpp::base::DataVector::set</a></div><div class="ttdeci">void set(size_t i, double value)</div><div class="ttdoc">Sets the element at index i to value.</div><div class="ttdef"><b>Definition</b> DataVector.cpp:180</div></div>
<div class="ttc" id="aclasssgpp_1_1base_1_1DataVector_html_ab353c20b73b16a72e68ce733e09eff8b"><div class="ttname"><a href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">sgpp::base::DataVector::toString</a></div><div class="ttdeci">void toString(std::string &amp;text) const</div><div class="ttdoc">Writes the data stored in the DataVector into a string.</div><div class="ttdef"><b>Definition</b> DataVector.cpp:415</div></div>
</div><!-- fragment --><p>An object of <a class="el" href="classsgpp_1_1base_1_1OperationHierarchisation.html" title="This class implements the hierarchisation and dehierarchisation on the sparse grid.">sgpp::base::OperationHierarchisation</a> is created and used to hierarchize the coefficient vector, which we print. </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.createOperationHierarchisation(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>).doHierarchisation(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>);</div>
<div class="line">fprintf(<span class="stringliteral">&#39;alpha after hierarchization:  %s\n&#39;</span>, <span class="keywordtype">char</span>(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>.<a class="code hl_function" href="classsgpp_1_1base_1_1DataVector.html#ab353c20b73b16a72e68ce733e09eff8b">toString</a>()));</div>
</div><!-- fragment --><p>Finally, a second <code>DataVector</code> is created which is used as a point to evaluate the sparse grid function at. An object is obtained which provides an evaluation operation (of type sgpp::base::OperationEvaluation), and the sparse grid interpolant is evaluated at \(\vec{p}\), which is close to (but not exactly at) a grid point. </p><div class="fragment"><div class="line">p = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.DataVector(dim);</div>
<div class="line">p.set(0, 0.52);</div>
<div class="line">p.set(1, 0.73);</div>
<div class="line">opEval = <a class="code hl_namespace" href="namespacesgpp.html">sgpp</a>.createOperationEval(<a class="code hl_function" href="multHPX_8cpp.html#ae871abe991ec98e4b1c09a6eaa9f1ddc">grid</a>);</div>
<div class="line">fprintf(<span class="stringliteral">&#39;u(0.52, 0.73) = %.4f\n&#39;</span>, opEval.eval(<a class="code hl_variable" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>,p));</div>
</div><!-- fragment --><p>The example results in the following output: </p><pre class="fragment">dimensionality:         2
number of grid points:  17
length of alpha vector: 17
alpha before hierarchization: [1, 0.75, 0.75, 0.4375, 0.9375, 0.9375, 0.4375, 0.75, 0.75, 0.4375, 0.9375, 0.9375, 0.4375, 0.5625, 0.5625, 0.5625, 0.5625]
alpha after hierarchization:  [1, 0.25, 0.25, 0.0625, 0.0625, 0.0625, 0.0625, 0.25, 0.25, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625]
u(0.52, 0.73) = 0.7696
</pre><p> It can be clearly seen that the surpluses decay with a factor of 1/4: On the first level, we obtain 1, on the second 1/4, and on the third 1/16 as surpluses. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="examples.html">Usage Examples</a></li><li class="navelem"><a class="el" href="examples_m.html">MATLAB Examples</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:36:16 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
