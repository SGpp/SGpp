<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SG++-Doxygen-Documentation: sgpp::pde::PDESolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      opt: "\\mathrm{opt}",
      norm: ["\\lVert{#1}\\rVert", 1]
    }
  }
}); 
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="sgpp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">SG++-Doxygen-Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsgpp_1_1pde_1_1PDESolver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsgpp_1_1pde_1_1PDESolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sgpp::pde::PDESolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>This class provides defines a implements basic task and tools which are useful while solving PDEs.  
 <a href="classsgpp_1_1pde_1_1PDESolver.html#details">More...</a></p>

<p><code>#include &lt;PDESolver.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sgpp::pde::PDESolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsgpp_1_1pde_1_1PDESolver.png" usemap="#sgpp::pde::PDESolver_map" alt=""/>
  <map id="sgpp::pde::PDESolver_map" name="sgpp::pde::PDESolver_map">
<area href="classsgpp_1_1pde_1_1EllipticPDESolver.html" title="This class extends the PDESolver with functions that are needed to solve elliptic PDEs." alt="sgpp::pde::EllipticPDESolver" shape="rect" coords="0,56,264,80"/>
<area href="classsgpp_1_1pde_1_1ParabolicPDESolver.html" title="This class extends the PDESolver with functions that are needed to solve parabolic PDEs." alt="sgpp::pde::ParabolicPDESolver" shape="rect" coords="411,56,675,80"/>
<area href="classsgpp_1_1pde_1_1PoissonEquationSolver.html" title="This class provides a simple-to-use solver of the multi dimensional Poisson Equation on Sparse Grids." alt="sgpp::pde::PoissonEquationSolver" shape="rect" coords="0,112,264,136"/>
<area href="classsgpp_1_1pde_1_1HeatEquationSolver.html" title="This class provides a simple-to-use solver of the multi dimensional Heat Equation on Sparse Grids." alt="sgpp::pde::HeatEquationSolver" shape="rect" coords="274,112,538,136"/>
<area href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html" title="This class provides a simple-to-use solver of the multi dimensional Heat Equation that uses Sparse Gr..." alt="sgpp::pde::HeatEquationSolverWithStretching" shape="rect" coords="548,112,812,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef887e4ad90f9ee170fdce53ac4f6bb8" id="r_aef887e4ad90f9ee170fdce53ac4f6bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aef887e4ad90f9ee170fdce53ac4f6bb8">coarsenInitialGridSurplus</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold)</td></tr>
<tr class="memdesc:aef887e4ad90f9ee170fdce53ac4f6bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coarsens a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:aef887e4ad90f9ee170fdce53ac4f6bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ecc30e2b0ac3579f7f5c4e6599eb84" id="r_a04ecc30e2b0ac3579f7f5c4e6599eb84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a04ecc30e2b0ac3579f7f5c4e6599eb84">constructGrid</a> (<a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;<a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a465a74f50df80eaf2ce1fbd413ef84bf">myBoundingBox</a>, size_t <a class="el" href="multHPX_8cpp.html#a6a330c3b2adf87bfa27e9a9450d8bc40">level</a>)=0</td></tr>
<tr class="memdesc:a04ecc30e2b0ac3579f7f5c4e6599eb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this routine the construct a regular grid to solve a PDE.  <br /></td></tr>
<tr class="separator:a04ecc30e2b0ac3579f7f5c4e6599eb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0311f95d9cf104d382f4093e8e80283" id="r_ae0311f95d9cf104d382f4093e8e80283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid</a> ()</td></tr>
<tr class="memdesc:ae0311f95d9cf104d382f4093e8e80283"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the grid created within that solver  <br /></td></tr>
<tr class="separator:ae0311f95d9cf104d382f4093e8e80283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89db95e3e95b25eefb5013f9439560c0" id="r_a89db95e3e95b25eefb5013f9439560c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a89db95e3e95b25eefb5013f9439560c0">evaluateCuboid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;FunctionValues, <a class="el" href="classsgpp_1_1base_1_1DataMatrix.html">sgpp::base::DataMatrix</a> &amp;EvaluationPoints)</td></tr>
<tr class="memdesc:a89db95e3e95b25eefb5013f9439560c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the sparse grid's function given by the stored grid and the alpha coefficients.  <br /></td></tr>
<tr class="separator:a89db95e3e95b25eefb5013f9439560c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8f8b9e656279c6b14bf27e4ee1082" id="r_a92a8f8b9e656279c6b14bf27e4ee1082"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a92a8f8b9e656279c6b14bf27e4ee1082">evaluatePoint</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;evalPoint, <a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>)</td></tr>
<tr class="memdesc:a92a8f8b9e656279c6b14bf27e4ee1082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the value of the function in the d-dimensional space.  <br /></td></tr>
<tr class="separator:a92a8f8b9e656279c6b14bf27e4ee1082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eb3364a1bca298cb3d30f417ac9291" id="r_a40eb3364a1bca298cb3d30f417ac9291"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a40eb3364a1bca298cb3d30f417ac9291">getGrid</a> () const</td></tr>
<tr class="memdesc:a40eb3364a1bca298cb3d30f417ac9291"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the a string the describes the grid which is currently used to solve  <br /></td></tr>
<tr class="separator:a40eb3364a1bca298cb3d30f417ac9291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bcff79a5a69e8f065621c4a637dd9b" id="r_a59bcff79a5a69e8f065621c4a637dd9b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a59bcff79a5a69e8f065621c4a637dd9b">getNumberDimensions</a> () const</td></tr>
<tr class="memdesc:a59bcff79a5a69e8f065621c4a637dd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this the determine the number of dimensions that are currently used in the solver.  <br /></td></tr>
<tr class="separator:a59bcff79a5a69e8f065621c4a637dd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6815ca45215bb246e21862ca281390" id="r_aab6815ca45215bb246e21862ca281390"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab6815ca45215bb246e21862ca281390">getNumberGridPoints</a> () const</td></tr>
<tr class="memdesc:aab6815ca45215bb246e21862ca281390"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to determine the number of grid points, used to solve the current problem  <br /></td></tr>
<tr class="separator:aab6815ca45215bb246e21862ca281390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45128f2082e8d53a167c2a90bfdd7e83" id="r_a45128f2082e8d53a167c2a90bfdd7e83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a45128f2082e8d53a167c2a90bfdd7e83">getNumberInnerGridPoints</a> () const</td></tr>
<tr class="memdesc:a45128f2082e8d53a167c2a90bfdd7e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to determine the number of inner grid points, used to solve the current problem  <br /></td></tr>
<tr class="separator:a45128f2082e8d53a167c2a90bfdd7e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79313aacae20fce23c6e8abdc3305d45" id="r_a79313aacae20fce23c6e8abdc3305d45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a79313aacae20fce23c6e8abdc3305d45">PDESolver</a> ()</td></tr>
<tr class="memdesc:a79313aacae20fce23c6e8abdc3305d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Constructor of the solver.  <br /></td></tr>
<tr class="separator:a79313aacae20fce23c6e8abdc3305d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78e4cc143f26d2d106495cd81058ba3" id="r_ac78e4cc143f26d2d106495cd81058ba3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac78e4cc143f26d2d106495cd81058ba3">printGrid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t PointesPerDimension, std::string tfilename) const</td></tr>
<tr class="memdesc:ac78e4cc143f26d2d106495cd81058ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is some kind of debug functionality.  <br /></td></tr>
<tr class="separator:ac78e4cc143f26d2d106495cd81058ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1cfdd7dbd2df1ac9d53f481f0411f2" id="r_aab1cfdd7dbd2df1ac9d53f481f0411f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab1cfdd7dbd2df1ac9d53f481f0411f2">printGridDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, size_t PointesPerDimension, <a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;GridArea, std::string tfilename) const</td></tr>
<tr class="memdesc:aab1cfdd7dbd2df1ac9d53f481f0411f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is some kind of debug functionality.  <br /></td></tr>
<tr class="separator:aab1cfdd7dbd2df1ac9d53f481f0411f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefbaefea95d2606fc318fcb1d1196e6" id="r_abefbaefea95d2606fc318fcb1d1196e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abefbaefea95d2606fc318fcb1d1196e6">printLevelIndexGrid</a> (std::string tfilename) const</td></tr>
<tr class="memdesc:abefbaefea95d2606fc318fcb1d1196e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the level,index pairs of the grid for each Gridpoint to a file.  <br /></td></tr>
<tr class="separator:abefbaefea95d2606fc318fcb1d1196e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee38bcddb2e020457a73e1fbbb7f27ec" id="r_aee38bcddb2e020457a73e1fbbb7f27ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aee38bcddb2e020457a73e1fbbb7f27ec">printSparseGrid</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::string tfilename, bool bSurplus) const</td></tr>
<tr class="memdesc:aee38bcddb2e020457a73e1fbbb7f27ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus.  <br /></td></tr>
<tr class="separator:aee38bcddb2e020457a73e1fbbb7f27ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64c62361bc2dbf9133fda9128a4631b" id="r_ac64c62361bc2dbf9133fda9128a4631b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac64c62361bc2dbf9133fda9128a4631b">printSparseGridExpTransform</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::string tfilename, bool bSurplus) const</td></tr>
<tr class="memdesc:ac64c62361bc2dbf9133fda9128a4631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus.  <br /></td></tr>
<tr class="separator:ac64c62361bc2dbf9133fda9128a4631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4c77f046a5e6c883af2a4301462cdf" id="r_a7b4c77f046a5e6c883af2a4301462cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7b4c77f046a5e6c883af2a4301462cdf">refineInitialGridSurplus</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, int numRefinePoints, double dThreshold)</td></tr>
<tr class="memdesc:a7b4c77f046a5e6c883af2a4301462cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a7b4c77f046a5e6c883af2a4301462cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166862b23257a31d1dca95f3e2b7431" id="r_a3166862b23257a31d1dca95f3e2b7431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, int numRefinePoints, double dThreshold, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a3166862b23257a31d1dca95f3e2b7431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a3166862b23257a31d1dca95f3e2b7431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47e14878284049156d5e63e5217986" id="r_abb47e14878284049156d5e63e5217986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abb47e14878284049156d5e63e5217986">refineInitialGridSurplusToMaxLevel</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold, <a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a> maxLevel)</td></tr>
<tr class="memdesc:abb47e14878284049156d5e63e5217986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:abb47e14878284049156d5e63e5217986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481446a6b4cc4f10f5f26b383417c968" id="r_a481446a6b4cc4f10f5f26b383417c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, double dThreshold, <a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a> maxLevel, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a481446a6b4cc4f10f5f26b383417c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a grid by taking the grid's coefficients into account.  <br /></td></tr>
<tr class="separator:a481446a6b4cc4f10f5f26b383417c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc81f7ec6fcf8216c478ca2237b1a0ae" id="r_adc81f7ec6fcf8216c478ca2237b1a0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid</a> (const std::string &amp;serializedGrid)</td></tr>
<tr class="memdesc:adc81f7ec6fcf8216c478ca2237b1a0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the grid used in this BlackScholes Solver by an given serialized string of the grid.  <br /></td></tr>
<tr class="separator:adc81f7ec6fcf8216c478ca2237b1a0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917d693b9b3f883d88dcb6f54041784" id="r_a7917d693b9b3f883d88dcb6f54041784"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7917d693b9b3f883d88dcb6f54041784">~PDESolver</a> ()</td></tr>
<tr class="memdesc:a7917d693b9b3f883d88dcb6f54041784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Std-Destructor of the solver.  <br /></td></tr>
<tr class="separator:a7917d693b9b3f883d88dcb6f54041784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9827af10992190a4f3c1fb12af05b833" id="r_a9827af10992190a4f3c1fb12af05b833"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution</a> (<a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;<a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, std::vector&lt; double &gt; &amp;norm_mu, std::vector&lt; double &gt; &amp;norm_sigma)</td></tr>
<tr class="memdesc:a9827af10992190a4f3c1fb12af05b833"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates for every grid point the value of a normal distribution given by norm_mu and norm_sigma.  <br /></td></tr>
<tr class="separator:a9827af10992190a4f3c1fb12af05b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac46f28fe1db45d35b227e62d3ac7a0f5" id="r_ac46f28fe1db45d35b227e62d3ac7a0f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a></td></tr>
<tr class="memdesc:ac46f28fe1db45d35b227e62d3ac7a0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores if the grid was created inside the solver  <br /></td></tr>
<tr class="separator:ac46f28fe1db45d35b227e62d3ac7a0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a0a1948e622c6c9b516f51a8db8fc" id="r_aac9a0a1948e622c6c9b516f51a8db8fc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">dim</a></td></tr>
<tr class="memdesc:aac9a0a1948e622c6c9b516f51a8db8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">the dimension of the grid  <br /></td></tr>
<tr class="separator:aac9a0a1948e622c6c9b516f51a8db8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50e57ef6db91938b72675063b5c608" id="r_aff50e57ef6db91938b72675063b5c608"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aff50e57ef6db91938b72675063b5c608">levels</a></td></tr>
<tr class="memdesc:aff50e57ef6db91938b72675063b5c608"><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of levels used for an regular grid  <br /></td></tr>
<tr class="separator:aff50e57ef6db91938b72675063b5c608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a74f50df80eaf2ce1fbd413ef84bf" id="r_a465a74f50df80eaf2ce1fbd413ef84bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a465a74f50df80eaf2ce1fbd413ef84bf">myBoundingBox</a></td></tr>
<tr class="memdesc:a465a74f50df80eaf2ce1fbd413ef84bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores Pointer to the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a>'s Bounding Box.  <br /></td></tr>
<tr class="separator:a465a74f50df80eaf2ce1fbd413ef84bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a7d65c5d2d3b0843874070b8716d8" id="r_a104a7d65c5d2d3b0843874070b8716d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a></td></tr>
<tr class="memdesc:a104a7d65c5d2d3b0843874070b8716d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> needed in this classificator.  <br /></td></tr>
<tr class="separator:a104a7d65c5d2d3b0843874070b8716d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36857d2d44fef8e2aa2c78f87c97ec0e" id="r_a36857d2d44fef8e2aa2c78f87c97ec0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">sgpp::base::GridStorage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a></td></tr>
<tr class="memdesc:a36857d2d44fef8e2aa2c78f87c97ec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores Pointer to the Girs's Storage.  <br /></td></tr>
<tr class="separator:a36857d2d44fef8e2aa2c78f87c97ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides defines a implements basic task and tools which are useful while solving PDEs. </p>
<p>E.g. grid construction, simple grid evaluation tools grid printing, initial grid refinement etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a79313aacae20fce23c6e8abdc3305d45" name="a79313aacae20fce23c6e8abdc3305d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79313aacae20fce23c6e8abdc3305d45">&#9670;&#160;</a></span>PDESolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sgpp::pde::PDESolver::PDESolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Std-Constructor of the solver. </p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>.</p>

</div>
</div>
<a id="a7917d693b9b3f883d88dcb6f54041784" name="a7917d693b9b3f883d88dcb6f54041784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7917d693b9b3f883d88dcb6f54041784">&#9670;&#160;</a></span>~PDESolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sgpp::pde::PDESolver::~PDESolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Std-Destructor of the solver. </p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef887e4ad90f9ee170fdce53ac4f6bb8" name="aef887e4ad90f9ee170fdce53ac4f6bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef887e4ad90f9ee170fdce53ac4f6bb8">&#9670;&#160;</a></span>coarsenInitialGridSurplus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::coarsenInitialGridSurplus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coarsens a grid by taking the grid's coefficients into account. </p>
<p>This coarsen method coarsens the grid based on the surplus by coarsening grid points with small surpluses first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> containing the grids coefficients </td></tr>
    <tr><td class="paramname">dThreshold</td><td>Threshold for a point's surplus for coarsening this point </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#ab3528d822006954a7129446b7eb2d8bd">sgpp::base::GridGenerator::coarsenNFirstOnly()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a9c977e458179a88b7d2ea4059b43a9bd">sgpp::base::GridGenerator::getNumberOfRemovablePoints()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a163ccf59d9ebd526c73ff7fdd17a5d01">sgpp::base::Grid::getSize()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>.</p>

</div>
</div>
<a id="a04ecc30e2b0ac3579f7f5c4e6599eb84" name="a04ecc30e2b0ac3579f7f5c4e6599eb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ecc30e2b0ac3579f7f5c4e6599eb84">&#9670;&#160;</a></span>constructGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sgpp::pde::PDESolver::constructGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>myBoundingBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this routine the construct a regular grid to solve a PDE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myBoundingBox</td><td>reference to a bounding box that describes the grid </td></tr>
    <tr><td class="paramname">level</td><td>number of the regular's grid levels </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver</a>, and <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a75dd73d88817b024255854ad9ee0851e">sgpp::pde::HeatEquationSolverWithStretching</a>.</p>

</div>
</div>
<a id="ae0311f95d9cf104d382f4093e8e80283" name="ae0311f95d9cf104d382f4093e8e80283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0311f95d9cf104d382f4093e8e80283">&#9670;&#160;</a></span>deleteGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::deleteGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes the grid created within that solver </p>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a465a74f50df80eaf2ce1fbd413ef84bf">myBoundingBox</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>.</p>

</div>
</div>
<a id="a89db95e3e95b25eefb5013f9439560c0" name="a89db95e3e95b25eefb5013f9439560c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89db95e3e95b25eefb5013f9439560c0">&#9670;&#160;</a></span>evaluateCuboid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::evaluateCuboid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>FunctionValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataMatrix.html">sgpp::base::DataMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>EvaluationPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the sparse grid's function given by the stored grid and the alpha coefficients. </p>
<p>on different points specified in EvaluationPoints and stores the result into FunctionValues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the sparse grid's coefficients </td></tr>
    <tr><td class="paramname">FunctionValues</td><td><a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> into the which the result of function's evaluation is stored </td></tr>
    <tr><td class="paramname">EvaluationPoints</td><td><a class="el" href="classsgpp_1_1base_1_1DataMatrix.html" title="A class to store two-dimensional data.">sgpp::base::DataMatrix</a> that contains the points at which the sparse grid's function is evaluated </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="namespacesgpp_1_1op__factory.html#a5e3c6076873667a5ac5df6a9c4a7bebb">sgpp::op_factory::createOperationMultipleEval()</a>, <a class="el" href="classsgpp_1_1base_1_1DataMatrix.html#adf0afc9e680b3a9c12e84c087f2e66c4">sgpp::base::DataMatrix::getNrows()</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize()</a>, <a class="el" href="classsgpp_1_1base_1_1OperationMultipleEval.html#aa024c7dc0998da50078b33eb0521f27a">sgpp::base::OperationMultipleEval::mult()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>.</p>

</div>
</div>
<a id="a92a8f8b9e656279c6b14bf27e4ee1082" name="a92a8f8b9e656279c6b14bf27e4ee1082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a8f8b9e656279c6b14bf27e4ee1082">&#9670;&#160;</a></span>evaluatePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sgpp::pde::PDESolver::evaluatePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>evalPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the value of the function in the d-dimensional space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evalPoint</td><td>coordinates of the point at which the function should be evaluated </td></tr>
    <tr><td class="paramname">alpha</td><td>the ansatzfunctions' coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>price of option for given point </dd></dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="namespacesgpp_1_1op__factory.html#afa95f55361a896584bf43d487d8c4ca8">sgpp::op_factory::createOperationEval()</a>, and <a class="el" href="classsgpp_1_1base_1_1OperationEval.html#a3c5070cded7cf77bd493001406475002">sgpp::base::OperationEval::eval()</a>.</p>

</div>
</div>
<a id="a40eb3364a1bca298cb3d30f417ac9291" name="a40eb3364a1bca298cb3d30f417ac9291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40eb3364a1bca298cb3d30f417ac9291">&#9670;&#160;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sgpp::pde::PDESolver::getGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the a string the describes the grid which is currently used to solve </p>
<dl class="section return"><dt>Returns</dt><dd>a string containing a serialized grid </dd></dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1Grid.html#a6b1410821d8627ca9f694a64c896a61d">sgpp::base::Grid::serialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpython_1_1uq_1_1analysis_1_1asgc_1_1ASGCKnowledge_1_1ASGCKnowledge.html#a5291c206f5d165763cc0bfb1d1ff20a4">python.uq.analysis.asgc.ASGCKnowledge.ASGCKnowledge::getSparseGridFunction()</a>, <a class="el" href="classpython_1_1uq_1_1learner_1_1SimulationLearner_1_1SimulationLearner.html#a2a26f6fd0b5f15559fab243b8727cbe3">python.uq.learner.SimulationLearner.SimulationLearner::learnData()</a>, <a class="el" href="classpython_1_1uq_1_1learner_1_1SimulationLearner_1_1SimulationLearner.html#a1f13efaaaa7cfe4283dac38aea9748fc">python.uq.learner.SimulationLearner.SimulationLearner::learnDataWithFolding()</a>, <a class="el" href="classpython_1_1uq_1_1learner_1_1SimulationLearner_1_1SimulationLearner.html#a4291491bc7d78410564c077712f0c67d">python.uq.learner.SimulationLearner.SimulationLearner::learnDataWithTest()</a>, and <a class="el" href="classpython_1_1uq_1_1learner_1_1SimulationLearner_1_1SimulationLearner.html#a6c0ca8427a6a42b89119c33924512f17">python.uq.learner.SimulationLearner.SimulationLearner::refineGrid()</a>.</p>

</div>
</div>
<a id="a9827af10992190a4f3c1fb12af05b833" name="a9827af10992190a4f3c1fb12af05b833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9827af10992190a4f3c1fb12af05b833">&#9670;&#160;</a></span>getGridNormalDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::getGridNormalDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates for every grid point the value of a normal distribution given by norm_mu and norm_sigma. </p>
<p>The result is stored dehierarchized in alpha.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>contains dehierarchized sparse grid coefficients containing the values of the multi dimensional normal distribution after call </td></tr>
    <tr><td class="paramname">norm_mu</td><td>the expected values of the normal distribution for every grid dimension </td></tr>
    <tr><td class="paramname">norm_sigma</td><td>the standard deviation of the normal distribution for every grid dimension </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">dim</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a6878101532f42b8770e3e8842f74ba0b">sgpp::base::HashGridStorage::getCoordinates()</a>, <a class="el" href="classsgpp_1_1base_1_1StdNormalDistribution.html#acf937f18efcdb91b2302f1343eb7158d">sgpp::base::StdNormalDistribution::getDensity()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#af261ad6948876baada8b4cea521c3113">sgpp::base::HashGridStorage::getPoint()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a163ccf59d9ebd526c73ff7fdd17a5d01">sgpp::base::Grid::getSize()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>.</p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain()</a>.</p>

</div>
</div>
<a id="a59bcff79a5a69e8f065621c4a637dd9b" name="a59bcff79a5a69e8f065621c4a637dd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bcff79a5a69e8f065621c4a637dd9b">&#9670;&#160;</a></span>getNumberDimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgpp::pde::PDESolver::getNumberDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this the determine the number of dimensions that are currently used in the solver. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the number of the grid's dimensions, if the grid isn't constructed, yet it returns 0 </dd></dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a652cad463eae50018eaf71a357c32ebd">sgpp::base::HashGridStorage::getDimension()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>.</p>

</div>
</div>
<a id="aab6815ca45215bb246e21862ca281390" name="aab6815ca45215bb246e21862ca281390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6815ca45215bb246e21862ca281390">&#9670;&#160;</a></span>getNumberGridPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgpp::pde::PDESolver::getNumberGridPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this to determine the number of grid points, used to solve the current problem </p>
<dl class="section return"><dt>Returns</dt><dd>the number of grid points </dd></dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>.</p>

</div>
</div>
<a id="a45128f2082e8d53a167c2a90bfdd7e83" name="a45128f2082e8d53a167c2a90bfdd7e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45128f2082e8d53a167c2a90bfdd7e83">&#9670;&#160;</a></span>getNumberInnerGridPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgpp::pde::PDESolver::getNumberInnerGridPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this to determine the number of inner grid points, used to solve the current problem </p>
<dl class="section return"><dt>Returns</dt><dd>the number of inner grid points </dd></dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a5ea2d18a5fe6867f0eef2c52c8875a4d">sgpp::base::HashGridStorage::getNumberOfInnerPoints()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>.</p>

</div>
</div>
<a id="ac78e4cc143f26d2d106495cd81058ba3" name="ac78e4cc143f26d2d106495cd81058ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78e4cc143f26d2d106495cd81058ba3">&#9670;&#160;</a></span>printGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::printGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PointesPerDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is some kind of debug functionality. </p>
<p>It writes a file, that can be used with gnuplot the print the grid.</p>
<p>Is only implemented for 1D and 2D grids!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">PointesPerDimension</td><td>the distance between evaluation points </td></tr>
    <tr><td class="paramname">tfilename</td><td>absolute path to file into which the grid's evaluation is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a06d08080266d2a23666361030910f4ae">sgpp::pde::HeatEquationSolverWithStretching</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinter.html#a8ac768be3edd2fb1171e2e095bb35175">sgpp::base::GridPrinter::printGrid()</a>.</p>

</div>
</div>
<a id="aab1cfdd7dbd2df1ac9d53f481f0411f2" name="aab1cfdd7dbd2df1ac9d53f481f0411f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1cfdd7dbd2df1ac9d53f481f0411f2">&#9670;&#160;</a></span>printGridDomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::printGridDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PointesPerDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>GridArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is some kind of debug functionality. </p>
<p>It writes a file, that can be used with gnuplot the print the grid.</p>
<p>Is only implemented for 2D grids!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the Sparse Gird's basis functions </td></tr>
    <tr><td class="paramname">PointesPerDimension</td><td>the distance between evaluation points </td></tr>
    <tr><td class="paramname">GridArea</td><td>the area in which the function should be plotted </td></tr>
    <tr><td class="paramname">tfilename</td><td>absolute path to file into which the grid's evaluation is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a4b842e84c97d964e4cdd65efcbf63d0f">sgpp::pde::HeatEquationSolverWithStretching</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinter.html#a7af238d631188a49f3b0f5cfa85e3814">sgpp::base::GridPrinter::printGridDomain()</a>.</p>

</div>
</div>
<a id="abefbaefea95d2606fc318fcb1d1196e6" name="abefbaefea95d2606fc318fcb1d1196e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefbaefea95d2606fc318fcb1d1196e6">&#9670;&#160;</a></span>printLevelIndexGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::printLevelIndexGrid </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the level,index pairs of the grid for each Gridpoint to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tfilename</td><td>relative path to file into which the grid's evaluation is written </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinter.html#ab541a66e7b257b50c58f4dd3b0f3f5f2">sgpp::base::GridPrinter::printLevelIndexGrid()</a>.</p>

</div>
</div>
<a id="aee38bcddb2e020457a73e1fbbb7f27ec" name="aee38bcddb2e020457a73e1fbbb7f27ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee38bcddb2e020457a73e1fbbb7f27ec">&#9670;&#160;</a></span>printSparseGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::printSparseGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSurplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus. </p>
<p>This function is available for all dimensions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the grid's ansatzfunctions </td></tr>
    <tr><td class="paramname">tfilename</td><td>absoulte path to the file the grid is written into </td></tr>
    <tr><td class="paramname">bSurplus</td><td>specifies whether the surplus (true) or the node basis value (false) is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa2ff946fa227995f2c9da26a40e7f89c">sgpp::pde::HeatEquationSolverWithStretching</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinter.html#ac1d88f0dc07fc764750d1de59d2222b0">sgpp::base::GridPrinter::printSparseGrid()</a>.</p>

</div>
</div>
<a id="ac64c62361bc2dbf9133fda9128a4631b" name="ac64c62361bc2dbf9133fda9128a4631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64c62361bc2dbf9133fda9128a4631b">&#9670;&#160;</a></span>printSparseGridExpTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::printSparseGridExpTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tfilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSurplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> Points of the Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> either with their node basis value or their hierarchical surplus. </p>
<p>This function is available for all dimensions.</p>
<p>The coordinates of the grid points are pushed the exp function. So log transformed grids can be plotted in cartesion coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the coefficients of the grid's ansatzfunctions </td></tr>
    <tr><td class="paramname">tfilename</td><td>absoulte path to the file the grid is written into </td></tr>
    <tr><td class="paramname">bSurplus</td><td>specifies whether the surplus (true) or the node basis value (false) is written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a7a21274ef0d75e14039d98ef16ec5bd2">sgpp::pde::HeatEquationSolverWithStretching</a>.</p>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, and <a class="el" href="classsgpp_1_1base_1_1GridPrinter.html#a1f04d6613e7bfc00feb12d35fef5aaac">sgpp::base::GridPrinter::printSparseGridExpTransform()</a>.</p>

</div>
</div>
<a id="a7b4c77f046a5e6c883af2a4301462cdf" name="a7b4c77f046a5e6c883af2a4301462cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4c77f046a5e6c883af2a4301462cdf">&#9670;&#160;</a></span>refineInitialGridSurplus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::refineInitialGridSurplus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRefinePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid by taking the grid's coefficients into account. </p>
<p>This refinement method refines the grid based on the surplus by refining grid points with big surpluses first. The number of grid points to refine may be specified by the numRefinePoints parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> containing the grids coefficients </td></tr>
    <tr><td class="paramname">numRefinePoints</td><td>the number of grid points that should be refined; if this smaller than zero -&gt; all refineable points will be refined </td></tr>
    <tr><td class="paramname">dThreshold</td><td>Threshold for a point's surplus for refining this point </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a59a390fde7396d96de40f850eba1ee0b">sgpp::base::GridGenerator::getNumberOfRefinablePoints()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a95d26ca03bd3ce7d51d7f3c42134b7f1">sgpp::base::GridGenerator::refine()</a>.</p>

</div>
</div>
<a id="a3166862b23257a31d1dca95f3e2b7431" name="a3166862b23257a31d1dca95f3e2b7431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3166862b23257a31d1dca95f3e2b7431">&#9670;&#160;</a></span>refineInitialGridSurplusSubDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::refineInitialGridSurplusSubDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRefinePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid by taking the grid's coefficients into account. </p>
<p>This refinement method refines the grid based on the surplus by refining grid points with big surpluses first. The number of grid points to refine may be specified by the numRefinePoints parameter.</p>
<p>This functions refines the grid only in subdomain specified by a multi-dimensional normal distribution. The normal distribution is given by the parameters norm_mu and norm_sigma which are d-dimensional vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> containing the grids coefficients </td></tr>
    <tr><td class="paramname">numRefinePoints</td><td>the number of grid points that should be refined; if this smaller than zero -&gt; all refineable points will be refined </td></tr>
    <tr><td class="paramname">dThreshold</td><td>Threshold for a point's surplus for refining this point </td></tr>
    <tr><td class="paramname">norm_mu</td><td>the expected values of the normal distribution for every grid dimension </td></tr>
    <tr><td class="paramname">norm_sigma</td><td>the standard deviation of the normal distribution for every grid dimension </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html#abffc5cdf8f5fa0f5cf58f6ed039b7694">sgpp::base::DataVector::componentwise_mult()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a59a390fde7396d96de40f850eba1ee0b">sgpp::base::GridGenerator::getNumberOfRefinablePoints()</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a95d26ca03bd3ce7d51d7f3c42134b7f1">sgpp::base::GridGenerator::refine()</a>.</p>

</div>
</div>
<a id="abb47e14878284049156d5e63e5217986" name="abb47e14878284049156d5e63e5217986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb47e14878284049156d5e63e5217986">&#9670;&#160;</a></span>refineInitialGridSurplusToMaxLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::refineInitialGridSurplusToMaxLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a>&#160;</td>
          <td class="paramname"><em>maxLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid by taking the grid's coefficients into account. </p>
<p>This refinement method refines the grid based on the surplus by refining grid points with big surpluses first. The grid is refined to max. Level!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> containing the grids coefficients </td></tr>
    <tr><td class="paramname">dThreshold</td><td>Threshold for a point's surplus for refining this point </td></tr>
    <tr><td class="paramname">maxLevel</td><td>maxLevel of refinement </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a80310df94d78f798f88816206593d2a0">sgpp::base::GridGenerator::getNumberOfRefinablePointsToMaxLevel()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a93152ddc0656fdaa7a4e01d4925e3b59">sgpp::base::GridGenerator::refineMaxLevel()</a>.</p>

</div>
</div>
<a id="a481446a6b4cc4f10f5f26b383417c968" name="a481446a6b4cc4f10f5f26b383417c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481446a6b4cc4f10f5f26b383417c968">&#9670;&#160;</a></span>refineInitialGridSurplusToMaxLevelSubDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::refineInitialGridSurplusToMaxLevelSubDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgpp_1_1base_1_1DataVector.html">sgpp::base::DataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesgpp_1_1base.html#a8843d8bd0b5412e977de307e0f488137">sgpp::base::level_t</a>&#160;</td>
          <td class="paramname"><em>maxLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>norm_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a grid by taking the grid's coefficients into account. </p>
<p>This refinement method refines the grid based on the surplus by refining grid points with big surpluses first. The grid is refined to max. Level!</p>
<p>This functions refines the grid only in subdomain specified by a multi-dimensional normal distribution. The normal distribution is given by the parameters norm_mu and norm_sigma which are d-dimensional vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>a <a class="el" href="classsgpp_1_1base_1_1DataVector.html" title="A class to store one-dimensional data.">sgpp::base::DataVector</a> containing the grids coefficients </td></tr>
    <tr><td class="paramname">dThreshold</td><td>Threshold for a point's surplus for refining this point </td></tr>
    <tr><td class="paramname">maxLevel</td><td>maxLevel of refinement </td></tr>
    <tr><td class="paramname">norm_mu</td><td>the expected values of the normal distribution for every grid dimension </td></tr>
    <tr><td class="paramname">norm_sigma</td><td>the standard deviation of the normal distribution for every grid dimension </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="multHPX_8cpp.html#afaae4b3ccddbff855673417650052c63">alpha</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html#abffc5cdf8f5fa0f5cf58f6ed039b7694">sgpp::base::DataVector::componentwise_mult()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aef696e83f78c80da9332df27369b48b6">sgpp::base::Grid::getGenerator()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a80310df94d78f798f88816206593d2a0">sgpp::base::GridGenerator::getNumberOfRefinablePointsToMaxLevel()</a>, <a class="el" href="classsgpp_1_1base_1_1DataVector.html#a4ec9b893255175cc583323968788b1b1">sgpp::base::DataVector::getSize()</a>, <a class="el" href="classsgpp_1_1base_1_1HashGridStorage.html#a9cf0ca4d0af93e71780d8eb145252223">sgpp::base::HashGridStorage::getSize()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1GridGenerator.html#a93152ddc0656fdaa7a4e01d4925e3b59">sgpp::base::GridGenerator::refineMaxLevel()</a>.</p>

</div>
</div>
<a id="adc81f7ec6fcf8216c478ca2237b1a0ae" name="adc81f7ec6fcf8216c478ca2237b1a0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc81f7ec6fcf8216c478ca2237b1a0ae">&#9670;&#160;</a></span>setGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgpp::pde::PDESolver::setGrid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serializedGrid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the grid used in this BlackScholes Solver by an given serialized string of the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serializedGrid</td><td>a string that describes the grid that should be used in this solver </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac46f28fe1db45d35b227e62d3ac7a0f5">bGridConstructed</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aac9a0a1948e622c6c9b516f51a8db8fc">dim</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#aaee4c4358e54da5cfd5d81faf604734a">sgpp::base::Grid::getBoundingBox()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#ae6c7b5f549277d5dc7ca4c41d05ed462">sgpp::base::Grid::getDimension()</a>, <a class="el" href="classsgpp_1_1base_1_1Grid.html#a9de6e7d313016311d8f72a8b0b29bc56">sgpp::base::Grid::getStorage()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aff50e57ef6db91938b72675063b5c608">levels</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a465a74f50df80eaf2ce1fbd413ef84bf">myBoundingBox</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a104a7d65c5d2d3b0843874070b8716d8">myGrid</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a36857d2d44fef8e2aa2c78f87c97ec0e">myGridStorage</a>, and <a class="el" href="classsgpp_1_1base_1_1Grid.html#a219ae2741ae5608036f34f13fba6abaa">sgpp::base::Grid::unserialize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classpython_1_1controller_1_1CheckpointController_1_1CheckpointController.html#a18c8431d564998e7fccfbbe42149bc5f">python.controller.CheckpointController.CheckpointController::setLearner()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac46f28fe1db45d35b227e62d3ac7a0f5" name="ac46f28fe1db45d35b227e62d3ac7a0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46f28fe1db45d35b227e62d3ac7a0f5">&#9670;&#160;</a></span>bGridConstructed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sgpp::pde::PDESolver::bGridConstructed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stores if the grid was created inside the solver </p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aef887e4ad90f9ee170fdce53ac4f6bb8">coarsenInitialGridSurplus()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">sgpp::pde::HeatEquationSolverWithStretching::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a89db95e3e95b25eefb5013f9439560c0">evaluateCuboid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a92a8f8b9e656279c6b14bf27e4ee1082">evaluatePoint()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a40eb3364a1bca298cb3d30f417ac9291">getGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a59bcff79a5a69e8f065621c4a637dd9b">getNumberDimensions()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab6815ca45215bb246e21862ca281390">getNumberGridPoints()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a45128f2082e8d53a167c2a90bfdd7e83">getNumberInnerGridPoints()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a89b4c12005c0b0e4e3d805c42d37ee9c">sgpp::pde::HeatEquationSolver::HeatEquationSolver()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a993915578e28e38ac683a897783bfbb7">sgpp::pde::HeatEquationSolverWithStretching::HeatEquationSolverWithStretching()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a3dfe019332d9a767a61c7c29aeedf7f6">sgpp::pde::PoissonEquationSolver::initGridWithExpHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1d26d9a7da899c0182d0b83315e332ec">sgpp::pde::PoissonEquationSolver::initGridWithExpHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a3a40af76357a8d0ea57f7cbf3ac79602">sgpp::pde::HeatEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8dcd2ef641164314d24780a562c62f88">sgpp::pde::HeatEquationSolverWithStretching::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#adb2ad67e36a9aabf2ce81300293e63c7">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#abcb9fa998657d800f731580a35a3fdef">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a79313aacae20fce23c6e8abdc3305d45">PDESolver()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae47be95b797722af0d3b72796e03e249">sgpp::pde::PoissonEquationSolver::PoissonEquationSolver()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7b4c77f046a5e6c883af2a4301462cdf">refineInitialGridSurplus()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abb47e14878284049156d5e63e5217986">refineInitialGridSurplusToMaxLevel()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a37afcea834092879e5e93f06de4e3e91">sgpp::pde::HeatEquationSolver::solveCrankNicolson()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa61ab5f30a7b33949bf765d240039897">sgpp::pde::HeatEquationSolverWithStretching::solveCrankNicolson()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a28cb984705b9aa5e3a83db07f4a973a2">sgpp::pde::HeatEquationSolver::solveExplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a830bd0a65ab2cb7624786c71bba5cc67">sgpp::pde::HeatEquationSolverWithStretching::solveExplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a2e6e08faae742f3c339a1535d9291c2e">sgpp::pde::HeatEquationSolver::solveImplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a333b0cfdf1d92be4b35623773100247d">sgpp::pde::HeatEquationSolverWithStretching::solveImplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#abd17a22be1f06dc47d929c38394a9cac">sgpp::pde::HeatEquationSolver::storeInnerRHS()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a17d54869ffaa5e2bb92465d22990c8a6">sgpp::pde::HeatEquationSolver::storeInnerSolution()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7917d693b9b3f883d88dcb6f54041784">~PDESolver()</a>.</p>

</div>
</div>
<a id="aac9a0a1948e622c6c9b516f51a8db8fc" name="aac9a0a1948e622c6c9b516f51a8db8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9a0a1948e622c6c9b516f51a8db8fc">&#9670;&#160;</a></span>dim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgpp::pde::PDESolver::dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the dimension of the grid </p>

<p class="reference">Referenced by <a class="el" href="classpython_1_1data_1_1DataContainer_1_1DataContainer.html#adbf32dc379914dbdf506fe6a8773b05c">python.data.DataContainer.DataContainer::__init__()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1EstimatedDist_1_1EstimatedDist.html#a6fa4bc1ff5580e07a0bca1c5fcb4c3c0">python.uq.dists.EstimatedDist.EstimatedDist::_convertEvalPoint()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1SGDEdist_1_1SGDEdist.html#a9fc900a12c6481ca347ef3c0247f0acf">python.uq.dists.SGDEdist.SGDEdist::cdf()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">sgpp::pde::HeatEquationSolverWithStretching::constructGrid()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1KDEDist_1_1KDEDist.html#a4fec51bc9aa2b9b227fc9c49da31aead">python.uq.dists.KDEDist.KDEDist::cov()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1SGDEdist_1_1SGDEdist.html#a14c601ba1a850838d6533ad11b9e17f6">python.uq.dists.SGDEdist.SGDEdist::cov()</a>, <a class="el" href="classpython_1_1data_1_1DataContainer_1_1DataContainer.html#aef30e41e6d2a40ae6bfc1cb3d051a7d3">python.data.DataContainer.DataContainer::getDataSubsetByIndexList()</a>, <a class="el" href="classpython_1_1data_1_1DataContainer_1_1DataContainer.html#a042e1563ed980d67a786f4d6020d8994">python.data.DataContainer.DataContainer::getDim()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1EstimatedDist_1_1EstimatedDist.html#a87123c1fd6d16156f5c4329e17945bbc">python.uq.dists.EstimatedDist.EstimatedDist::getDim()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1LibAGFDist_1_1LibAGFDist.html#a3dc7d1fff377a0276e79ef6fbe37cfc0">python.uq.dists.LibAGFDist.LibAGFDist::getDim()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1NatafDist_1_1NatafDist.html#abd180f3fdc4f75c3bb0669c8c0383927">python.uq.dists.NatafDist.NatafDist::getDim()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a3dfe019332d9a767a61c7c29aeedf7f6">sgpp::pde::PoissonEquationSolver::initGridWithExpHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1d26d9a7da899c0182d0b83315e332ec">sgpp::pde::PoissonEquationSolver::initGridWithExpHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a3a40af76357a8d0ea57f7cbf3ac79602">sgpp::pde::HeatEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8dcd2ef641164314d24780a562c62f88">sgpp::pde::HeatEquationSolverWithStretching::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#adb2ad67e36a9aabf2ce81300293e63c7">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#abcb9fa998657d800f731580a35a3fdef">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeatFullDomain()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1SGDEdist_1_1SGDEdist.html#ab5dab0bc2c12de02c866e62f6cae1d35">python.uq.dists.SGDEdist.SGDEdist::ppf()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1EstimatedDist_1_1EstimatedDist.html#a181f12b58b55f3baca96d50ebfe78bf9">python.uq.dists.EstimatedDist.EstimatedDist::rvs()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1NatafDist_1_1NatafDist.html#a357a217ef8709f8d5132591603ede31a">python.uq.dists.NatafDist.NatafDist::rvs()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1KDEDist_1_1KDEDist.html#a69027f62f5ec9559b734445a356804b3">python.uq.dists.KDEDist.KDEDist::rvs()</a>, <a class="el" href="classpython_1_1uq_1_1dists_1_1SGDEdist_1_1SGDEdist.html#a6ff53293040f6371c96d2a8ba8cefec8">python.uq.dists.SGDEdist.SGDEdist::rvs()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>, <a class="el" href="classpython_1_1uq_1_1operations_1_1natafTransformation_1_1NatafTransformation.html#a4cce651068900242716a785d709f16c8">python.uq.operations.natafTransformation.NatafTransformation::trans_X_to_Z()</a>, and <a class="el" href="classpython_1_1uq_1_1operations_1_1natafTransformation_1_1NatafTransformation.html#a6ed6a3d4b63ff8b17f1dcc45049a9723">python.uq.operations.natafTransformation.NatafTransformation::trans_Z_to_X()</a>.</p>

</div>
</div>
<a id="aff50e57ef6db91938b72675063b5c608" name="aff50e57ef6db91938b72675063b5c608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff50e57ef6db91938b72675063b5c608">&#9670;&#160;</a></span>levels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sgpp::pde::PDESolver::levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the number of levels used for an regular grid </p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">sgpp::pde::HeatEquationSolverWithStretching::constructGrid()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>.</p>

</div>
</div>
<a id="a465a74f50df80eaf2ce1fbd413ef84bf" name="a465a74f50df80eaf2ce1fbd413ef84bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465a74f50df80eaf2ce1fbd413ef84bf">&#9670;&#160;</a></span>myBoundingBox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsgpp_1_1base_1_1BoundingBox.html">sgpp::base::BoundingBox</a>* sgpp::pde::PDESolver::myBoundingBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores Pointer to the <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a>'s Bounding Box. </p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a3dfe019332d9a767a61c7c29aeedf7f6">sgpp::pde::PoissonEquationSolver::initGridWithExpHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#adb2ad67e36a9aabf2ce81300293e63c7">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeat()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>.</p>

</div>
</div>
<a id="a104a7d65c5d2d3b0843874070b8716d8" name="a104a7d65c5d2d3b0843874070b8716d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104a7d65c5d2d3b0843874070b8716d8">&#9670;&#160;</a></span>myGrid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsgpp_1_1base_1_1Grid.html">sgpp::base::Grid</a>* sgpp::pde::PDESolver::myGrid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Sparse <a class="el" href="classsgpp_1_1base_1_1Grid.html" title="abstract base class for all types grids used in sgpp the class gives pure virtual function definition...">sgpp::base::Grid</a> needed in this classificator. </p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aef887e4ad90f9ee170fdce53ac4f6bb8">coarsenInitialGridSurplus()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">sgpp::pde::HeatEquationSolverWithStretching::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a89db95e3e95b25eefb5013f9439560c0">evaluateCuboid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a40eb3364a1bca298cb3d30f417ac9291">getGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a3dfe019332d9a767a61c7c29aeedf7f6">sgpp::pde::PoissonEquationSolver::initGridWithExpHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1d26d9a7da899c0182d0b83315e332ec">sgpp::pde::PoissonEquationSolver::initGridWithExpHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a3a40af76357a8d0ea57f7cbf3ac79602">sgpp::pde::HeatEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8dcd2ef641164314d24780a562c62f88">sgpp::pde::HeatEquationSolverWithStretching::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#adb2ad67e36a9aabf2ce81300293e63c7">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#abcb9fa998657d800f731580a35a3fdef">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a06d08080266d2a23666361030910f4ae">sgpp::pde::HeatEquationSolverWithStretching::printGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac78e4cc143f26d2d106495cd81058ba3">printGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab1cfdd7dbd2df1ac9d53f481f0411f2">printGridDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#ae25c8115e2d2f00da1ffa78b3c49616d">sgpp::pde::HeatEquationSolverWithStretching::printGridDomainStretching()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abefbaefea95d2606fc318fcb1d1196e6">printLevelIndexGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa2ff946fa227995f2c9da26a40e7f89c">sgpp::pde::HeatEquationSolverWithStretching::printSparseGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aee38bcddb2e020457a73e1fbbb7f27ec">printSparseGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a7a21274ef0d75e14039d98ef16ec5bd2">sgpp::pde::HeatEquationSolverWithStretching::printSparseGridExpTransform()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ac64c62361bc2dbf9133fda9128a4631b">printSparseGridExpTransform()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7b4c77f046a5e6c883af2a4301462cdf">refineInitialGridSurplus()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abb47e14878284049156d5e63e5217986">refineInitialGridSurplusToMaxLevel()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a37afcea834092879e5e93f06de4e3e91">sgpp::pde::HeatEquationSolver::solveCrankNicolson()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aa61ab5f30a7b33949bf765d240039897">sgpp::pde::HeatEquationSolverWithStretching::solveCrankNicolson()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a28cb984705b9aa5e3a83db07f4a973a2">sgpp::pde::HeatEquationSolver::solveExplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a830bd0a65ab2cb7624786c71bba5cc67">sgpp::pde::HeatEquationSolverWithStretching::solveExplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a2e6e08faae742f3c339a1535d9291c2e">sgpp::pde::HeatEquationSolver::solveImplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a333b0cfdf1d92be4b35623773100247d">sgpp::pde::HeatEquationSolverWithStretching::solveImplicitEuler()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae879ff41dc97931b01385b7af6e4c948">sgpp::pde::PoissonEquationSolver::solvePDE()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1546ee7b0507268a297acf29ba61433c">sgpp::pde::PoissonEquationSolver::storeInnerRHS()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#abd17a22be1f06dc47d929c38394a9cac">sgpp::pde::HeatEquationSolver::storeInnerRHS()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1d13b31dd216ec52573199966d91cfba">sgpp::pde::PoissonEquationSolver::storeInnerSolution()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a17d54869ffaa5e2bb92465d22990c8a6">sgpp::pde::HeatEquationSolver::storeInnerSolution()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7917d693b9b3f883d88dcb6f54041784">~PDESolver()</a>.</p>

</div>
</div>
<a id="a36857d2d44fef8e2aa2c78f87c97ec0e" name="a36857d2d44fef8e2aa2c78f87c97ec0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36857d2d44fef8e2aa2c78f87c97ec0e">&#9670;&#160;</a></span>myGridStorage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesgpp_1_1base.html#a28b49a5ec2b860b2ac182d6403a90089">sgpp::base::GridStorage</a>* sgpp::pde::PDESolver::myGridStorage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores Pointer to the Girs's Storage. </p>

<p class="reference">Referenced by <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a410426159b608f98dae32bc488c10aac">sgpp::pde::HeatEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#ae5faf552e12a9f147cb5baf3a5497c77">sgpp::pde::PoissonEquationSolver::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#aaac81680ff24ab68b9237acbffc54669">sgpp::pde::HeatEquationSolverWithStretching::constructGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#ae0311f95d9cf104d382f4093e8e80283">deleteGrid()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a9827af10992190a4f3c1fb12af05b833">getGridNormalDistribution()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a59bcff79a5a69e8f065621c4a637dd9b">getNumberDimensions()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#aab6815ca45215bb246e21862ca281390">getNumberGridPoints()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a45128f2082e8d53a167c2a90bfdd7e83">getNumberInnerGridPoints()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a3dfe019332d9a767a61c7c29aeedf7f6">sgpp::pde::PoissonEquationSolver::initGridWithExpHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#a1d26d9a7da899c0182d0b83315e332ec">sgpp::pde::PoissonEquationSolver::initGridWithExpHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolver.html#a3a40af76357a8d0ea57f7cbf3ac79602">sgpp::pde::HeatEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1HeatEquationSolverWithStretching.html#a8dcd2ef641164314d24780a562c62f88">sgpp::pde::HeatEquationSolverWithStretching::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#adb2ad67e36a9aabf2ce81300293e63c7">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeat()</a>, <a class="el" href="classsgpp_1_1pde_1_1PoissonEquationSolver.html#abcb9fa998657d800f731580a35a3fdef">sgpp::pde::PoissonEquationSolver::initGridWithSmoothHeatFullDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a7b4c77f046a5e6c883af2a4301462cdf">refineInitialGridSurplus()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a3166862b23257a31d1dca95f3e2b7431">refineInitialGridSurplusSubDomain()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#abb47e14878284049156d5e63e5217986">refineInitialGridSurplusToMaxLevel()</a>, <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#a481446a6b4cc4f10f5f26b383417c968">refineInitialGridSurplusToMaxLevelSubDomain()</a>, and <a class="el" href="classsgpp_1_1pde_1_1PDESolver.html#adc81f7ec6fcf8216c478ca2237b1a0ae">setGrid()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>pde/src/sgpp/pde/application/<a class="el" href="PDESolver_8hpp.html">PDESolver.hpp</a></li>
<li>pde/src/sgpp/pde/application/<a class="el" href="PDESolver_8cpp.html">PDESolver.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesgpp.html">sgpp</a></li><li class="navelem"><a class="el" href="namespacesgpp_1_1pde.html">pde</a></li><li class="navelem"><a class="el" href="classsgpp_1_1pde_1_1PDESolver.html">PDESolver</a></li>
    <li class="footer">Generated on Thu Feb 13 2025 14:51:21 for SG++-Doxygen-Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
